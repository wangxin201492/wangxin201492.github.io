<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="wangxin201492">
<meta property="og:url" content="https://wangxin201492.github.io/index.html">
<meta property="og:site_name" content="wangxin201492">
<meta property="og:description" content="my blogs">
<meta property="article:author" content="wangxin201492">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangxin201492.github.io/"/>





  <title>wangxin201492</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b4b40ab284f92e7b4921a8198acda5b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wangxin201492</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/MongoDB-sharding-troubleshoot-cacheRefreshX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/MongoDB-sharding-troubleshoot-cacheRefreshX/" itemprop="url">MongoDB 路由表刷新导致响应慢</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-29T14:16:20+08:00">
                2020-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MongoDB sharding 实例从 <strong>3.4版本</strong> 升级到 <strong>4.0版本</strong> 以后插入性能明显降低，观察日志发现大量的 <code>insert</code> 请求慢日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:46.563+0800 I COMMAND [conn1528] command sdb.sColl command: insert &#123; insert: &quot;sColl&quot;, xxx&#125; ... locks: &#123;Global: &#123; acquireCount: &#123; r: 6, w: 2 &#125; &#125;, Database: &#123; acquireCount: &#123; r: 2, w: 2 &#125; &#125;, Collection: &#123; acquireCount: &#123; r: 2, w: 2 &#125;, acquireWaitCount: &#123; r: 1 &#125;, timeAcquiringMicros: &#123; r: 2709634 &#125; &#125; &#125; protocol:op_msg 2756ms</span><br></pre></td></tr></table></figure>

<p>日志中可以看到 <code>insert</code> 请求执行获取 collection 上的 IS锁 2次，其中一次发生等待，等待时间为2.7s，这与 <code>insert</code> 请求执行时间保持一致。说明性能降低与<strong>锁等待</strong>有明显的相关性。</p>
<p>追溯日志发现 2.7s 前，系统正在进行 collection 元数据刷新（2.7s的时长与collection本身chunk较多相关）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:43.853+0800 I SH_REFR [ConfigServerCatalogCacheLoader-20] Refresh for collection sdb.sColl from version 25550573|83||5f59e113f7f9b49e704c227f to version 25550574|264||5f59e113f7f9b49e704c227f took 8676ms</span><br><span class="line">2020-08-19T16:40:43.853+0800 I SHARDING [conn1527] Updating collection metadata for collection sdb.sColl from collection version: 25550573|83||5f59e113f7f9b49e704c227f, shard version: 25550573|72||5f59e113f7f9b49e704c227f to collection version: 25550574|264||5f59e113f7f9b49e704c227f, shard version: 25550574|248||5f59e113f7f9b49e704c227f</span><br></pre></td></tr></table></figure>



<h2 id="chunk-版本信息"><a href="#chunk-版本信息" class="headerlink" title="chunk 版本信息"></a>chunk 版本信息</h2><p>首先，我们来理解下上文中的版本信息。在上文日志中看到，shard version 和 collection version 形式均为 「25550573|83||5f59e113f7f9b49e704c227f」，这即是一个 chunk version，通过 “|” 和 “||” 将版本信息分为三段：</p>
<ul>
<li>第一段为 <code>major version</code> : 整数，用于<strong>辨识路由指向是否发生变化，以便各节点及时更新路由</strong>。比如在发生chunk 在 shard 之间迁移时会增加</li>
<li>第二段为 <code>minor version</code> : 整数，主要用于记录<strong>不影响路由指向的一些变化</strong>。比如chunk 发生 split 时增加</li>
<li>第三段为 <code>epoch</code> : objectID，标识集合的唯一实例，用于<strong>辨识集合是否发生了变化</strong>。只有当 collection 被 drop 或者 collection的shardKey发生refined时 会重新生成</li>
</ul>
<p><strong>shard version</strong> 为 sharded collection 在目标shard上最高的 chunk version</p>
<p><strong>collection version</strong> 为 sharded collection 在所有shard上最高的 chunk version</p>
<blockquote>
<p>下文 “路由更新触发场景” - “场景一：请求触发” 中就描述了使用 shard version 来触发路由更新的典型应用场景。</p>
</blockquote>
<h2 id="路由信息存储"><a href="#路由信息存储" class="headerlink" title="路由信息存储"></a>路由信息存储</h2><p>sharded collection 的路由信息被记录在 configServer 的 <a href="https://docs.mongodb.com/manual/reference/config-database/#config.chunks" target="_blank" rel="noopener">config.chunks</a> 集合中，而 mongos&amp;shardServer 则按需从 configServer 中加载到本地缓存(CatalogCache)中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.chunks</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"sdb.sColl-name_106.0"</span>,</span><br><span class="line">        "lastmod" : Timestamp(4, 2),</span><br><span class="line">        "lastmodEpoch" : ObjectId("5f3ce659e6957ccdd6a56364"),</span><br><span class="line">        "ns" : "sdb.sColl",</span><br><span class="line">        "min" : &#123;</span><br><span class="line">                "name" : 106</span><br><span class="line">        &#125;,</span><br><span class="line">        "max" : &#123;</span><br><span class="line">                "name" : 107</span><br><span class="line">        &#125;,</span><br><span class="line">        "shard" : "mongod8320",</span><br><span class="line">        "history" : [</span><br><span class="line">                &#123;</span><br><span class="line">                        "validAfter" : Timestamp(1598001590, 84),</span><br><span class="line">                        "shard" : "mongod8320"</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中记录的 document 表示该 chunk ：</p>
<ul>
<li>所属的 namespace 为 “sdb.sColl”，其 epoch 为 “5f3ce659e6957ccdd6a56364”</li>
<li>chunk区间为 {“name”: 106} ~ {“name”: 107}，chunk版本为 {major=4, minor=2}，在 mongod8320 的shard上</li>
<li>同时记录了一些历史信息</li>
</ul>
<h2 id="路由更新触发场景"><a href="#路由更新触发场景" class="headerlink" title="路由更新触发场景"></a>路由更新触发场景</h2><p>路由更新采用 “lazy” 的机制，非必须的场景下不会进行路由更新。主要有2种场景会进行路由刷新：</p>
<h3 id="场景一：请求触发"><a href="#场景一：请求触发" class="headerlink" title="场景一：请求触发"></a>场景一：请求触发</h3><p>mongos 收到客户端请求后，根据当前 CatalogCache 缓存中的路由信息，为客户端请求增加一个 <strong>「shardVersion」</strong> 的元信息。然后按照路由信息将请求分发到目标shard上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  insert: "sCollName", </span><br><span class="line">  documents: [ &#123; _id: ObjectId('5f685824c800cd1689ca3be8'), name: xxxx &#125; ], </span><br><span class="line">  shardVersion: [ Timestamp(5, 1), ObjectId('5f3ce659e6957ccdd6a56364') ], </span><br><span class="line">  $db: "sdb"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shardServer 收到 mongos 发来的请求后，提取其中的 <strong>「shardVersion」</strong> 字段，并与本地存储的 <strong>「shardVersion」</strong>进行比较。比较二者 <code>epoch &amp; majorVersion</code> 是否相同，相同则认为可以进行写入。如果版本不匹配，则抛出一个 <code>StaleConfigInfo</code> 异常。对于该异常，shardServer&amp;mongos 均会进行处理，逻辑基本一致：如果本地路由信息是低版本的，则进行路由刷新。</p>
<h3 id="场景二：特殊请求"><a href="#场景二：特殊请求" class="headerlink" title="场景二：特殊请求"></a>场景二：特殊请求</h3><ul>
<li>一些命令执行一定会触发路由信息变化，比如 <code>moveChunk</code></li>
<li>受其他节点行为影响，收到 <code>forceRoutingTableRefresh</code> 命令，强制刷新</li>
<li>一些行为必须要获取最新的路由信息，比如 <code>cleanupOrphaned</code></li>
</ul>
<h2 id="路由刷新行为"><a href="#路由刷新行为" class="headerlink" title="路由刷新行为"></a>路由刷新行为</h2><p><img src="https://wangxin201492.github.io/techImages/MongoDB-cache-refresh.png" alt="MongoDB-cache-refresh"></p>
<p>具体的刷新行为分为两步：</p>
<p>第一步：从config节点拉取权威的路由信息，并进行CatalogCache路由信息刷新。实际最终是通过 <code>ConfigServerCatalogCacheLoader</code> 线程来进行的，构造一个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"ns"</span>: namespace,</span><br><span class="line">  "lastmod": &#123; $gte: sinceVersion&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求来获取路由信息。如果本地没有collection的路由信息，则会那么全量获取路由信息，<code>sinceVersion</code> = (0,0) ；否则只需增量获取路由信息， <code>sinceVersion</code> = 本地路由信息中最大的版本号，即 <strong>shard version</strong>。</p>
<p><code>ConfigServerCatalogCacheLoader</code> 获得到路由信息以后，会刷新 CatalogCache中的路由信息，此时系统日志会打印上文中看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:43.853+0800 I SH_REFR [ConfigServerCatalogCacheLoader-20] Refresh for collection sdb.sColl from version 25550573|83||5f59e113f7f9b49e704c227f to version 25550574|264||5f59e113f7f9b49e704c227f took 8676ms</span><br></pre></td></tr></table></figure>



<p>第二步：更新 <code>MetadataManager</code>(用于维护集合的元信息，并提供对部分场景获取一个一致性的路由信息等功能) 中的 路由信息。更新 <code>MetadataManager</code> 时为了保证一致性，会给 collection 增加一个 <strong>X锁</strong>。更新过程中，系统日志会打印上文看到的第二条日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:43.853+0800 I SHARDING [conn1527] Updating collection metadata for collection sdb.sColl from collection version: 25550573|83||5f59e113f7f9b49e704c227f, shard version: 25550573|72||5f59e113f7f9b49e704c227f to collection version: 25550574|264||5f59e113f7f9b49e704c227f, shard version: 25550574|248||5f59e113f7f9b49e704c227f</span><br></pre></td></tr></table></figure>

<p><strong>这里也即是文章开篇提到影响我们性能的日志，根因还是由于更新元信息的X锁导致。</strong></p>
<h2 id="3-6-版本对-chunk-version-管理的变化"><a href="#3-6-版本对-chunk-version-管理的变化" class="headerlink" title="3.6+版本对 chunk version 管理的变化"></a>3.6+版本对 chunk version 管理的变化</h2><p>那么，为什么 3.4版本 没有问题，而到了 4.0版本 却发生了性能退化呢？这里直接给出答案：<strong>3.6&amp;4.0的最新小版本当中，当shard进行 splitChunk 时，如果 shardVersion == collectionVersion ，则会增加 major version，进而触发路由刷新。</strong>而3.4版本中只会增加 minor version。这里首先来看下 splitChunk 的基本流程，随后我们再来详述为什么要做这样的改动</p>
<h3 id="splitChunk-流程"><a href="#splitChunk-流程" class="headerlink" title="splitChunk 流程"></a>splitChunk 流程</h3><p><img src="https://wangxin201492.github.io/techImages/MongoDB-splitChunk.png" alt="MongoDB-splitChunk"></p>
<ul>
<li><strong>「auto-spliting触发」</strong>：在 4.0及以前的版本中，sharding实例的 auto-spliting 是由 mongos 来触发的。每次有写入请求时，mongos都会记录对应chunk的写入量，并判断是否要向 shardServer 下发一次 <code>splitChunk</code> 请求。判断标准：<code>dataWrittenBytes &gt;= maxChunkSize / 5(固定值)</code>。</li>
<li><strong>「splitVector + splitChunk」</strong>：向 chunk所在的shard 下发一个 <code>splitVector</code> 请求，获取对该chunk进行拆分的拆分点。该过程会根据索引进行一定的数据扫描及计算，详见：<a href="https://developer.aliyun.com/article/119494" target="_blank" rel="noopener">SplitVector命令</a>。若 <code>splitVector</code> 获取到了具体的拆分点，则再次向 chunk所在的shard 下发一个 <code>splitChunk</code> 请求，进行实际的拆分。</li>
<li><strong>「_configsvrCommitChunkSplit」</strong>：shardServer 收到 <code>splitChunk</code> 请求后，首先获取一个分布式锁，然后向 configServer 下发一个 <code>_configsvrCommitChunkSplit</code>。configServer 收到该请求后进行数据更新，完成splitChunk，过程中会有 chunk 版本信息的变化。</li>
<li><strong>「route refresh」</strong>：上述流程正常完成后，mongos进行路由刷新。</li>
</ul>
<h3 id="splitChunk-时，chunk-version变化"><a href="#splitChunk-时，chunk-version变化" class="headerlink" title="splitChunk 时，chunk version变化"></a>splitChunk 时，chunk version变化</h3><p>在 <a href="https://jira.mongodb.org/browse/SERVER-41480" target="_blank" rel="noopener">SERVER-41480</a> 中，对splitChunk时，chunk version版本管理进行了调整</p>
<p>在3.4版本以及3.6、4.0较早的小版本中，<strong>「_configsvrCommitChunkSplit」</strong> 只会增加 chunk 的minor version。</p>
<blockquote>
<p>The original reasoning for this was to prevent unnecessary routing table refreshes on the routers, which don’t ordinarily need to know about chunk splits (since they don’t change targeting information).</p>
</blockquote>
<p>根本原因是为了保护 mongos 不做必须要的路由刷新，因为 splitChunk 并不会改变路由目标，所以 mongos 不需要感知。</p>
<p>但是只进行小版本的自增，如果用户进行单调递增的写入，容易造成较大的性能开销。</p>
<p><img src="https://wangxin201492.github.io/techImages/MongoDB-SERVER-41480.png" alt="MongoDB-SERVER-41480"></p>
<p>假设 sharding实例有2个mongos：mongosA、mongosB，2个shard：shardA(chunkRange: MinKey ~ 0)，shardB(chunkRange: 0 ~ Maxkey)。用户持续单调递增写入。</p>
<ul>
<li><strong>T1时刻</strong>：mongosB首先判断chunk满足<strong>「auto-spliting触发」</strong> 条件，向 shardB 发送<strong>「splitVector + splitChunk」</strong>，在请求正常结束后，mongosB触发路由刷新。此时，shardB 的 chunkRange 为 0 ~ 100，100 ~ Maxkey。</li>
<li>随后在一定时间内（比如<strong>T2时刻</strong>），mongosB无法满足<strong>「auto-spliting触发」</strong> 条件，而mongosA持续判断满足条件，向shardB发送 <strong>「splitVector + splitChunk」</strong>，但最终在<strong>「_configsvrCommitChunkSplit」</strong>步骤，由于 mongosA 的路由表不是最新的，所以无法按照其请求将 0 ~ Maxkey 进行拆分，最终无法成功执行。由于整个流程没有完整结束，所以 mongosA 也无法进行 路由表更新，则<strong>在这段时间内持续会有这样的无效请求</strong>。</li>
</ul>
<p>而如上文描述的，<code>splitVector</code> 根据索引进行一定的数据扫描、计算，<code>splitChunk</code> 会获取分布式锁，均为耗时较高的请求，所以这种场景对性能的影响不可忽视。</p>
<p>在 <strong>SERVER-41480</strong>中对上述问题进行修复，修复的方式是如果 shardVersion == collectionVersion (即 collection上次的 chunk split 也发生在该shard上) ，则会增加 major version，以触发各节点路由的刷新。修复的版本为<code>3.6.15</code>, <code>4.0.13</code>, <code>4.3.1</code>, <code>4.2.2</code>。</p>
<p>而这个修复则导致了开篇我们遇到的问题，确切些来说，<strong>任何在 shardVersion == collectionVersion 的 shard 上进行 split 操作都会导致全局路由的刷新。</strong></p>
<h2 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h2><p><a href="https://jira.mongodb.org/browse/SERVER-49233" target="_blank" rel="noopener">SERVER-49233</a> 中对这个问题进行了详细的阐述：</p>
<blockquote>
<p>we chose a solution, which erred on the side of correctness, with the reasoning that on most systems auto-splits are happening rarely and are not happening at the same time across all shards.</p>
</blockquote>
<p>我们选择的方案，宁可过于注重正确性（<strong>SERVER-41480</strong>），理由是在大多数的系统中，auto-split很少发生，而且不会同时在所有shard上发生。</p>
<blockquote>
<p>However, this logic seems to be causing more harm than good in the case of almost uniform writes across all chunks. If it is the case that all shards are doing splits almost in unison, under this fix there will constantly be a bump in the collection version, which means constant stalls due to StaleShardVersion.</p>
</blockquote>
<p>然而，在对所有chunk进行均衡写入的情况下，这个逻辑似乎弊大于利。如果这种场景下，所有的shard同时进行split，那么在 <strong>SERVER-41480</strong> 修复下，collection version 将不断出现颠簸，也就意味着不断由于 <code>StaleShardVersion</code> 而导致不断暂停。</p>
<p><img src="https://wangxin201492.github.io/techImages/MongoDB-SERVER-49233.png" alt="MongoDB-SERVER-49233"></p>
<p>举例来详细说明下这个问题：假设某sharding实例有4个shard，各持有2个chunk，当前时刻major version=N。客户端对sharding实例的所有chunk进行均衡的写入，某时刻mongosA判断所有chunk符合split条件，依次对各shard进行连续的 split chunk 触发。为了便于说明，假设如图所示，在T1，T2，T3，T4时刻，依次在ShardA、shardB、shardC、shardD进行连续的chunk split触发，那么：</p>
<ul>
<li>T1.1时刻 chunk1 发生 split，使得 shardA 的 shardVersion == collection；T1.2时刻 chunk2 发生 split，触发 configServer major version ++ ，此时最新的major version=N+1；随后的T1.3时刻，shardA感知后刷新本地major version=N+1</li>
<li>随后的T2、T3、T4时刻依次发生上述流程。</li>
<li>最终在T5时刻，mongosA 在触发完split chunk后主动刷新路由表，感知major version = N+4</li>
</ul>
<p>那么当系统中另外一个mongos（未发生更新，路由表中major version=N）向shard（比如shardB）发送请求时</p>
<ul>
<li>在第一次请求交互后，mongosX感知自身major version落后，与configServer交互，更新本地路由表后下发第二次请求</li>
<li>第二次请求中，shardB感知自身major version落后，通过configServer拉取并更新路由表</li>
<li>在第三次请求中，双方均获得最新的路由表，而完成此次请求</li>
<li>mongos&amp;shard之间感知路由表落后靠请求交互时的 <code>StaleShardVersion</code> 来完成，而路由表更新的过程中，所有需要依赖该集合路由表完成的请求，都需要<strong>等待路由表更新完成</strong>后才能继续。所以上述过程即jira中描述的：<strong>不断由于</strong> <strong><code>StaleShardVersion</code></strong> <strong>而导致不断暂停。</strong></li>
</ul>
<p>同时 <strong>SERVER-49233</strong> 提供了具体的解决方案，在 <code>3.6.19</code>、<code>4.0.20</code>、<code>4.2.9</code> 及后续的版本中，提供 <code>incrementChunkMajorVersionOnChunkSplit</code> 参数， 默认为 false（即 <code>splitChunk</code> 不会增加major version），可在配置文件或者通过启动setParameter的方式设置为true。</p>
<p>而由于 auto-spliting 逻辑在 4.2版本 修改为在 shardServer 上触发(<a href="https://jira.mongodb.org/browse/SERVER-34448" target="_blank" rel="noopener">SERVER-34448</a>)， 也就不会再有 mongos 频繁下发无效 splitChunk 的场景。 所以对于 4.4 版本， <a href="https://jira.mongodb.org/browse/SERVER-49433" target="_blank" rel="noopener">SERVER-49433</a> 直接将增加 major version 的逻辑回滚掉，只会增加 minor version。（4.2版本由于中间版本提供了 major version 逻辑，所以提供 <code>incrementChunkMajorVersionOnChunkSplit</code> 来让用户选择）</p>
<p>这里对各版本行为总结如下：</p>
<ul>
<li>只会增加 minor version：<code>3.4</code>所有版本、<code>3.6.15</code> 之前的版本、<code>4.0.13</code>之前的版本、<code>4.2.2</code>之前的版本、<code>4.4</code>（暂未发布）</li>
<li>shardVersion == collectionVersion 会增加 major version，否则增加minor version：<code>3.6.15</code>~ <code>3.6.18</code>（包含）之间的版本、<code>4.0.13</code> ~ <code>4.0.19</code>（包含）之间的版本、<code>4.2.2</code> ~ <code>4.2.8</code>（包含）之间的版本</li>
<li>提供 <code>incrementChunkMajorVersionOnChunkSplit</code> 参数，默认只增加 minor version：<code>3.6.19</code>及后续版本、<code>4.0.20</code>及后续版本、<code>4.2.9</code>及后续版本</li>
</ul>
<h2 id="使用场景与解决方案"><a href="#使用场景与解决方案" class="headerlink" title="使用场景与解决方案"></a>使用场景与解决方案</h2><table>
<thead>
<tr>
<th>MongoDB版本</th>
<th>使用场景</th>
<th>修复方案</th>
</tr>
</thead>
<tbody><tr>
<td>4.2以下</td>
<td>数据写入固定在某些Shard</td>
<td>采用可以增加major version的版本（或设置 <code>incrementChunkMajorVersionOnChunkSplit</code> = true）</td>
</tr>
<tr>
<td>4.2以下</td>
<td>数据在shard之间写入较均衡</td>
<td>采用仅增加minor version的版本（或设置 <code>incrementChunkMajorVersionOnChunkSplit</code> = false）</td>
</tr>
<tr>
<td>4.2</td>
<td>数据写入固定在某些Shard</td>
<td>由于4.2版本 splitChunk 在shardServer上触发，所以无需关心</td>
</tr>
<tr>
<td>4.2</td>
<td>数据在shard之间写入较均衡</td>
<td>采用仅增加minor version的版本（或设置 <code>incrementChunkMajorVersionOnChunkSplit</code> = false）</td>
</tr>
</tbody></table>
<p><a href="https://www.aliyun.com/product/mongodb" target="_blank" rel="noopener">阿里云MongoDB</a> 4.2版本中已经跟进了官方修复。遇到该问题的用户可以将实例升级到4.2的最新小版本，而后按需配置<code>incrementChunkMajorVersionOnChunkSplit</code>即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/StaleConfig/MongoDB-sharding-StaleConfig/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/StaleConfig/MongoDB-sharding-StaleConfig/" itemprop="url">MongoDB sharding 路由刷新策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-21T10:05:48+08:00">
                2020-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/StaleConfig/" itemprop="url" rel="index">
                    <span itemprop="name">StaleConfig</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-mongos节点-收到用户-insert-请求"><a href="#1-mongos节点-收到用户-insert-请求" class="headerlink" title="1. mongos节点 收到用户 insert 请求"></a>1. mongos节点 收到用户 insert 请求</h2><p>mongos 收到一个 insert 请求后，会经过如下流程处理将请求发送给 shard 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongos::handleRequest() --&gt; Strategy::clientCommand() --&gt; runCommand() --&gt; execCommandClient() --&gt; ClusterWriteCmd::InvocationBase::run() --&gt; ClusterWriteCmd::InvocationBase::runImpl() --&gt; ClusterWriter::write() --&gt; BatchWriteExec::executeBatch() --&gt; MultiStatementTransactionRequestsSender()</span><br></pre></td></tr></table></figure>

<p>在 <code>ClusterWriter::write()</code> 中会准备一个 <code>ChunkManagerTargeter</code> 来维保存目标 namespace 在 <code>CatalogCache</code> 中的路由信息，方便后续请求处理。</p>
<p>主要代码逻辑在 <code>BatchWriteExec::executeBatch()</code> 中，主要是封装 <code>BatchWriteOp</code> 的几个核心方法来完成具体的请求处理工作：</p>
<p>首先，根据请求的目标shard、order 等参数来将请求分成多个批次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status targetStatus = batchOp.targetBatch(targeter, recordTargetErrors, &amp;childBatches);</span><br></pre></td></tr></table></figure>

<p>然后逐批构造请求，并将请求通过 <code>MultiStatementTransactionRequestsSender</code> 依次发送到shard，并等待接收结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> request = [&amp;] &#123; <span class="keyword">const</span> <span class="keyword">auto</span> shardBatchRequest(batchOp.buildBatchRequest(*nextBatch));</span><br><span class="line">...</span><br><span class="line"><span class="function">MultiStatementTransactionRequestsSender <span class="title">ars</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  opCtx,</span></span></span><br><span class="line"><span class="function"><span class="params">  Grid::<span class="built_in">get</span>(opCtx)-&gt;getExecutorPool()-&gt;getArbitraryExecutor(),</span></span></span><br><span class="line"><span class="function"><span class="params">  clientRequest.getNS().db().toString(),</span></span></span><br><span class="line"><span class="function"><span class="params">  requests,</span></span></span><br><span class="line"><span class="function"><span class="params">  kPrimaryOnlyReadPreference,</span></span></span><br><span class="line"><span class="function"><span class="params">  isRetryableWrite ? Shard::RetryPolicy::kIdempotent : Shard::RetryPolicy::kNoRetry)</span></span>;</span><br></pre></td></tr></table></figure>



<p>在请求构造(<code>BatchWriteOp::buildBatchRequest()</code>)的的时候，设置请求的 <code>shardVersion</code>。这里实际是为请求设置了一个 <code>shardVersion</code> 字段，设置的值则为刚开始提到的 <code>CatalogCache</code> 中保存的 namespace 路由信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setShardVersion(targetedBatch.getEndpoint().shardVersion);</span><br></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  insert: "sCollName", </span><br><span class="line">  documents: [ &#123; _id: ObjectId('5f685824c800cd1689ca3be8'), name: xxxx &#125; ], </span><br><span class="line">  shardVersion: [ Timestamp(5, 1), ObjectId('5f3ce659e6957ccdd6a56364') ], </span><br><span class="line">  $db: "sdb"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-shard节点-收到-mongos节点-转发过来携带-shardVersion-的-insert-请求"><a href="#2-shard节点-收到-mongos节点-转发过来携带-shardVersion-的-insert-请求" class="headerlink" title="2. shard节点 收到 mongos节点 转发过来携带 shardVersion 的 insert 请求"></a>2. shard节点 收到 mongos节点 转发过来携带 <code>shardVersion</code> 的 insert 请求</h2><p>正常情况下， shard节点 按照如下流程处理 insert 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongod::handleRequest() --&gt; ServiceEntryPointCommon::handleRequest() --&gt; receivedCommands() --&gt; execCommandDatabase() --&gt; runCommandImpl() --&gt; WriteCommand::InvocationBase::run() --&gt; CmdInsert::Invocation::runImpl() --&gt; performInserts() --&gt; insertBatchAndHandleErrors() --&gt; acquireCollection()</span><br></pre></td></tr></table></figure>



<p>在 <code>execCommandDatabase()</code> 中，会提取请求中的 <code>shardVersion</code>和<code>databaseVersion</code> 字段信息，存储到 <code>OperationShardingState</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!opCtx-&gt;getClient()-&gt;isInDirectClient() &amp;&amp;</span><br><span class="line">            readConcernArgs.getLevel() != repl::ReadConcernLevel::kAvailableReadConcern &amp;&amp;</span><br><span class="line">            (iAmPrimary ||</span><br><span class="line">             (readConcernArgs.hasLevel() || readConcernArgs.getArgsAfterClusterTime()))) &#123;</span><br><span class="line">  oss.initializeClientRoutingVersions(invocation-&gt;ns(), request.body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>只有执行了<code>oss.initializeClientRoutingVersions()</code>，后续才会进行shardVersion比对。那么不进行shardVersion比对的场景是：</p>
<ol>
<li>reacConcern指定为available</li>
<li>从secondary读取且readConcern没有指定任何的参数</li>
</ol>
<h3 id="2-1-是否可以进行写入"><a href="#2-1-是否可以进行写入" class="headerlink" title="2.1 是否可以进行写入"></a>2.1 是否可以进行写入</h3><p>在 <code>acquireCollection()</code> 时，会判断请求是否可以进行写入( <code>assertCanWrite_inlock()</code> )。判断的标准则是比对 <strong>当前节点存储的shardVersion</strong> 和 <strong>收到mongos发送来的shardVersion</strong>，比较二者 <code>epoch &amp; majorVersion</code> 是否相同，相同则认为可以进行写入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can we write to this data and not have a problem?</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isWriteCompatibleWith</span><span class="params">(<span class="keyword">const</span> ChunkVersion&amp; other)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> epoch() == other.epoch() &amp;&amp; majorVersion() == other.majorVersion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则会抛出一个 <code>StaleConfigInfo</code> 异常。</p>
<h3 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2 异常处理"></a>2.2 异常处理</h3><p>该异常在 <code>insertBatchAndHandleErrors()</code> 中进行捕获，并 <code>handleError()</code>。对于异常为 <code>StaleConfigInfo</code> ，处理手段是将其设置到 <code>OperationShardingState</code> 中，并将其结果添加到向上游返回的输出中，且认为代码无须向下执行，继续直接返回给上游。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ex.extraInfo&lt;StaleConfigInfo&gt;()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!opCtx-&gt;getClient()-&gt;isInDirectClient()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; oss = OperationShardingState::<span class="built_in">get</span>(opCtx);</span><br><span class="line">            oss.setShardingOperationFailedStatus(ex.toStatus());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't try doing more ops since they will fail with the same error.</span></span><br><span class="line">        <span class="comment">// Command reply serializer will handle repeating this error if needed.</span></span><br><span class="line">        out-&gt;results.emplace_back(ex.toStatus());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>execCommandDatabase()</code> 进入析构流程时，析构 <code>ScopedOperationCompletionShardingActions</code> 会处理上面提及的 <code>StaleConfigInfo</code>。在 <code>onShardVersionMismatch</code> 接管异常处理工作，比对 本地shardVersion 是否大于 接收的版本。如果是则无需处理，否则进行 <code>forceShardFilteringMetadataRefresh</code> 强制刷新。</p>
<p>而无论是否进行了刷新，都会将 <code>StaleConfigInfo</code> 返回给上游 mongos</p>
<h2 id="3-mongos-处理-StaleConfigInfo"><a href="#3-mongos-处理-StaleConfigInfo" class="headerlink" title="3. mongos 处理 StaleConfigInfo"></a>3. mongos 处理 <code>StaleConfigInfo</code></h2><p>续 <strong>阶段1</strong> ， <code>MultiStatementTransactionRequestsSender()</code> 收到结果以后，通过 <code>BatchWriteOp::noteBatchResponse()</code> 处理 response</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch was ok, note response</span></span><br><span class="line">batchOp.noteBatchResponse(*batch, batchedCommandResponse, &amp;trackedErrors);</span><br></pre></td></tr></table></figure>



<p><code>BatchWriteOp::noteBatchResponse()</code> 的入参中有一个 <code>BatchedCommandResponse</code> 对象记录所有节点返回的结果。而 <code>BatchWriteOp</code> 中的 <code>_writeOps</code> 则记录了向各个节点下发的请求，根据response结果一一标记对应的request。最终在 <code>WriteOp::_updateOpState()</code> 中对 当前writeOp 进行标记。如果 <code>writeError == StaleShardVersion</code> 或者 <code>writeError == CannotImplicitlyCreateCollection</code>，则当前 writeOp 的状态仍然保留为 <code>WriteOpState_Ready</code>，而如果遇到其他异常则被标记位 <code>WriteOpState_Error</code>，请求正常完成则被标记为 <code>WriteOpState_Completed</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finish the response (with error, if needed)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == writeError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ordered || !lastError) &#123;</span><br><span class="line">        writeOp.noteWriteComplete(*<span class="built_in">write</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We didn't actually apply this write - cancel so we can retarget</span></span><br><span class="line">        dassert(writeOp.getNumTargeted() == <span class="number">1u</span>);</span><br><span class="line">        writeOp.cancelWrites(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    writeOp.noteWriteError(*<span class="built_in">write</span>, *writeError);</span><br><span class="line">    lastError = writeError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随后仍然会将 <code>StaleConfigInfo</code> 异常信息添加到 targeter 中，并在接下来的逻辑中进行刷新（如果本地版本更老）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!staleErrors.empty()) &#123;</span><br><span class="line">  noteStaleResponses(staleErrors, &amp;targeter);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Status refreshStatus = targeter.refreshIfNeeded(opCtx, &amp;targeterChanged);</span><br></pre></td></tr></table></figure>



<p>刷新的方式是首先标记版本过期，需要刷新。然后重新 <code>init</code> 时会获取路由信息而出发刷新。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status ChunkManagerTargeter::_refreshNow(OperationContext* opCtx) &#123;</span><br><span class="line">    Grid::<span class="built_in">get</span>(opCtx)-&gt;catalogCache()-&gt;onStaleShardVersion(<span class="built_in">std</span>::<span class="built_in">move</span>(*_routingInfo));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> init(opCtx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/shardCollection/MongoDB-sharding-shardCollection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/shardCollection/MongoDB-sharding-shardCollection/" itemprop="url">MongoDB sharding shardCollection实现流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-13T15:46:07+08:00">
                2020-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/shardCollection/" itemprop="url" rel="index">
                    <span itemprop="name">shardCollection</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="mongos-ShardCollectionCmd-run"><a href="#mongos-ShardCollectionCmd-run" class="headerlink" title="mongos : ShardCollectionCmd::run()"></a>mongos : <code>ShardCollectionCmd::run()</code></h2><p>mongos 收到 <code>shardCollection</code> 后，将请求解析并封装成一个 <code>_configsvrShardCollection</code>(ConfigsvrShardCollectionRequest) 请求，发送给 config节点</p>
<h2 id="config-ConfigSvrShardCollectionCommand-run"><a href="#config-ConfigSvrShardCollectionCommand-run" class="headerlink" title="config : ConfigSvrShardCollectionCommand::run()"></a>config : <code>ConfigSvrShardCollectionCommand::run()</code></h2><ol>
<li>解析 <code>_configsvrShardCollection</code> 请求</li>
<li>给 namespace &amp; database 均增加 “shardCollection” 的分布式锁</li>
<li>确认 database 已经是 sharded 的</li>
<li>如果 database == “config” ，确认 namespace == “config.system.sessions” 且其 count() == 0</li>
<li>构造一个 <code>_shardsvrShardCollection</code>(ShardsvrShardCollection) 请求，发送给 database 的 <strong>primaryShard</strong></li>
</ol>
<h2 id="shard-ShardsvrShardCollectionCommand-run"><a href="#shard-ShardsvrShardCollectionCommand-run" class="headerlink" title="shard : ShardsvrShardCollectionCommand::run()"></a>shard : <code>ShardsvrShardCollectionCommand::run()</code></h2><p>解析 <code>_shardsvrShardCollection</code> 请求</p>
<p>将请求注册到 <code>ActiveShardCollectionRegistry</code> 中，</p>
<ol>
<li><strong>如果没有同 namespace 的 shardCollection 运行，则注册成功，继续进行 shard 操作</strong></li>
<li>如果有同 namespace 的请求，请求相同，则通过 promise/future 方式等待请求完成直接获取结果。请求不同则报错（<em>ConflictingOperationInProgress</em>）</li>
</ol>
<p>主要的shard逻辑在 <code>shardCollection</code> 完成。</p>
<h3 id="确认-config-collections-中，对-namespace-的-shard-操作是否与当前-请求相同"><a href="#确认-config-collections-中，对-namespace-的-shard-操作是否与当前-请求相同" class="headerlink" title="确认 config.collections 中，对 namespace 的 shard 操作是否与当前 请求相同"></a>确认 <code>config.collections</code> 中，对 namespace 的 shard 操作是否与当前 请求相同</h3><ol>
<li>不同则报错 ：<em>AlreadyInitialized</em></li>
<li>相同则返回 <code>config.collections</code> 中的结果，进而直接将对应的 collection 返回给上游</li>
<li><strong>不存在，则继续进行 shard 操作</strong></li>
</ol>
<h3 id="确认-collection-的一些状态-：-calculateTargetState"><a href="#确认-collection-的一些状态-：-calculateTargetState" class="headerlink" title="确认 collection 的一些状态 ： calculateTargetState"></a>确认 collection 的一些状态 ： <code>calculateTargetState</code></h3><ol>
<li><code>config.chunks</code> 中有 namespace 的一些记录，报错：<em>ManualInterventionRequired</em>。需要手动请求可能因为之前 shard 操作导致有参与的chunk记录</li>
<li>判断 namespace 索引状况：<code>createCollectionOrValidateExisting</code><ol>
<li>所有的 unique index 必须以 shardKey 为 prefix。否则：<em>InvalidOptions</em></li>
<li>非空 collection 必须有一个有效 index</li>
<li>如果 shardKey 指定的是 unique的，必须有一个完全相同的 unique index</li>
<li>没有有效的 index， 且 collection 不为空则fail：<em>InvalidOptions</em></li>
<li>空 collection 则创建 需要的 index</li>
</ol>
</li>
<li><strong>isEmpty</strong> : collection 是否为 空</li>
<li><strong>tags</strong> : <code>config.tags</code> 中是否有 namespace 相关的 tag</li>
<li><strong>uuid</strong> : 是否有有效的 uuid 或者生成一个新的</li>
<li><strong>fromMapReduce</strong> : 是否来自于 mapReduce 请求</li>
<li><strong>splitPoint</strong> : 基于 tag / shardKey类型 / 是否指定 initialSplitPoints(mapReduce) / numInitialChunks 等参数确定<ol>
<li>mapReduce 场景下，指定了 initialSplitPoints ： splitPoint = initialSplitPoints</li>
<li>tag 为空 &amp;&amp; shardKey 为 hashed &amp;&amp; collection 为空，则将 chunk 按照 numInitialChunks 均分（未指定则默认为 shard * 2）</li>
</ol>
</li>
<li><strong>numContiguousChunksPerShard</strong> ： 每个 shard 持续的 chunk段</li>
</ol>
<p>在计算<code>calculateTargetState</code> 前，shardCollection会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From this point onward the collection can only be read, not written to, so it is safe to</span></span><br><span class="line"><span class="comment">// construct the prerequisites and generate the target state.</span></span><br><span class="line"><span class="function">CollectionCriticalSection <span class="title">critSec</span><span class="params">(opCtx, nss)</span></span></span><br></pre></td></tr></table></figure>

<p>通过一个 <code>CollectionCriticalSection</code> ，来将 collection 设置为只读，而在计算完<code>calculateTargetState</code> 后，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From this point onward, the collection can not be written to or read from.</span></span><br><span class="line">critSec.enterCommitPhase();</span><br></pre></td></tr></table></figure>

<p>继续将其设置为不可读写（直到shardCollection完成）。</p>
<p><code>CollectionCriticalSection</code> 是</p>
<h3 id="确定-ShardingOptimizationType-并进行具体的-chunk-分配"><a href="#确定-ShardingOptimizationType-并进行具体的-chunk-分配" class="headerlink" title="确定 ShardingOptimizationType 并进行具体的 chunk 分配"></a>确定 <code>ShardingOptimizationType</code> 并进行具体的 chunk 分配</h3><ol>
<li><strong>SplitPointsProvided</strong> : 提供了 splitPoint<ol>
<li>按照 splitPoint 将 chunk 分配到 shard 上(<code>generateShardCollectionInitialChunks</code>)</li>
</ol>
</li>
<li><strong>TagsProvidedWithEmptyCollection</strong> : tags 不为空 且 collection 不为空<ol>
<li>按照 tags 将 chunk 分配到 shard 上(<code>generateShardCollectionInitialZonedChunks</code>)</li>
</ol>
</li>
<li><strong>TagsProvidedWithNonEmptyCollection</strong> : tags 不为空 collection 为空<ol>
<li>将 <strong>$minKey ~ $maxKey</strong> 均分配到 primaryShard 上</li>
</ol>
</li>
<li><strong>EmptyCollection</strong> : collection 为空<ol>
<li>将 <strong>$minKey ~ $maxKey</strong> 均分配到 primaryShard 上</li>
</ol>
</li>
<li><strong>None</strong> : tags 为空 &amp;&amp; splitPoint 为空 &amp;&amp; collection 不为空<ol>
<li>将 maxChunkSizeBytes / maxChunkObjects / keyPattern 构造一个 <code>splitVector</code> 请求 发送给 primaryShard，获得一个 splitPoint 。然后根据结果将 chunk 拆分，但是都分配到 primaryShard</li>
</ol>
</li>
</ol>
<p>随后如果<code>ShardingOptimizationType != None &amp;&amp; !fromMapReduce</code> ，发送给其他相关shard发送一个  <code>_cloneCollectionOptionsFromPrimaryShard</code> 来触发其从primaryShard获取该 Collection的相关信息。具体实现则使用 <code>moveChunk</code> 时用到的 <code>MigrationDestinationManager::cloneCollectionIndexesAndOptions()</code> 来完成。</p>
<h3 id="更新config元信息及其他shard路由信息"><a href="#更新config元信息及其他shard路由信息" class="headerlink" title="更新config元信息及其他shard路由信息"></a>更新config元信息及其他shard路由信息</h3><p>上一步中会获得一个 <code>ShardCollectionConfig</code> 实际上是 <code>std::vector&lt;ChunkType&gt; chunks</code>。随后在 <code>writeChunkDocumentsAndRefreshShards</code> 中处理<code>ShardCollectionConfig</code>：</p>
<ol>
<li><strong>writeFirstChunksToConfig</strong>：写入 <code>config.chunks</code> 集合</li>
<li><strong>updateShardingCatalogEntryForCollection</strong>：更新 <code>config.collections</code> 集合</li>
<li><strong>refreshAllShards</strong>：强制刷新本地路由，基于最新的路由信息 构造一个 <code>_flushRoutingTableCacheUpdates</code> 请求，通知所有相关 shard</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/MongoDB-ServiceContext-Client-OperationContext/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/MongoDB-ServiceContext-Client-OperationContext/" itemprop="url">MongoDB中 ServiceContext/Client/OperationContext的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-03T11:03:12+08:00">
                2020-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ServiceContext"><a href="#ServiceContext" class="headerlink" title="ServiceContext"></a>ServiceContext</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class representing the context of a service, such as a MongoD database service or</span></span><br><span class="line"><span class="comment"> * a MongoS routing service.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A ServiceContext is the root of a hierarchy of contexts.  A ServiceContext owns</span></span><br><span class="line"><span class="comment"> * zero or more Clients, which in turn each own OperationContexts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceContext</span> <span class="title">final</span> :</span> <span class="keyword">public</span> Decorable&lt;ServiceContext&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一个mongod or mongos 进程中只有一个全局唯一的 <code>ServiceContext</code>：<code>ServiceContext</code> 代表一个service的上下文环境，一个 <code>ServiceContext</code> 是上下文层次中的根。一个 <code>ServiceContext</code> 拥有0个或多个 <code>Client</code>， 一个 <code>Client</code> 拥有各自的 <code>OperationContext</code></p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The database's concept of an outside "client".</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="title">final</span> :</span> <span class="keyword">public</span> Decorable&lt;<span class="built_in">Client</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一个外部链接对应一个 <code>Client</code></p>
<h2 id="OperationContext"><a href="#OperationContext" class="headerlink" title="OperationContext"></a>OperationContext</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class encompasses the state required by an operation and lives from the time a network</span></span><br><span class="line"><span class="comment"> * operation is dispatched until its execution is finished. Note that each "getmore" on a cursor</span></span><br><span class="line"><span class="comment"> * is a separate operation. On construction, an OperationContext associates itself with the</span></span><br><span class="line"><span class="comment"> * current client, and only on destruction it deassociates itself. At any time a client can be</span></span><br><span class="line"><span class="comment"> * associated with at most one OperationContext. Each OperationContext has a RecoveryUnit</span></span><br><span class="line"><span class="comment"> * associated with it, though the lifetime is not necesarily the same, see releaseRecoveryUnit</span></span><br><span class="line"><span class="comment"> * and setRecoveryUnit. The operation context also keeps track of some transaction state</span></span><br><span class="line"><span class="comment"> * (RecoveryUnitState) to reduce complexity and duplication in the storage-engine specific</span></span><br><span class="line"><span class="comment"> * RecoveryUnit and to allow better invariant checking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationContext</span> :</span> <span class="keyword">public</span> Interruptible, <span class="keyword">public</span> Decorable&lt;OperationContext&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该类包含了一个 operation 所需的所有状态，生命周期 从 网络分派 开始，到 执行完成 为止。<code>cursor</code> 上的每一个 <code>getmore</code> 都是一个独立的 operation。在 构造函数 中，一个 <code>OperationContext</code> 会被关联到当前的 <code>Client</code> 中，直到被销毁时才会取消关联。任何时间，每个 <code>Client</code> 最多只会被关联到一个 <code>OperationContext</code> 上。每个 <code>OperationContext</code> 也会持有 <code>RecoveryUnit</code>/<code>RecoveryUnitState</code> 等对象</p>
<h2 id="源码梳理"><a href="#源码梳理" class="headerlink" title="源码梳理"></a>源码梳理</h2><p>从源码上看，mongos 和 mongod 启动的时候都会通过 <code>setGlobalServiceContext(ServiceContext::make());</code> 来初始化一个 <code>ServiceContext</code>，这里最终将初始化好的 <code>ServiceContext</code> 放到 <code>globalServiceContext</code> 这个全局变量里，并提供一个 <code>getGlobalServiceContext()</code> 函数方便对象获取。</p>
<p>每有一个客户端连接到 mongod/mongos 时，会同时创建一个 <code>ServiceStateMachine</code> 用于管理该客户端连接生命周期中的状态，在 <code>ServiceStateMachine</code> 构造函数中，会调用 <code>ServiceContext-&gt;makeClient()</code> 来创建一个 <code>Client</code>对象，<code>makeClient()</code> 同时也会将创建好的 <code>Client</code> 对象添加到 <code>ServiceContext</code> 维护的 <code>stdx::unordered_set&lt;Client*&gt; _clients</code> 中。</p>
<p>在 <code>ServiceStateMachine</code> 对 <code>Client</code> 请求进行状态管理时，<code>Process</code> 为请求处理的状态，对该状态的处理在 <code>ServiceStateMachine::_processMessage()</code> 完成。这个方法中通过 <code>Client::getCurrent()-&gt;makeOperationContext();</code> 来构建一个 <code>OperationContext</code>，并在方法结束前将 <code>OperationContext</code> reset掉。</p>
<p>上面过程会涉及到2个自增的ID，这里简单说下：</p>
<ul>
<li>每有客户端连接时，会创建 <code>Session</code> 对象，基于这个 <code>Session</code> 对象创建上面提及的 <code>ServiceStateMachine</code>。<code>Session</code> 创建的时候则会通过 <code>AtomicWord&lt;unsigned long long&gt; sessionIdCounter</code> 来拿到一个唯一自增ID。mongod/mongos 会创建唯一的线程来处理 <code>Client</code> 的请求，该线程名称 <code>conn123</code> 中的 123 即是 上面获取到的sessionId</li>
<li><code>ServiceContext::makeOperationContext()</code> 创建 <code>OperationContext</code> 时会传入一个id用于唯一标识该 <code>OperationContext</code>，这个ID的获取是通过 <code>ServiceContext</code> 维护的 <code>AtomicWord&lt;unsigned&gt; _nextOpId</code> 拿到的。这个 ID 即为 <code>killOp</code>/<code>currentOp</code> 等命令中展示的 <code>opid</code></li>
</ul>
<p>同时 <code>ServiceContext</code> 提供了一个 <code>ClientObserver</code> 类用于 <code>Client</code> / <code>OperationContext</code> 构造和析构时的hook。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer interface implemented to hook client and operation context creation and</span></span><br><span class="line"><span class="comment"> * destruction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientObserver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCreateClient</span><span class="params">(<span class="built_in">Client</span>* client)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDestroyClient</span><span class="params">(<span class="built_in">Client</span>* client)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCreateOperationContext</span><span class="params">(OperationContext* opCtx)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDestroyOperationContext</span><span class="params">(OperationContext* opCtx)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ClientObserver</code> 的子类实现上述 virtual 函数，并通过 <code>ServiceContext::registerClientObserver()</code> 将自身注册到 <code>ServiceContext</code> 的 <code>std::vector&lt;ClientObserverHolder&gt; _clientObservers;</code> 中。那么在上文描述到的创建 <code>Client</code> 的函数 <code>ServiceContext::makeClient()</code> 和创建 <code>OperationContext</code> 函数 <code>ServiceContext::makeOperationContext()</code> 中则会依次遍历 <code>_clientObservers</code> 来调用对应的hook函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/ImplicitlyCreateCollection/MongoDB-sharding-ImplicitlyCreateCollection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/ImplicitlyCreateCollection/MongoDB-sharding-ImplicitlyCreateCollection/" itemprop="url">MongoDB sharding 隐式创建collection</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-31T13:21:15+08:00">
                2020-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/ImplicitlyCreateCollection/" itemprop="url" rel="index">
                    <span itemprop="name">ImplicitlyCreateCollection</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-mongos节点-收到用户-insert-请求"><a href="#1-mongos节点-收到用户-insert-请求" class="headerlink" title="1. mongos节点 收到用户 insert 请求"></a>1. mongos节点 收到用户 insert 请求</h2><p>mongos 收到一个 insert 请求后，会经过如下流程处理将请求发送给 shard 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongos::handleRequest() --&gt; Strategy::clientCommand() --&gt; runCommand() --&gt; execCommandClient() --&gt; ClusterWriteCmd::InvocationBase::run() --&gt; ClusterWriteCmd::InvocationBase::runImpl() --&gt; ClusterWriter::write() --&gt; BatchWriteExec::executeBatch() --&gt; MultiStatementTransactionRequestsSender()</span><br></pre></td></tr></table></figure>

<p>在发送给 shard 节点的请求中，会通过 <code>allowImplicitCollectionCreation</code> 字段来控制是否允许 shard 节点隐式创建collection。sharding状态下，该字段基本为 false，即不允许 shard 节点隐式创建collection</p>
<ul>
<li>对于 <code>insert</code> / <code>update</code> / <code>delete</code> 这三类请求，会在 <code>ClusterWriteCmd::InvocationBase::runImpl()</code> 中进行 <code>batchedRequest.setAllowImplicitCreate(false);</code> </li>
<li><code>src/mongo/s/cluster_commands_helpers.cpp</code> 中也提供了 <code>scatterGatherVersionedTargetByRoutingTable</code> / <code>scatterGatherUnversionedTargetAllShards</code> / <code>scatterGatherOnlyVersionIfUnsharded</code> / <code>executeCommandAgainstDatabasePrimary</code> 函数。如果请求包中不显式声明 <code>allowImplicitCollectionCreation</code> ，则默认为 <code>false</code> <ul>
<li>但是 <strong>renameCollection</strong> 及 <strong>covertToCapped</strong> 会将 <code>appendAllowImplicitCreate</code> 声明为 <code>true</code>(可以隐式创建collection)</li>
</ul>
</li>
</ul>
<blockquote>
<p>shard节点可以直接创建collection，即为<strong>隐式创建collection</strong>(rs实例均采用这种方式)。否则需要和 config 交互来完成 collection 的创建，即为<strong>显式创建collection</strong></p>
</blockquote>
<h2 id="2-shard节点-收到-mongos节点-转发过来携带-allowImplicitCollectionCreation-false的-insert-请求"><a href="#2-shard节点-收到-mongos节点-转发过来携带-allowImplicitCollectionCreation-false的-insert-请求" class="headerlink" title="2. shard节点 收到 mongos节点 转发过来携带 allowImplicitCollectionCreation=false的 insert 请求"></a>2. shard节点 收到 mongos节点 转发过来携带 <code>allowImplicitCollectionCreation=false</code>的 insert 请求</h2><p>正常情况下， shard节点 按照如下流程处理 insert 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongod::handleRequest() --&gt; ServiceEntryPointCommon::handleRequest() --&gt; receivedCommands() --&gt; execCommandDatabase() --&gt; runCommandImpl() --&gt; WriteCommand::InvocationBase::run() --&gt; CmdInsert::Invocation::runImpl() --&gt; performInserts() --&gt; insertBatchAndHandleErrors() --&gt; acquireCollection() --&gt; makeCollection() --&gt; DatabaseImpl::userCreateNS() --&gt; createCollection()</span><br></pre></td></tr></table></figure>



<p>而由于 <code>allowImplicitCollectionCreation=false</code> ，在 <code>execCommandDatabase()</code> 时会将 <code>allowImplicitCollectionCreation</code> 设置到 <code>OperationShardingState</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oss.setAllowImplicitCollectionCreation(allowImplicitCollectionCreationField);</span><br></pre></td></tr></table></figure>



<p><code>createCollection()</code> 中则获取该值，判断为false，进行uassert，产生异常，向上抛出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uassert(CannotImplicitlyCreateCollectionInfo(nss), <span class="string">"request doesn't allow collection to be created implicitly"</span>, OperationShardingState::<span class="built_in">get</span>(opCtx).allowImplicitCollectionCreation());</span><br></pre></td></tr></table></figure>



<p>异常在 <code>insertBatchAndHandleErrors</code> 中被 catch 住，在 <code>handleError()</code> 中判断异常为 <code>CannotImplicitlyCreateCollectionInfo</code> ，将异常信息设置到 <code>OperationShardingState</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ex.extraInfo&lt;CannotImplicitlyCreateCollectionInfo&gt;()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; oss = OperationShardingState::<span class="built_in">get</span>(opCtx);</span><br><span class="line">  oss.setShardingOperationFailedStatus(ex.toStatus());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此原有处理流程结束， 退回到 <code>execCommandDatabase()</code> 中触发析构逻辑，在 <code>ScopedOperationCompletionShardingActions</code> 进行析构的时候处理之前设置到 <code>OperationShardingState</code> 中的异常状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> scoped = behaviors.scopedOperationCompletionShardingActions(opCtx);</span><br></pre></td></tr></table></figure>



<p><code>ScopedOperationCompletionShardingActions</code> 的析构函数中，会通过 <code>onCannotImplicitlyCreateCollection</code> 函数向 config节点 下发一个 <code>_configsvrCreateCollection</code> 请求。发生异常则日志记录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScopedOperationCompletionShardingActions::~ScopedOperationCompletionShardingActions() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> cannotImplicitCreateCollInfo = status-&gt;extraInfo&lt;CannotImplicitlyCreateCollectionInfo&gt;()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ShardingState::<span class="built_in">get</span>(_opCtx)-&gt;enabled()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> handleCannotImplicitCreateStatus = onCannotImplicitlyCreateCollection(_opCtx, cannotImplicitCreateCollInfo-&gt;getNss());</span><br><span class="line">            <span class="keyword">if</span> (!handleCannotImplicitCreateStatus.isOK())</span><br><span class="line">                <span class="built_in">log</span>() &lt;&lt; <span class="string">"Failed to handle CannotImplicitlyCreateCollection exception"</span> &lt;&lt; causedBy(redact(handleCannotImplicitCreateStatus));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-config节点-处理-configsvrCreateCollection-请求"><a href="#3-config节点-处理-configsvrCreateCollection-请求" class="headerlink" title="3. config节点 处理 _configsvrCreateCollection 请求"></a>3. config节点 处理 <code>_configsvrCreateCollection</code> 请求</h2><p>config节点 收到 <code>_configsvrCreateCollection</code> 请求后，在 <code>ConfigSvrCreateCollectionCommand::typedRun()</code> 中进行处理</p>
<ol>
<li>首先通过和 <code>config.locks</code> 交互获取 <code>collection</code> 对应 namespace 和 database 的分布式锁</li>
<li>然后通过 <code>ShardingCatalogManager::createCollection()</code> 和 primaryShard 交互，完成collection创建</li>
</ol>
<h2 id="4-shard节点-处理-configsvrCreateCollection-结果"><a href="#4-shard节点-处理-configsvrCreateCollection-结果" class="headerlink" title="4. shard节点 处理 _configsvrCreateCollection 结果"></a>4. shard节点 处理 <code>_configsvrCreateCollection</code> 结果</h2><p>如 <strong>阶段2</strong> 中提到 <code>ScopedOperationCompletionShardingActions</code> 代码中，如 <code>_configsvrCreateCollection</code> 结果未按预期完成，则打印”Failed to handle CannotImplicitlyCreateCollection exception”日志记录。随后继续进行 <code>insert</code> 请求处理，此时因发生了 <code>CannotImplicitlyCreateCollectionInfo</code> 异常，所以最终 shard节点 向 mongos节点 返回一个 “request doesn’t allow collection to be created implicitly” 错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  n: 0,</span><br><span class="line">  writeErrors: [ &#123; </span><br><span class="line">    index: 0,</span><br><span class="line">    code: 227,</span><br><span class="line">    ns: "xxx.xxx",</span><br><span class="line">    errmsg: "request doesn't allow collection to be created implicitly" </span><br><span class="line">    &#125; ],</span><br><span class="line">  opTime: &#123; ts: Timestamp(1596026022, 1), t: 87 &#125;,</span><br><span class="line">  electionId: ObjectId('7fffffff0000000000000057'),</span><br><span class="line">  ok: 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-mongos节点-处理第一次-insert-结果"><a href="#5-mongos节点-处理第一次-insert-结果" class="headerlink" title="5. mongos节点 处理第一次 insert 结果"></a>5. mongos节点 处理第一次 <code>insert</code> 结果</h2><p>如 <strong>阶段1</strong> 中描述，mongos节点 <code>BatchWriteExec::executeBatch()</code> 中构造 <code>MultiStatementTransactionRequestsSender()</code> 向下游分发，并等待返回结果。</p>
<p>收到结果后，通过 <code>BatchWriteOp::noteBatchResponse()</code> 处理 response</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch was ok, note response</span></span><br><span class="line">batchOp.noteBatchResponse(*batch, batchedCommandResponse, &amp;trackedErrors);</span><br></pre></td></tr></table></figure>



<p><code>BatchWriteOp::noteBatchResponse()</code> 的入参中有一个 <code>BatchedCommandResponse</code> 对象记录所有节点返回的结果。而 <code>BatchWriteOp</code> 中的 <code>_writeOps</code> 则记录了向各个节点下发的请求，根据response结果一一标记对应的request。最终在 <code>WriteOp::_updateOpState()</code> 中对 当前writeOp 进行标记。如果 <code>writeError == StaleShardVersion</code> 或者 <code>writeError == CannotImplicitlyCreateCollection</code>，则当前 writeOp 的状态仍然保留为 <code>WriteOpState_Ready</code>，而如果遇到其他异常则被标记位 <code>WriteOpState_Error</code>，请求正常完成则被标记为 <code>WriteOpState_Completed</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finish the response (with error, if needed)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == writeError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ordered || !lastError) &#123;</span><br><span class="line">        writeOp.noteWriteComplete(*<span class="built_in">write</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We didn't actually apply this write - cancel so we can retarget</span></span><br><span class="line">        dassert(writeOp.getNumTargeted() == <span class="number">1u</span>);</span><br><span class="line">        writeOp.cancelWrites(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    writeOp.noteWriteError(*<span class="built_in">write</span>, *writeError);</span><br><span class="line">    lastError = writeError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随后在 <code>BatchWriteExec::executeBatch()</code> 中判断 <code>batchOp.isFinished()</code> (有 <code>WriteOpState_Error</code> 则为 true，有<code>WriteOpState_Ready</code> 则为false)，此时由于 <strong>阶段4</strong> 中返回的是 <code>CannotImplicitlyCreateCollection</code>，所以 <code>batchOp.isFinished()</code> 的结果为 false。则继续构建 insert 请求下发给 shard节点进行重试。</p>
<h2 id="6-shard节点-处理第二次-insert-请求-amp-mongos节点-处理第二次-insert-结果"><a href="#6-shard节点-处理第二次-insert-请求-amp-mongos节点-处理第二次-insert-结果" class="headerlink" title="6. shard节点 处理第二次 insert 请求 &amp; mongos节点 处理第二次 insert 结果"></a>6. shard节点 处理第二次 <code>insert</code> 请求 &amp; mongos节点 处理第二次 <code>insert</code> 结果</h2><p>由于 <strong>阶段3</strong> 中 config节点 已经触发 shard节点 完成collection的创建了，所以此时按照 <strong>阶段2</strong> 中的正常流程 <code>insertBatchAndHandleErrors</code> 继续处理完成，最终返回用户一个处理完成的 insert 请求结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  n: 1,</span><br><span class="line">  opTime: &#123; ts: Timestamp(1596026028, 6), t: 87 &#125;,</span><br><span class="line">  electionId: ObjectId('7fffffff0000000000000057'),</span><br><span class="line">  ok: 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mongos节点 收到结果后按照 <strong>阶段5</strong> 中描述的由于没有error，则将结果组装后正常返回给上游用户</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/lock/OCC/OCC-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/lock/OCC/OCC-overview/" itemprop="url">关于乐观锁的探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T16:41:56+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/lock/" itemprop="url" rel="index">
                    <span itemprop="name">lock</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/lock/OCC/" itemprop="url" rel="index">
                    <span itemprop="name">OCC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>乐观并发控制</strong>（又名“<strong>乐观锁</strong>”，Optimistic Concurrency Control，缩写“OCC”）</p>
</blockquote>
<h2 id="为什么要使用锁"><a href="#为什么要使用锁" class="headerlink" title="为什么要使用锁"></a>为什么要使用锁</h2><p>在多线程编程领域，基本上所有的编程模型都采用了“<strong>并发访问串行处理</strong>”的策略，而方法就是给临界资源加一把锁</p>
<h2 id="并发控制策略-：乐观锁、悲观锁"><a href="#并发控制策略-：乐观锁、悲观锁" class="headerlink" title="并发控制策略 ：乐观锁、悲观锁"></a>并发控制策略 ：乐观锁、悲观锁</h2><p>锁的一种宏观分类方式是<strong>悲观锁</strong>和<strong>乐观锁</strong>。悲观锁与乐观锁<strong>并不是特指某个锁</strong>，而是在并发情况下的两种不同策略。</p>
<ul>
<li>悲观锁(Pessimistic Lock) : 就是很悲观，每次去拿数据的时候都认为别人会修改。所以<strong>每次在拿数据的时候都会上锁</strong>。这样别人想拿数据就被挡住，直到悲观锁被释放。</li>
<li>乐观锁(Optimistic Lock) : 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，<strong>更新前检查在读取至更新这段时间别人有没有修改过这个数据</strong>。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）。</li>
</ul>
<p>缺点：悲观锁阻塞事务，乐观锁回滚重试。</p>
<h3 id="悲观锁的代价"><a href="#悲观锁的代价" class="headerlink" title="悲观锁的代价"></a>悲观锁的代价</h3><p>日常用到的加锁基本都是悲观锁。悲观锁是用来做并发最简单的方式，其代价也是最高的：</p>
<ul>
<li>加锁、释放锁会需要操作系统进行上下文切换和调度延时，在上下文切换的时候，cpu之前缓存的指令和数据都将失效，这个过程将增加系统开销。</li>
<li>多个线程同时竞争锁，锁竞争机制本身需要消耗系统资源。没有获取到锁的线程会被挂起直至获取锁，在线程被挂起和恢复执行的过程中也存在很大开销。</li>
<li>等待锁的线程会阻塞，影响实际的使用体验。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(Priority Inversion)。</li>
</ul>
<h3 id="乐观锁、悲观锁的选择"><a href="#乐观锁、悲观锁的选择" class="headerlink" title="乐观锁、悲观锁的选择"></a>乐观锁、悲观锁的选择</h3><p>适用场景考虑几个因素：</p>
<ol>
<li>响应速度：需要响应速度快使用乐观锁</li>
<li>冲突频率：<ol>
<li>对于资源竞争较少（多读场景、线程冲突较轻）的情况选择<strong>乐观锁</strong> ：使用悲观锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而乐观锁操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（多写场景，线程冲突严重）的场景选择<strong>悲观锁</strong> ：乐观锁自旋的概率会比较大，从而浪费更多的CPU资源，效率低于悲观锁。</li>
</ol>
</li>
<li>重试代价：代价高则用悲观锁</li>
</ol>
<h2 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h2><p>乐观锁允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为<strong>无锁编程</strong>。</p>
<p>换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！（下文描述的版本号机制也是基于 MySQL 中提供了一个原子操作，这个原子操作最终也可能是一个CAS或者悲观锁）</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</p>
<p><strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<p><strong>CAS利用CPU指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。</strong></p>
<h4 id="CAS-带来的问题"><a href="#CAS-带来的问题" class="headerlink" title="CAS 带来的问题"></a>CAS 带来的问题</h4><ol>
<li><code>ABA</code>问题：比如说一个线程<code>T1</code>从内存位置<code>V</code>中取出<code>A</code>，这时候另一个线程<code>T2</code>也从内存中取出<code>A</code>，并且<code>T2</code>进行了一些操作变成了<code>B</code>，然后<code>T2</code>又将<code>V</code>位置的数据变成<code>A</code>，这时候线程<code>T1</code>进行<code>CAS</code>操作发现内存中仍然是<code>A</code>，然后<code>T1</code>操作成功。尽管线程<code>T1</code>的<code>CAS</code>操作成功，但可能存在潜藏的问题。</li>
<li>循环时间长开销大：自旋<code>CAS</code>（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。</li>
</ol>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set name &#x3D; &#39;XXX&#39;, version &#x3D; version + 1 where id &#x3D; #&#123;id&#125; and version &#x3D; #&#123;version&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="MVCC-：-Multi-Version-Concurrency-Control-即多版本并发控制"><a href="#MVCC-：-Multi-Version-Concurrency-Control-即多版本并发控制" class="headerlink" title="MVCC ： Multi-Version Concurrency Control, 即多版本并发控制"></a>MVCC ： Multi-Version Concurrency Control, 即<strong>多版本并发控制</strong></h3><p>MVCC 是实现乐观锁的一种方案，用空间（多版本）以及回滚成本（冲突），保证可重复读且没有幻读（读小于自己事务ID的版本）避免（或减少）加锁。</p>
<h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><ol>
<li><strong>多版本并发控制</strong>（MVCC），来实现 MySQL 上的<code>多事务``并发访问</code>时，隔离级别控制；</li>
<li><strong>数据版本</strong>：并发事务执行时，同一行数据有多个版本</li>
<li><strong>事务版本</strong>：每个事务都有一个事务版本</li>
<li>版本有序 ：版本是通过<code>时间</code>来标识的<ul>
<li><strong>数据版本</strong>：包含<code>创建版本</code>（创建时间）、<code>删除版本</code>（删除时间）</li>
<li><strong>事务版本</strong>：事务的<code>创建时间</code>，作为<code>事务版本</code></li>
<li>Note：<strong>数据版本</strong>，并不包含<code>更新版本</code>（更新时间），因为，在多事务并发情况下，更新操作，实际是：<code>删除原数据</code> + <code>新增新数据</code></li>
</ul>
</li>
</ol>
<p><img src="https://wangxin201492.github.io/techImages/mvcc-version-relation.png" alt="mvcc-version-relation.png"></p>
<h4 id="MVCC-本质"><a href="#MVCC-本质" class="headerlink" title="MVCC 本质"></a>MVCC 本质</h4><ol>
<li>本质使用了<code>copy-on-write</code>（写时复制），为每个数据保留多份 snapshot</li>
<li>不同 snapshot 之间，使用<code>指针</code>连接成<code>链表</code>；</li>
<li>创建事务，能看到的 snapshot 是受限的，是链表上，<code>小于等于</code>当前事务版本的<code>最大版本</code>（读取已提交：离当前事务<code>最近</code>的<code>已提交</code>版本）</li>
<li><code>update</code> 操作，创建一个新的 snapshot，并使用事务版本，作为创建版本；</li>
</ol>
<p><img src="https://wangxin201492.github.io/techImages/mvcc-snapshot-list.png" alt="mvcc-snapshot-list.png"></p>
<h4 id="MVCC-历史数据清理"><a href="#MVCC-历史数据清理" class="headerlink" title="MVCC 历史数据清理"></a>MVCC 历史数据清理</h4><p>// TODO</p>
<h4 id="MVCC在事务中使用"><a href="#MVCC在事务中使用" class="headerlink" title="MVCC在事务中使用"></a>MVCC在事务中使用</h4><p>MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）</p>
<ol>
<li>Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC。原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。</li>
<li>串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。</li>
</ol>
<p>通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。</p>
<p>RR 和 RC 隔离级别生成 ReadView 时间不同</p>
<ol>
<li>在 <code>RR</code> 隔离级别下，每个事务 <code>touch first read</code> 时（本质上就是执行第一个 <code>SELECT</code> 语句时，后续所有的 <code>SELECT</code> 都是复用这个 <code>ReadView</code> ，其它 <code>update</code> , <code>delete</code> , <code>insert</code> 语句和一致性读 <code>snapshot</code> 的建立没有关系），会将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code> 。</li>
<li>在 <code>RC</code> 隔离级别下，每个 <code>SELECT</code> 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code> 。</li>
</ol>
<p>二者的区别就在于生成 <code>ReadView</code> 的时间点不同，一个是事务之后第一个 <code>SELECT</code> 语句开始、一个是事务中每条 <code>SELECT</code> 语句开始。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71156910</a></li>
<li><a href="https://segmentfault.com/a/1190000016611415" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016611415</a></li>
<li><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="noopener">https://juejin.im/post/5b4977ae5188251b146b2fc8</a></li>
<li><a href="https://segmentfault.com/a/1190000015239603" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015239603</a></li>
<li><a href="http://ningg.top/inside-mysql-transaction-and-mvcc/" target="_blank" rel="noopener">http://ningg.top/inside-mysql-transaction-and-mvcc/</a></li>
<li><a href="https://www.codercto.com/a/88775.html" target="_blank" rel="noopener">https://www.codercto.com/a/88775.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/MongoDB-Timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/MongoDB-Timer/" itemprop="url">MongoDB 源码中定时器机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T09:42:24+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MongoDB 提供了2种定时执行机制</p>
<ul>
<li><code>TaskExecutor::scheduleWorkAt(Date_t when, CallbackFn&amp;&amp; work)</code></li>
<li><code>PeriodicRunner::PeriodicJob</code></li>
</ul>
<h2 id="TaskExecutor-scheduleWorkAt"><a href="#TaskExecutor-scheduleWorkAt" class="headerlink" title="TaskExecutor::scheduleWorkAt"></a>TaskExecutor::scheduleWorkAt</h2><p><code>TaskExecutor::scheduleWorkAt</code> 提供了一个在指定时间 <code>when</code> 执行的方式，具体在 <code>ThreadPoolTaskExecutor</code> 中实现。</p>
<p><code>ThreadPoolTaskExecutor</code>实现 <code>scheduleWorkAt</code> 方法和 <code>scheduleWork</code> 逻辑基本一致：将 <code>CallbackFn</code> 添加到一个 <code>WorkQueue</code> 中，并获得一个 <code>CallbackHandle</code>，随后将 <code>WorkQueue</code> 插入到 <code>_poolInProgressQueue</code> 中等待被处理。区别在于：</p>
<ul>
<li><code>scheduleWork</code> 将 <code>CallbackFn</code> 添加到一个 temp 的 WorkQueue，而 <code>scheduleWorkAt</code> 添加到 <code>_sleepersQueue</code></li>
<li><code>scheduleWork</code> 中直接将 <code>WorkQueue</code> 中数据插入到 <code>_poolInProgressQueue</code> 中，而 <code>scheduleWorkAt</code> 则是通过 <code>_net::setAlarm</code> 注册一个时间 when 后回调插入的(<code>_net</code> 为一个 <code>NetworkInterfaceTL</code> 成员)。</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusWith&lt;TaskExecutor::CallbackHandle&gt; <span class="title">ThreadPoolTaskExecutor::scheduleWorkAt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Date_t when, CallbackFn&amp;&amp; work)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> wq = makeSingletonWorkQueue(<span class="built_in">std</span>::<span class="built_in">move</span>(work), <span class="literal">nullptr</span>, when);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> cbHandle = enqueueCallbackState_inlock(&amp;_sleepersQueue, &amp;wq);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> status = _net-&gt;setAlarm(cbHandle.getValue(), </span><br><span class="line">                                 when, </span><br><span class="line">                                 [<span class="keyword">this</span>, cbHandle = cbHandle.getValue()](Status status) &#123;</span><br><span class="line">            ...</span><br><span class="line">            scheduleIntoPool_inlock(&amp;_sleepersQueue, cbState-&gt;iter, <span class="built_in">std</span>::<span class="built_in">move</span>(lk));</span><br><span class="line">        &#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cbHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> <strong>Note:</strong>   <code>scheduleWorkAt</code> 和 <code>scheduleWork</code> 都会返回一个 <code>TaskExecutor::CallbackHandle</code> 对象  <code>cbHandle</code>，这个 <code>cbHandle</code> <em>不是一个回调函数*，应该是表示回调状态 的一个对象， <code>CallbackHandle</code> 持有一个 <code>CallbackState</code> , 而 <code>CallbackState</code> 的类注释为 *”Class representing a  scheduled callback and providing methods for interacting with it.”</em></p>
<p>具体的回调函数即上文提到的 <code>CallbackFn</code> 被添加到 <code>WorkQueue</code>  中，而后被添加到*   <code>_poolInProgressQueue</code> 等待被消费</p>
</blockquote>
<p><code>NetworkInterfaceTL::setAlarm</code> 接收 3 个入参：<code>cbHandle</code>, <code>when</code>, <code>action</code>，<code>cbHandle</code> 主要做一些 状态管理 、 合理性校验等逻辑。action即为当面提到的将 <code>WorkQueue</code> 添加到 <code>_poolInProgressQueue</code> 的回调。</p>
<p><code>NetworkInterfaceTL::setAlarm</code> 中 构造了一个 <code>PromiseFuture</code> 对象 <strong>pf ( future为 action）</strong>，并将时间点 when，回调状态 <code>cbHandle</code>，新建一个 <code>ASIOReactorTimer timer</code>，以及 pf.promise 封装成一个 <code>AlarmState</code> 。然后调用 <code>timer-&gt;waitUntil( when )</code> 等待到达指定时间（witerUntil 实际上也是返回一个 Future），指定时间到达时调用 <code>_answerAlarm</code> 标记 满足 promise（及触发上文 action ）</p>
<p> 关于指定时间执行的行为则在 <code>NetworkInterfaceTL::setAlarm</code> 中实现。</p>
<p><code>ASIOReactorTimer</code> 中会持有一个 <code>_timer (asio::system_timer)</code> ，<code>waitUntil()</code> 中会依次调用 <code>_timer-&gt;expires_at()</code>, <code>_timer-&gt;async_wait()</code>进行计时等待</p>
<p><strong>总结一下</strong>：<code>TaskExecutor::scheduleWorkAt</code> 实际上是基于 <code>asio::system_timer</code> 库实现的指定时间执行逻辑。</p>
<ul>
<li>指定时间到达后，会标记 满足 promise ，调用 <code>_answerAlarm</code> </li>
<li><code>_answerAlarm</code> 中进行一系列判断后 也会标记 满足 promise ， 调用 action</li>
<li>action 中 会将 <code>_sleepersQueue</code> 中的数据插入到 <code>_poolInProgressQueue</code> 排队等待执行</li>
</ul>
<p>由于 整个逻辑中回调函数比较多，所以堆栈会比较冗长，这里是以 为例的堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#0  mongo::ReplicaSetMonitor::_doScheduledRefresh (this&#x3D;0x7f0362e0fb00, currentHandle&#x3D;...) at src&#x2F;mongo&#x2F;client&#x2F;replica_set_monitor.cpp:249</span><br><span class="line">#5  0x00007f035e3fdd28 in mongo::executor::ThreadPoolTaskExecutor::runCallback (this&#x3D;0x7f0362e19140, cbStateArg&#x3D;...) at src&#x2F;mongo&#x2F;executor&#x2F;thread_pool_task_executor.cpp:659</span><br><span class="line">#7  0x00007f035e3ff7ad in mongo::executor::ThreadPoolTaskExecutor::scheduleIntoPool_inlock(mongo::executor::ThreadPoolTaskExecutor::WorkQueue*, const iterator&amp;, const iterator&amp;, std::unique_lock&lt;std::mutex&gt;)</span><br><span class="line">#16 0x00007f035e3fee44 in mongo::executor::ThreadPoolTaskExecutor::scheduleWorkAt(mongo::Date_t, mongo::executor::TaskExecutor::CallbackFn&amp;&amp;)</span><br><span class="line">#30 0x00007f035e43d6f2 in mongo::executor::NetworkInterfaceTL::_answerAlarm(mongo::Status, std::shared_ptr&lt;mongo::executor::NetworkInterfaceTL::AlarmState&gt;)</span><br></pre></td></tr></table></figure>



<h2 id="PeriodicRunner-PeriodicJob"><a href="#PeriodicRunner-PeriodicJob" class="headerlink" title="PeriodicRunner::PeriodicJob"></a>PeriodicRunner::PeriodicJob</h2><p> Periodic* 类涉及3个接口：</p>
<ul>
<li><code>PeriodicJob</code> 描述一个周期性 job，接收3个参数：<strong>job名称 name, Job执行逻辑 callable, 执行间隔 period</strong></li>
<li><code>ControllableJob : PeriodicJob</code> 实际执行逻辑，<em>start / pause / resume / stop</em> .      <ul>
<li><code>PeriodicJobImpl</code> 继承实现了该类。</li>
</ul>
</li>
<li><code>PeriodicJobAnchor</code> : 包装一个 <code>ControllableJob</code> ，用于控制 <code>ControllableJob</code> 的执行。<em>start / pause /     resume / stop</em> .</li>
<li><code>PeriodicRunner</code> ： 提供一个<code>makeJob</code> – 初始化 <code>PeriodicJob</code> / <code>PeriodicJobImpl</code> / <code>PeriodicJobAnchor</code>.<ul>
<li><code>PeriodicRunnerImpl</code> 继承实现了该类</li>
</ul>
</li>
</ul>
<p>上面这几个接口主要提供 job 的描述，job 运行的管理，但是也有2个比较奇怪的地方：</p>
<ul>
<li><code>PeriodicJobImpl</code> 看名称疑似 <code>PeriodicJob</code> 的具体实现，然而却是 <code>ControllableJob</code> 的实现</li>
<li><code>PeriodicJobAnchor</code> 和 <code>ControllableJob</code> 都提供了 job 的 <em>start / pause / resume / stop</em> 行为。<code>PeriodicJobAnchor</code> 中包装一个 <code>ControllableJob</code> 对象 _handle，所有的 job 行为也都直接调用了 _handle 对应的函数</li>
</ul>
<p>每个 job 有独立的线程处理，线程的名称即为 job 的名称。job 的运行管理在 <code>PeriodicJobImpl::_run</code> 中实现，负责管理的 <em>pause / resume / stop</em> 等行为会修改 job 的执行状态，<code>_run</code> 在执行前根据被标记的执行状态作出具体的处理。</p>
<p>正常情况下( RUNNING状态 )，_run 会调用 <code>clockSource-&gt;waitForConditionUntil</code>  ( _clockSource 为 <code>servicecontext -&gt;getPreciseClockSource()</code> )，这中间由于 <code>tracksSystemClock = true / waitable = null</code>，所以时间等待最终的实现是 <code>stdx::condition_variable.wait_util(lock, deadline);</code></p>
<blockquote>
<p><strong>Note:</strong>   PeriodicRunner::PeriodicJob 虽然进行初始化的时候传入的是一个 interval ，但是实际最终执行还是基于上次  job 开始执行的时间 + interval 获得一个 deadline 来定义下一次任务的触发时</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/MongoDB-ReplicaSetMonitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/MongoDB-ReplicaSetMonitor/" itemprop="url">MongoDB ReplicaSetMonitor对shard探测机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-27T12:59:24+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>sharding实例对后端 shard 会进行状态探测，以发现 shard 是否有节点更新（ 选主、节点加入、节点异常）。提供探测能力的核心类为 <code>ReplicaSetMonitor</code> 及相关类。</p>
<p>对于状态探测的基本逻辑应该也比较好构思：<strong>定期状态探测、探测结果存储、探测结果查询</strong>。MongoDB中也按照这个逻辑来完成的： </p>
<ul>
<li><p><code>ReplicaSetMonitor</code> 提供状态查询的接口，以及定期探测触发能力。状态信息存储在 <code>_state</code> (<code>SetState</code>类型成员变量) 中</p>
</li>
<li><p><code>SetState</code> 存储 ReplicaSet shard 的状态信息。包装 Node 记录各个 Node 的信息，持有一个 <code>ScanState</code> 记录该 ReplicaSet 当前正在 scan 的信息</p>
</li>
<li><p>Refresher 进行实际的状态探测，提供一个 static 方法 <code>ensureScanInProgress</code> 来初始化一个 Refresher 进行探测。</p>
<ul>
<li><code>Refresher</code> 与 <code>SetState</code> 是一一绑定的，只有 <code>SetState</code> 在被探测状态，才会有对应的 <code>Refresher</code> 产生</li>
</ul>
</li>
<li><p><code>ScanState</code> 记录 <code>Refresher</code> 探测过程中的状态信息。<code>ScanState</code> 会被 <code>SetState::currentScan</code> 及 <code>Refresher::_scan</code> 持有，一般情况下这2个 scan 是相同的，但是可能存在并发的场景导致指向的不是同一个 scan， 这时候以 <code>SetState::currentScan</code> 为准。</p>
</li>
</ul>
<p>ReplicaSetMonitor / SetState / Refresher / ScanState 具体关系参考下图：</p>
<p><img src="https://wangxin201492.github.io/techImages/MongoDB-ReplicaSetMonitor.png" alt="MongoDB-ReplicaSetMonitor.png"></p>
<h2 id="探测目标-shard-要求"><a href="#探测目标-shard-要求" class="headerlink" title="探测目标 shard 要求"></a>探测目标 shard 要求</h2><p><strong>只有以 ReplicaSet 方式启动的 shard(包含 config )，才会持有一个 <code>ReplicaSetMonitor</code> 类的成员。</strong>即只有 ReplicaSet shard 才会被探测，以 Standalong 方式启动的 shard 不会进行探测</p>
<h2 id="探测触发"><a href="#探测触发" class="headerlink" title="探测触发"></a>探测触发</h2><p>ReplicaSetMonitor 中会<strong>定期进行 shard 状态探测</strong>，如果当前维系的状态<strong>不能满足其他代码的 ReadPreference 要求，也会下发探测</strong></p>
<h3 id="定期探测"><a href="#定期探测" class="headerlink" title="定期探测"></a>定期探测</h3><p><code>ReplicaSetMonitor</code> 初始化时会调用<code>_scheduleRefresh</code>，而后通过 <code>_scheduleRefresh</code> 和 <code>_doScheduledRefresh</code> 两个函数相互调用及 <code>TaskExecutor::scheduleWorkAt</code> 完成:</p>
<ul>
<li><code>_scheduleRefresh</code>中通过使用 <code>TaskExecutor::scheduleWorkAt</code> 注册定时任务，定时任务负责调用 <code>_doScheduledRefresh</code></li>
<li><code>_doScheduledRefresh</code> 负责调用 <code>Refresher::ensureScanInProgress</code> 进行 <code>Refresher</code> 新建与 探测下发。同时根据当前 <code>SetState</code> 的状态来决定下次刷新的周期，然后调用 <code>_scheduleRefresh</code> 注册新的定时任务</li>
</ul>
<p>默认情况下，定时任务每隔 <strong>kDefaultRefreshPeriod (30s)</strong> 执行一次。但是如果 SetState 的 waiters 结构中非空，则会将周期调整为 <strong>kExpeditedRefreshPeriod (500ms)</strong> 。SetState 的 waiters 结构中 数据添加在下文按需探测时，数据清理在探测执行完成时。</p>
<h3 id="按需探测"><a href="#按需探测" class="headerlink" title="按需探测"></a>按需探测</h3><p>代码中需要按照某种 ReadPreference 获得 shard 的部分节点地址时，会调用 ReplicaSetMonitor 提供 <code>getHostsOrRefresh</code> 函数。如果当前持有的 shard 信息不能满足 ReadPreference 时，会构造一个 promise-future，返回 future ，然后将 promise 添加到 SetState 的 waiter 中，并立即下发刷新。</p>
<ul>
<li>如果刷新结果能满足 ReadPreference ，则返回对应的host</li>
<li>如果不能满足，则会按照上文描述，下次 <code>_doScheduledRefresh</code> 被调用时，将刷新周期改为 <strong>500ms</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ReplicaSetMonitor::_doScheduledRefresh(<span class="keyword">const</span> CallbackHandle&amp; currentHandle) &#123;</span><br><span class="line">    ....</span><br><span class="line">    Refresher::ensureScanInProgress(_state, lk);</span><br><span class="line"></span><br><span class="line">    Milliseconds period = _state-&gt;refreshPeriod;</span><br><span class="line">    <span class="keyword">if</span> (_state-&gt;isExpedited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_state-&gt;waiters.empty()) &#123;</span><br><span class="line">            <span class="comment">// No current waiters so we can stop the expedited scanning.</span></span><br><span class="line">            _state-&gt;isExpedited = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            period = <span class="built_in">std</span>::<span class="built_in">min</span>(period, kExpeditedRefreshPeriod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _scheduleRefresh(_state-&gt;now() + period, lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="探测方式"><a href="#探测方式" class="headerlink" title="探测方式"></a>探测方式</h2><p>探测的核心 就是发送 <strong>isMaster()</strong> 命令并处理返回结果。</p>
<p>探测的中间状态记录在上文描述的 <strong>ScanState</strong> 中，主要持有几个 成员 来实现：</p>
<ul>
<li><strong>hostsToScan</strong> : 待执行队列</li>
<li><strong>possibleNodes</strong> :     非primary节点返回的node集合</li>
<li><strong>waitingFor</strong> : 已经发送命令，等待返回的集合</li>
<li><strong>triedHosts</strong> : 已经下发isMaster命令的集合</li>
</ul>
<p>探测过程有一个简单的状态机：<strong>CONTACT_HOST</strong>、<strong>WAIT</strong>、<strong>DONE</strong>，基于上面描述的 ScanState 持有的几个成员来判断：</p>
<ul>
<li><strong>CONTACT_HOST</strong> : 链接当前实例。如果 <strong>hostsToScan</strong> 中有 host，则会返回该 host 并标记状态为 <strong>CONTACT_HOST</strong></li>
<li><strong>WAIT</strong> : 等待 response 。如果 <strong>hostsToScan</strong> 为空，而 <strong>waitingFor</strong> 不为空则标记为 WAIT 状态</li>
<li><strong>DONE</strong> : Refresh 完成。如果 <code>_scan != _set-&gt;currentScan</code> 或者 <strong>hostsToScan</strong> &amp; <strong>waitingFor</strong> 均为空，则为 <strong>DONE</strong> 状态</li>
</ul>
<p>状态流转都在<code>getNextStep</code>中实现，用于<code>scheduleNetworkRequests</code>调度流转。</p>
<p><code>IsMasterReply</code> : 记录isMaster必要的返回信息</p>
<h3 id="请求下发"><a href="#请求下发" class="headerlink" title="请求下发"></a>请求下发</h3><p><code>scheduleNetworkRequests</code> 通过 <code>getNextStep</code> 依次从 <strong>hostsToScan</strong> 拿到一个host信息，并将 host 信息插入到 <strong>waitingFor</strong> 及 <strong>triedHosts</strong> 这 2 个 set 中。然后针对这个 host 调用 <code>scheduleIsMaster</code> </p>
<p><code>scheduleIsMaster</code> 构建一个 isMaster 的request ，提交给 executor ，并注册回调：</p>
<ul>
<li>如果当前 Refresher 的 <code>_scan</code> 和 <code>_set-&gt;currentScan</code> 不同，则忽略返回结果</li>
<li>如果返回结果是 ok，则调用 <code>receivedIsMaster</code>；否则调用 <code>failedHost</code></li>
</ul>
<h3 id="response处理"><a href="#response处理" class="headerlink" title="response处理"></a>response处理</h3><p><code>receivedIsMaster</code> : 将 host 从 waitingFor 中清理掉，然后构建一个 <code>IsMasterReply</code></p>
<ul>
<li>如果 <code>IsMasterReply</code> 的结果不是 ok ， 则会标记当前 host 为 fail</li>
<li>如果 reply 中 setName 和 _set 中的 name 不匹配，则会标记当前 host 为 fail</li>
<li>如果 reply 声明自己是 primary 节点， 则会调用 <code>receivedIsMasterFromMaster</code></li>
<li>找到 primary 节点以后的 reply 处理： 将 reply 更新到对应的 <code>_set</code> 的 node 上，并在 notify 中判断是否有已经满足 <code>_set-&gt;waiter</code> 的 promise，有则返回</li>
<li>未找到 primary 节点前的 reply 处理： 将 reply 的 member 全部加到 <strong>possibleNodes</strong> 中，如果在 reply 中声明了 primary 节点的地址且该 primary </li>
<li>在 <strong>triedHosts</strong> 中，则将该节点重新添加会 <strong>hostsToScan</strong>。然后将该 reply 记录到 <strong>unconfirmedReplies</strong> 中</li>
</ul>
<p><code>receivedIsMasterFromMaster</code> 处理逻辑比较多，简单整理了下：</p>
<ul>
<li>有效性判断：判断 <code>configVersion</code> / <code>electionId</code> 的有效性</li>
<li>状态存储：将 reply 的结果更新到 <code>SetState</code> 中。更新nodes / seedNodes / seedConnStr / workingConnstr</li>
<li>清理<code>ScanState</code> 中记录的信息：<strong>triedHost</strong> / <strong>waiitingFor</strong> / <strong>unconfirmedReplies</strong></li>
<li>如果 primary 有变化，则会通知所有的 listener 状态变更。</li>
</ul>
<p><code>failedHost</code> : 将 host从 <strong>waitingFor</strong> 中移除，并将node标记为 fail</p>
<p>无论<code>receivedIsMaster</code> 还是 <code>failedHost</code> 执行完成后，都会调用 <code>scheduleNetworkRequests</code> 重新调度（可能有新加入 <strong>hostsToScan</strong> 的节点）</p>
<h2 id="周边类"><a href="#周边类" class="headerlink" title="周边类"></a>周边类</h2><p><code>ReplicaSetMonitorManager</code> 是负责 <code>ReplicaSetMonitor</code> 的管理类，维护一个 map 结构 （记录 setName 和 <code>ReplicaSetMonitor</code>），一个<code>TaskExecutor</code> 用于所有 <code>ReplicaSetMonitor</code> 命令执行，以及一个<code>ReplicaSetChangeNotifier</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/command/serverStatus/MongoDB-request-counter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/command/serverStatus/MongoDB-request-counter/" itemprop="url">MongoDB 请求计数逻辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-22T17:25:43+08:00">
                2020-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/serverStatus/" itemprop="url" rel="index">
                    <span itemprop="name">serverStatus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>mongos上一个find请求堆栈主要路径是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#0 mongo::(anonymous namespace)::ClusterFindCmd::Invocation::run  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;cluster_find_cmd.cpp:205</span><br><span class="line"></span><br><span class="line">#1 0x00007f3701fae26a in mongo::(anonymous namespace)::execCommandClient  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:303</span><br><span class="line"></span><br><span class="line">#2 0x00007f3701faff38 in mongo::(anonymous namespace)::runCommand  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:489</span><br><span class="line"></span><br><span class="line">#3 0x00007f3701fb1f76 in mongo::Strategy::clientCommand at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:800</span><br><span class="line"></span><br><span class="line">#4 0x00007f3701e243cc in mongo::ServiceEntryPointMongos::handleRequest  at src&#x2F;mongo&#x2F;s&#x2F;service_entry_point_mongos.cpp:95</span><br><span class="line"></span><br><span class="line">#5 0x00007f3701e7d5e2 in mongo::ServiceStateMachine::_processMessage  at src&#x2F;mongo&#x2F;transport&#x2F;service_state_machine.cpp:452</span><br></pre></td></tr></table></figure>



<p><code>db.serverStatus()</code> 输出结果中有3个地方对请求进行了计数，这里简单整理下</p>
<ol>
<li><code>db.serverStatus().network.numRequests</code>(简称<strong>requests计数</strong>） – 对应在堆栈中#5（即 <code>ServiceStateMachine::_processMessage()</code>）进行计数。表示<strong>接收的网络包数量</strong></li>
<li><code>db.serverStatus().metrics.commands.*.total &amp; failed</code>（简称<strong>metrics计数</strong>） – 对应在堆栈中#1（即 <code>execCommandClient()</code> ）进行计数。表示<strong>不同命令执行的次数</strong></li>
<li><code>db.serverStatus().opcounters</code>（简称<strong>opcounters计数</strong>） – 对应在堆栈中#0（即 <code>Invocation::run()</code>）即进行计数。表示<strong>requests计数</strong></li>
</ol>
<p><strong>requests计数</strong>和<strong>metrics计数</strong>的逻辑是固定的，而对于opcounters计数会根据请求的不同有一定gap。</p>
<h2 id="opcounters-计数分析"><a href="#opcounters-计数分析" class="headerlink" title="opcounters 计数分析"></a>opcounters 计数分析</h2><p><code>db.serverStatus().opcounters</code> 包含如下结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"insert"</span> : NumberLong(<span class="number">6</span>),</span><br><span class="line">        <span class="attr">"query"</span> : NumberLong(<span class="number">1</span>),</span><br><span class="line">        <span class="attr">"update"</span> : NumberLong(<span class="number">2</span>),</span><br><span class="line">        <span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">        <span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">        <span class="attr">"command"</span> : NumberLong(<span class="number">75</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>ServiceEntryPointMongos::handleRequest()</code>中对计数场景进行了区分：</p>
<h3 id="计数场景1：-opcode-OP-MSG-或者-opcode-OP-QUERY-且-namespace的collection部分-“-cmd”"><a href="#计数场景1：-opcode-OP-MSG-或者-opcode-OP-QUERY-且-namespace的collection部分-“-cmd”" class="headerlink" title="计数场景1：(opcode == OP_MSG) 或者 (opcode == OP_QUERY 且 namespace的collection部分 == “$cmd”)"></a>计数场景1：(<code>opcode == OP_MSG</code>) 或者 (<code>opcode == OP_QUERY</code> 且 namespace的collection部分 == “$cmd”)</h3><p>按照上面举例的find堆栈 <code>clientCommand()</code> –&gt; <code>runCommand()</code> –&gt; <code>execCommandClient()</code> –&gt; <code>Invocation::run()</code> 依次调用。这里所有的command都会继承 Command 类，该类提供一个 <code>shouldAffectCommandCounter()</code> 返回True。</p>
<ul>
<li>insert / update / delete / query / getmore 请求重写了 <code>shouldAffectCommandCounter()</code> 返回 false ，在 <code>Invocation::run()</code> 中完成计数</li>
<li>其余请求均作为 command，在 <code>execCommandClient()</code> 中完成计数</li>
</ul>
<h3 id="计数场景2：opcode-OP-QUERY-且-namespace的collection部分-“-cmd”"><a href="#计数场景2：opcode-OP-QUERY-且-namespace的collection部分-“-cmd”" class="headerlink" title="计数场景2：opcode == OP_QUERY 且 namespace的collection部分 != “$cmd”"></a>计数场景2：<code>opcode == OP_QUERY</code> 且 namespace的collection部分 != “$cmd”</h3><p>直接调用 <code>Strategy::queryOp()</code>， 并在其中完成计数</p>
<h3 id="计数场景3：opcode-OP-GET-MORE"><a href="#计数场景3：opcode-OP-GET-MORE" class="headerlink" title="计数场景3：opcode == OP_GET_MORE"></a>计数场景3：<code>opcode == OP_GET_MORE</code></h3><p>直接调用 <code>Strategy::getMore()</code>，并在其中完成计数</p>
<h3 id="计数场景4：opcode-OP-KILL-CURSORS"><a href="#计数场景4：opcode-OP-KILL-CURSORS" class="headerlink" title="计数场景4：opcode == OP_KILL_CURSORS"></a>计数场景4：<code>opcode == OP_KILL_CURSORS</code></h3><p>直接调用 <code>Strategy::killCursors()</code>，并在其中调用 <code>OpCounters::gotOp()</code></p>
<p>gotOp 对 OP_KILL_CURSORS / OP_REPLY 不进行计数，即这两种场景不会记录在 opcounters 中</p>
<h3 id="计数场景5：opcode-OP-INSERT-OP-UPDATE-OP-DELETE"><a href="#计数场景5：opcode-OP-INSERT-OP-UPDATE-OP-DELETE" class="headerlink" title="计数场景5：opcode == OP_INSERT / OP_UPDATE / OP_DELETE"></a>计数场景5：<code>opcode == OP_INSERT / OP_UPDATE / OP_DELETE</code></h3><p>按照场景1堆栈 <code>Strategy::writeOp()</code> –&gt; <code>runCommand()</code> –&gt; <code>execCommandClient()</code> –&gt; <code>Invocation::run()</code> 依次调用，同场景1</p>
<h3 id="对insert-update-delete-请求的计数说明"><a href="#对insert-update-delete-请求的计数说明" class="headerlink" title="对insert / update / delete 请求的计数说明"></a>对<code>insert / update / delete</code> 请求的计数说明</h3><p>对于insert / update / delete 请求，会在 <code>Invocation::run()</code> 中完成计数，但是对这3个请求的处理不是简单的+1完成的。增加的数量为 <code>batchedRequest.sizeWriteOps()</code>。由于3.6版本中新增了 OP_MSG 的协议类型，支持这3种请求携带多条数据：即 OP_MSG 协议中 <strong>kind=Document Sequence 的 sections 字段</strong>。这3种请求的具体实现，都重写了 Command 类提供的 parse 函数，基于原有的 request 构建了一个额外的 <code>BatchedCommandRequest</code> ，调用的是 <code>BatchedCommandRequest::parseInsert()</code> 函数。</p>
<p>实际执行验证来看：</p>
<p>通过insert插入一个BSONArray，opcounters.insert 会增加 array 的 size。和上面的分析是对齐的</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"insert"</span> : NumberLong(<span class="number">2</span>),</span><br><span class="line">	<span class="attr">"query"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"update"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"command"</span> : NumberLong(<span class="number">58</span>)</span><br><span class="line">&#125;</span><br><span class="line">mongos&gt; db.collection.insert([&#123;name: "B"&#125;,&#123;name: "C"&#125;])</span><br><span class="line">BulkWriteResult(&#123;</span><br><span class="line">	"writeErrors" : [ ],</span><br><span class="line">	"writeConcernErrors" : [ ],</span><br><span class="line">	"nInserted" : 2,</span><br><span class="line">	"nUpserted" : 0,</span><br><span class="line">	"nMatched" : 0,</span><br><span class="line">	"nModified" : 0,</span><br><span class="line">	"nRemoved" : 0,</span><br><span class="line">	"upserted" : [ ]</span><br><span class="line">&#125;)</span><br><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"insert"</span> : NumberLong(<span class="number">4</span>),</span><br><span class="line">	<span class="attr">"query"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"update"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"command"</span> : NumberLong(<span class="number">62</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而 <code>db.colleciton.update()</code> / <code>db.colleciton.delete()</code> 并不像 <code>insert()</code> 一样支持多条记录的修改。这几个函数都是被 mongo shell 封装过的，具体通过 insert / update / delete 进行多条document修改可以参考<a href="https://docs.mongodb.com/manual/reference/command/nav-crud/" target="_blank" rel="noopener">官网文档</a>中提供的命令，分别对应有 inserts / updates / deletes 字段支持多条document修改</p>
<p><strong>Notice:</strong> 按照上面的分析，对于opcode == OP_QUERY / OP_GET_MORE / OP_KILL_CURSORS 的场景，对metrics计数应该是有缺失的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/command/serverStatus/MongoDB-serverStatus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/command/serverStatus/MongoDB-serverStatus/" itemprop="url">MongoDB serverStatus实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-21T13:15:09+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/serverStatus/" itemprop="url" rel="index">
                    <span itemprop="name">serverStatus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> <code>CmdServerStatus</code> 的 run() 函数是 <code>serverStatus</code> 命令的具体实现</p>
<ul>
<li>首先将一些全局信息添加到result中</li>
<li>遍历<code>_sections</code>，调用<code>appendSection</code>，将所有注册的<code>Section</code>结果添加到result中</li>
<li>调用<code>MetricTree::theMetricTree-&gt;appendTo()</code>，将所有<code>Metric</code>指标添加到result中</li>
<li>其他一些信息的补充</li>
</ul>
<p>同时 <code>CmdServerStatus</code> 还维护了一个 <code>_sections</code> （map结构）存储section名称和具体 <code>ServerStatusSection</code> 的对应关系。提供 <code>addSection</code> 函数将制定section添加到 <code>_sections</code> 中</p>
<h2 id="Section指标"><a href="#Section指标" class="headerlink" title="Section指标"></a>Section指标</h2><p><code>ServerStatusSection</code> 是所有 <code>section</code> 指标的基类，构造方法调用 <code>CmdServerStatusInstantiator::getInstance()-&gt;addSection()</code> 将自身注册到 <code>CmdServerStatus</code> 中。并声明 virtual 函数 <code>includeByDefault</code> , <code>addRequiredPrivileges</code> , <code>generateSection</code> , <code>appendSection</code> 由子类定义实现，子类主要需要按需求定义<code>includeByDefault</code> , <code>generateSection</code> 的具体实现。</p>
<ul>
<li><code>includeByDefault</code> 用于说明是否默认被包含</li>
<li><code>generateSection</code>&amp;<code>appendSection</code>   一般实现其中一个即可，父类方法中<code>appendSection</code> 调用了 <code>generateSection</code> ，所以一般只需要实现 <code>generateSection</code> 即可。</li>
</ul>
<p><code>CmdServerStatusInstantiator</code> 是包装 <code>CmdServerStatus</code> 用于获取 <code>CmdServerStatus</code> 单例对象的一个struct，提供 <code>getInstance()</code> 完成单例对象获取。所以上面讲到的 <code>ServerStatusSection</code> 构造时调用 <code>CmdServerStatusInstantiator::getInstance()-&gt;addSection()</code> ，最终完成了自身到 <code>CmdServerStatus</code> 的 _sections 注册。</p>
<p>serverStatus命令运行时将遍历自身的 _sections ，依次根据 <code>includeByDefault</code> 配置，调用其 appendSection 完成 response BSON 的构建。</p>
<blockquote>
<p>其他 Command 都是在类声明的时候同时定义了一个对象，完成到 CommandMap 的注册。而 <code>CmdServerStatus</code> 由于需要 <code>CmdServerStatusInstantiator</code> 构建单例对象，所以是在 <code>CmdServerStatusInstantiator</code> 声明时定义了一个对象，完成 <code>CmdServerStatus</code> 到 CommandMap 的注册行为。</p>
</blockquote>
<h2 id="Metric指标"><a href="#Metric指标" class="headerlink" title="Metric指标"></a>Metric指标</h2><p><code>MetricTree</code>维护了一个树状结构(下文简称Tree) 用于存储所有的 metric指标 及其 path 对应关系，同时提供一个静态变量 <code>theMetricTree</code> 对外提供服务。同时提供 <code>add</code> 和 <code>appendTo</code> 函数分别用于将 Tree 添加到 <code>theMetricTree</code> 以及将 Tree 的数据以BSON的形式输出。</p>
<ul>
<li><p><code>add</code> 函数用于将 <code>ServerStatusMetric</code> 添加到 <code>Tree</code> : <code>Tree</code> 维护 <code>metrics path</code> 和 <code>ServerStatusMetric</code> 的对应关系，内部是由 2 个 map 构成的，如果当前 <code>metrics path</code> 是叶子节点（即 path 中不存在”.”），那么存储到``path –&gt; ServerStatusMetric<code>的 map 中，反之取出 path 的第一级路径，存储到 第一级路径 --&gt;</code>MetricTree` （不存在则新加一个） ，然后递归调用完成添加</p>
</li>
<li><ul>
<li>如果 path 是以 “.” 为开头，则添加到 Tree 的顶级路径，否则会在提供的 path 前添加 “metrics.” 前缀（即添加到metrics的子节点上）</li>
</ul>
</li>
<li><p><code>appendTo</code> 函数用于将 <code>Tree</code> 的数据以BSON的形式输出 ： 对于非叶子节点，会递归调用 <code>appendTo</code> 函数。对于叶子节点则会调用 <code>ServerStatusMetric</code> 的 <code>appendAtLeaf</code> 函数。最终根据所有 <code>ServerStatusMetric</code> 的 path 产生对应的的BSON</p>
</li>
</ul>
<p><code>ServerStatusMetric</code> 是所有 metric指标 的基类，主要提供构造方法调用 <code>MetricTree::theMetricTree-&gt;add(this)</code> 将自身注册到 <code>MetricTree</code> 中。并声明一个 <code>virtual appendAtLeaf</code> 函数由子类定义实现。该类有4个子类：</p>
<ul>
<li><p>模板类 <code>ServerStatusMetricField</code> 是一个被广泛应用的子类。增加一个T，用于实现大多数需求：都是 k-v 的结构， <code>appendAtLeaf</code>将 <strong>k &amp; v</strong> 直接append到bson中</p>
</li>
<li><ul>
<li>举例场景：所有command的一个成员变量，用于做类似命令与请求次数的绑定，便于serverStatus拿到结果</li>
</ul>
</li>
<li><p><code>MemBase (= .mem.bits )</code> ，获取MongoDB使用的内存信息</p>
</li>
<li><p><code>ClusterCursorStats (= cursor )</code>，cursor 信息</p>
</li>
<li><p><code>ReplExecutorSSM (= repl.executor )</code>，// TODO</p>
</li>
</ul>
<p>serverStatus命令运行时，将调用 <code>theMetricTree</code> 的 <code>appendTo</code> 函数，完成 response BSON 的构建</p>
<h2 id="Section指标-amp-Metric指标-实现对比"><a href="#Section指标-amp-Metric指标-实现对比" class="headerlink" title="Section指标 &amp; Metric指标 实现对比"></a>Section指标 &amp; Metric指标 实现对比</h2><p>ServerStatusMetric 和 ServerStatusSection 下文统称为Impl</p>
<table>
<thead>
<tr>
<th></th>
<th>Section指标</th>
<th>Metric指标</th>
</tr>
</thead>
<tbody><tr>
<td>都有一个单例的对象管理</td>
<td>CmdServerStatusInstantiator::getInstance()</td>
<td>MetricTree::theMetricTree</td>
</tr>
<tr>
<td>都是 name – Impl  的对应关系</td>
<td>CmdServerStatus  中_sections是一个map结构  name – ServerStatusSection</td>
<td>ServerStatusMetric中基于2个map结构实现了一个树状结构  叶子节点也都是  name – ServerStatusMetric</td>
</tr>
<tr>
<td>Impl都提供一个函数将结果  append 到 response 中</td>
<td>generateSection&amp;appendSection</td>
<td>appendTo</td>
</tr>
</tbody></table>
<p>区别应该有2点：</p>
<ol>
<li><code>ServerStatusSection</code>的append函数 <code>generateSection</code>&amp;<code>appendSection</code> 包含了 opCtx 和 configElement 。定义分别是<ul>
<li>`virtual BSONObj generateSection(OperationContext* opCtx, const BSONElement&amp;      configElement) const;``</li>
<li>``virtual void appendSection(OperationContext* opCtx, const BSONElement&amp;      configElement, BSONObjBuilder* result) const;`</li>
</ul>
</li>
<li><code>ServerStatusSection</code>提供了 <code>includeByDefault</code> 和 <code>addRequiredPrivileges</code> 对输出结构的控制力更强一些</li>
</ol>
<p>看起来是对于serverStatus默认添加且是计数行为的使用 <code>ServerStatusMetric</code> 比较方便简单一些。其他情况尤其对于 opCtx 有依赖或者需要控制对serverStatus输出的还是使用 <code>ServerStatusSection</code> 操控力更强一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangxin201492</p>
              <p class="site-description motion-element" itemprop="description">my blogs</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wangxin201492" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wangxin201492@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangxin201492</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
