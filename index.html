<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="wangxin201492">
<meta property="og:url" content="https://wangxin201492.github.io/index.html">
<meta property="og:site_name" content="wangxin201492">
<meta property="og:description" content="my blogs">
<meta property="article:author" content="wangxin201492">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangxin201492.github.io/"/>





  <title>wangxin201492</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b4b40ab284f92e7b4921a8198acda5b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wangxin201492</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/write/oplog/MongoDB-WRITE-oplog-insert/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/write/oplog/MongoDB-WRITE-oplog-insert/" itemprop="url">Oplog 是如何写入的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-04T10:09:10+08:00">
                2021-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/write/" itemprop="url" rel="index">
                    <span itemprop="name">write</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/write/oplog/" itemprop="url" rel="index">
                    <span itemprop="name">oplog</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="Oplog写入的相关组件"><a href="#Oplog写入的相关组件" class="headerlink" title="Oplog写入的相关组件"></a>Oplog写入的相关组件</h2><h3 id="OpObserver"><a href="#OpObserver" class="headerlink" title="OpObserver"></a>OpObserver</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The OpObserver interface contains methods that get called on certain database events. It provides</span></span><br><span class="line"><span class="comment"> * a way for various server subsystems to be notified of other events throughout the server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In order to call any OpObserver method, you must be in a 'WriteUnitOfWork' ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpObserver</span> &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>OpObserver</code> 包含了各种事件对应的 methods（ <code>onInserts</code> / <code>onUpdate</code> / <code>onDelete</code> 等等事件），这样便于其他子系统知晓这些event。调用任何的 <code>OpObserver</code> 方法都需要在 <code>WriteUnitOfWork</code> 中，也就意味着所有需要的lock都已经被 <code>WriteUnitOfWork</code> 持有。</p>
<p>mongod进程初始化的时候会 add 多个 <code>OpObserver</code> 的实现：<code>OpObserverShardingImpl</code> / <code>AuthOpObserver</code> ，对于shardServer会add <code>ShardServerOpObserver</code> ，对于 configServer 会 add <code>ConfigServerOpObserver</code>：</p>
<ul>
<li><code>AuthOpObserver</code> 只监听跟权限变更相关的oplog，具体实现在 <code>AuthzManagerExternalStateLocal::logOp()</code></li>
<li><code>ShardServerOpObserver</code>  &amp; <code>ConfigServerOpObserver</code> 都只会监听几个特定的oplog</li>
<li>主要的 oplog 写入行为在 <code>OpObserverShardingImpl</code>中完成，对于非事务的oplog，以 onInserts 为例，这里主要完成2件事情：<ul>
<li>通过 <code>_logOpWriter</code> 组装一条待写入 OplogDoc，通过 <code>_logOpsInner</code> 进行数据写入（此处又回调到<code>CollectionImpl::insertDocumentsForOplog</code>来完成实际的写入）</li>
<li>旁路写入 <code>shardObserveInsertOp</code> ，如果当前shard是moveChunk的源，这里会从oplog中提取信息记录在内存中，方便增量同步用</li>
</ul>
</li>
</ul>
<h3 id="RecoveryUnit"><a href="#RecoveryUnit" class="headerlink" title="RecoveryUnit"></a>RecoveryUnit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A RecoveryUnit is responsible for ensuring that data is persisted.</span></span><br><span class="line"><span class="comment"> * All on-disk information must be mutated through this interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecoveryUnit</span> &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>RecoveryUnit</code> 负责确保数据的持久化，所有磁盘操作都必须通过该接口完成。实际上 <code>RecoveryUnit</code> 可以理解为 server层 的事务入口，storage层负责与引擎对接时需要实现这个接口。<code>RecoveryUnit</code> 提供了基础的 begin、commit、abort等操作，提供了Rollback&amp;commit时的callback事件设置入口，同时也提供了时间戳设置的接口。</p>
<p>在 storageEngine init 的时候，会注册一个 <code>StorageClientObserver</code>，当opCtx初始化的时候，为opCtx设置当前使用引擎的 <code>RecoveryUnit</code>，以 wiredTiger为例，使用的就是 <code>WiredTigerRecoveryUnit</code>。</p>
<h3 id="WriteUnitOfWork"><a href="#WriteUnitOfWork" class="headerlink" title="WriteUnitOfWork"></a>WriteUnitOfWork</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The WriteUnitOfWork is an RAII type that begins a storage engine write unit of work on both the</span></span><br><span class="line"><span class="comment"> * Locker and the RecoveryUnit of the OperationContext. Any writes that occur during the lifetime of</span></span><br><span class="line"><span class="comment"> * this object will be committed when commit() is called, and rolled back (aborted) when the object</span></span><br><span class="line"><span class="comment"> * is destructed without a call to commit() or release().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteUnitOfWork</span> &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>WriteUnitOfWork</code> 是一个 RAII 风格类，操作 opCtx 的 <code>Locker</code> &amp; <code>RecoveryUnit</code> 上开始存储引擎的写入工作单元。</p>
<h2 id="insert时-Oplog写入流程"><a href="#insert时-Oplog写入流程" class="headerlink" title="insert时 Oplog写入流程"></a>insert时 Oplog写入流程</h2><p>insert 因为不涉及查询优化，这里的执行路径比较简单，先来看下insert时 oplog的插入流程。</p>
<p>在 <code>insertDocuments()</code> 时会开启一个 <code>WriteUnitOfWork</code>，并为请求分配optime，随后 <code>CollectionImpl::insertDocuments()</code> 来进行数据插入，其中会依次写数据、写索引，并将oplog传播给 <code>OpObserver</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/mongo/db/ops/write_ops_exec.cpp:295</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertDocuments</span><span class="params">( ... )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Intentionally not using writeConflictRetry. That is handled by the caller so it can react to</span></span><br><span class="line">    <span class="comment">// oversized batches.</span></span><br><span class="line">    <span class="function">WriteUnitOfWork <span class="title">wuow</span><span class="params">(opCtx)</span></span>;</span><br><span class="line">		...</span><br><span class="line">    <span class="comment">// 非事务的insert会分配时间戳</span></span><br><span class="line">    <span class="keyword">auto</span> oplogSlots = repl::getNextOpTimes(opCtx, batchSize);</span><br><span class="line">  	...</span><br><span class="line">    uassertStatusOK(</span><br><span class="line">        collection-&gt;insertDocuments(opCtx, <span class="built_in">begin</span>, <span class="built_in">end</span>, &amp;CurOp::<span class="built_in">get</span>(opCtx)-&gt;debug(), fromMigrate));</span><br><span class="line">    wuow.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/mongo/db/catalog/collection_impl.cpp:432</span></span><br><span class="line"><span class="function">Status <span class="title">CollectionImpl::insertDocuments</span><span class="params">( ... )</span> </span>&#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="keyword">const</span> SnapshotId sid = opCtx-&gt;recoveryUnit()-&gt;getSnapshotId();</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 写数据、写索引</span></span><br><span class="line">    status = _insertDocuments(opCtx, <span class="built_in">begin</span>, <span class="built_in">end</span>, opDebug);</span><br><span class="line">    <span class="keyword">if</span> (!status.isOK()) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    invariant(sid == opCtx-&gt;recoveryUnit()-&gt;getSnapshotId());</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// oplog 传播给 OpObserver</span></span><br><span class="line">    getGlobalServiceContext()-&gt;getOpObserver()-&gt;onInserts(</span><br><span class="line">        opCtx, ns(), uuid(), <span class="built_in">begin</span>, <span class="built_in">end</span>, fromMigrate);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 注册 onCommit 回调</span></span><br><span class="line">    opCtx-&gt;recoveryUnit()-&gt;onCommit(</span><br><span class="line">        [<span class="keyword">this</span>](boost::optional&lt;Timestamp&gt;) &#123; notifyCappedWaitersIfNeeded(); &#125;);</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注册的 <code>OpObserver</code> 会依次捕获该 oplog 写入事件进行处理，如上文提到，真正写 oplog 在 <code>OpObserverShardingImpl</code> 中完成，最终会构造一个 <code>DocWriter</code> 并调用 <code>CollectionImpl::insertDocumentsForOplog</code> 来进行实际写入。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/clusterTime/MongoDB-sharding-clusterTime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/clusterTime/MongoDB-sharding-clusterTime/" itemprop="url">MongoDB集群中的 clusterTime</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-27T15:56:10+08:00">
                2021-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/clusterTime/" itemprop="url" rel="index">
                    <span itemprop="name">clusterTime</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ClusterTime"><a href="#ClusterTime" class="headerlink" title="ClusterTime"></a>ClusterTime</h1><p>[TOC]</p>
<h3 id="clusterTime-demo"><a href="#clusterTime-demo" class="headerlink" title="clusterTime demo"></a>clusterTime demo</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$clusterTime"</span> : &#123;</span><br><span class="line">    "clusterTime" : Timestamp(1495470881, 5),</span><br><span class="line">    "signature" : &#123;</span><br><span class="line">      "hash" : BinData(0, "7olYjQCLtnfORsI9IAhdsftESR4="),</span><br><span class="line">      "keyId" : "6422998367101517844"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="核心组件关系"><a href="#核心组件关系" class="headerlink" title="核心组件关系"></a>核心组件关系</h3><pre class="mermaid">classDiagram
    ServiceContext .. LogicalTimeValidator
  LogicalTimeValidator --> KeysCollectionManager
  LogicalTimeValidator --> TimeProofService
  KeysCollectionManager --> KeysCollectionCache
  KeysCollectionManager --> KeyGenerator
  KeysCollectionCache --> KeysCollectionClient
  KeyGenerator --> KeysCollectionClient

    class LogicalTimeValidator{
        -SignedLogicalTime _lastSeenValidTime;
        +signLogicalTime()
        +trySignLogicalTime()
        +validate()
    }
  class KeysCollectionManager {
      周期运行: PeriodicRunner
  }
  class TimeProofService {
      +checkProof()
  }
  class KeysCollectionCache {
    // expiresAt -> keysDocument
    map<LogicalTime, KeysCollectionDocument>
  }
  class KeyGenerator {
    // for_configServer_primary_only
    +generateNewKeysIfNeeded()
  }
  class KeysCollectionClient {
    +getNewKeys()
    +insertNewKey()
  }


  ServiceContext .. LogicalClock

  class LogicalClock {
      -LogicalTime _clusterTime
      +reserveTicks()
      +advanceClusterTime()
      +getClusterTime()
  }


  class LogicalTimeMetadata {
      -SignedLogicalTime _clusterTime
      +readFromMetadata()
      +writeToMetadata()
  }</pre>



<h4 id="组件初始化"><a href="#组件初始化" class="headerlink" title="组件初始化"></a>组件初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for mongod(shardServer&amp;configServer), using KeysCollectionClientDirect</span></span><br><span class="line"><span class="keyword">auto</span> keysCollectionClient = stdx::make_unique&lt;KeysCollectionClientDirect&gt;();</span><br><span class="line"><span class="comment">// for mongos, using KeysCollectionClientSharded</span></span><br><span class="line"><span class="comment">// auto keysCollectionClient = stdx::make_unique&lt;KeysCollectionClientSharded&gt;(grid-&gt;catalogClient());</span></span><br><span class="line"><span class="keyword">auto</span> keyManager = <span class="built_in">std</span>::make_shared&lt;KeysCollectionManager&gt;(</span><br><span class="line">  KeysCollectionManager::kKeyManagerPurposeString, <span class="comment">// = "HMAC"</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">move</span>(keysCollectionClient),</span><br><span class="line">  Seconds(KeysRotationIntervalSec)); <span class="comment">// = 90days</span></span><br><span class="line">keyManager-&gt;startMonitoring(startupOpCtx-&gt;getServiceContext());</span><br><span class="line"></span><br><span class="line">LogicalTimeValidator::<span class="built_in">set</span>(startupOpCtx-&gt;getServiceContext(),</span><br><span class="line">                          stdx::make_unique&lt;LogicalTimeValidator&gt;(keyManager));</span><br></pre></td></tr></table></figure>



<h3 id="全局时钟维护-LogicalClock"><a href="#全局时钟维护-LogicalClock" class="headerlink" title="全局时钟维护 - LogicalClock"></a>全局时钟维护 - LogicalClock</h3><p>mongos、shardServer、configServer初始化时都会启动一个 <code>LogicalClock</code> ，用来维护该节点目前已知最新的 <code>LogicalTime</code>，并提供必要的接口，用于推动时钟（<code>advanceClusterTime()</code>）以及tick时钟（<code>reserveTicks()</code>）。</p>
<h3 id="KeysCollectionManager"><a href="#KeysCollectionManager" class="headerlink" title="KeysCollectionManager"></a>KeysCollectionManager</h3><blockquote>
<p>KeysCollection : <code>admin.system.keys</code></p>
</blockquote>
<p><code>KeysCollectionManager</code> 负责管理维护 KeysCollection。内部运行一个线程（<code>monitoring-keys-for-HMAC</code>），定期（<code>KeysRotationIntervalSec</code>，默认为90天）加载 keysCollection 中的相关文档，并维护到本地缓存（<code>KeysCollectionCache</code>）。</p>
<p>本地缓存（<code>KeysCollectionCache</code>）内维护了一个 <code>expiresAt</code> –&gt; <code>KeysDocument</code> 的map</p>
<p>configServer的primary节点在进行定期加载前会会生成 key信息，并插入到 KeysCollection</p>
<h3 id="ClusterTime-Signature-校验机制-–-LogicalTimeValidator-validate"><a href="#ClusterTime-Signature-校验机制-–-LogicalTimeValidator-validate" class="headerlink" title="ClusterTime Signature 校验机制 – LogicalTimeValidator::validate()"></a>ClusterTime Signature 校验机制 – <code>LogicalTimeValidator::validate()</code></h3><p>mongos&amp;shardServer 收到 上游请求后，如果传递的 <code>clusterTime</code> 有效（不为0）且 <code>isAuthorizedToAdvanceClock()</code> ，会对收到的 <code>clusterTime</code> 进行校验：</p>
<ol>
<li>如果入参的 <code>clusterTime</code> 小于 <code>LogicalTimeValidator::_lastSeenValidTime</code> ，则无需进行校验</li>
<li>匹配 <code>admin.system.keys</code> 中 <code>expireAt</code> &gt; <code>clusterTime</code> 并且 <code>keyId</code> 相等的文档，提取 <code>key</code> 字段</li>
<li><code>clusterTime</code> 与 <code>0x0000&#39;0000&#39;0000&#39;FFFF</code> 或运算，即保留 <code>clusterTime</code> 的高位信息（<code>timeCeil</code>）</li>
<li>基于 <code>key</code> &amp; <code>timeCeil</code> 计算 HMAC值，与传入的 <code>hash</code> 比较</li>
</ol>
<h3 id="ClusterTime的传播-–-LogicalTimeMetadata"><a href="#ClusterTime的传播-–-LogicalTimeMetadata" class="headerlink" title="ClusterTime的传播 – LogicalTimeMetadata"></a>ClusterTime的传播 – <code>LogicalTimeMetadata</code></h3><p><code>LogicalTimeMetadata</code>  负责 $clusterTime 的元信息维护。</p>
<p>分片集群实例节点之间发生请求交互时，<code>LogicalTimeMetadata</code>会将当前节点已知的 clusterTime 添加到请求元信息中。</p>
<p>mongos&amp;shardServer收到上游请求后，<code>validate()</code> 后 会进行 <code>advanceClusterTime</code>。另外内部请求交互会使用 <code>LogicalTimeMetadataHook</code> ，交互完成后 该hook 也会进行 <code>advanceClusterTime</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/MongoDB-sharding-troubleshoot-cacheRefreshX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/MongoDB-sharding-troubleshoot-cacheRefreshX/" itemprop="url">MongoDB 路由表刷新导致响应慢</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-30T14:29:52+08:00">
                2021-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MongoDB sharding 实例从 <strong>3.4版本</strong> 升级到 <strong>4.0版本</strong> 以后插入性能明显降低，观察日志发现大量的 <code>insert</code> 请求慢日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:46.563+0800 I COMMAND [conn1528] command sdb.sColl command: insert &#123; insert: &quot;sColl&quot;, xxx&#125; ... locks: &#123;Global: &#123; acquireCount: &#123; r: 6, w: 2 &#125; &#125;, Database: &#123; acquireCount: &#123; r: 2, w: 2 &#125; &#125;, Collection: &#123; acquireCount: &#123; r: 2, w: 2 &#125;, acquireWaitCount: &#123; r: 1 &#125;, timeAcquiringMicros: &#123; r: 2709634 &#125; &#125; &#125; protocol:op_msg 2756ms</span><br></pre></td></tr></table></figure>

<p>日志中可以看到 <code>insert</code> 请求执行获取 collection 上的 IS锁 2次，其中一次发生等待，等待时间为2.7s，这与 <code>insert</code> 请求执行时间保持一致。说明性能降低与<strong>锁等待</strong>有明显的相关性。</p>
<p>追溯日志发现 2.7s 前，系统正在进行 collection 元数据刷新（2.7s的时长与collection本身chunk较多相关）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:43.853+0800 I SH_REFR [ConfigServerCatalogCacheLoader-20] Refresh for collection sdb.sColl from version 25550573|83||5f59e113f7f9b49e704c227f to version 25550574|264||5f59e113f7f9b49e704c227f took 8676ms</span><br><span class="line">2020-08-19T16:40:43.853+0800 I SHARDING [conn1527] Updating collection metadata for collection sdb.sColl from collection version: 25550573|83||5f59e113f7f9b49e704c227f, shard version: 25550573|72||5f59e113f7f9b49e704c227f to collection version: 25550574|264||5f59e113f7f9b49e704c227f, shard version: 25550574|248||5f59e113f7f9b49e704c227f</span><br></pre></td></tr></table></figure>



<h2 id="chunk-版本信息"><a href="#chunk-版本信息" class="headerlink" title="chunk 版本信息"></a>chunk 版本信息</h2><p>首先，我们来理解下上文中的版本信息。在上文日志中看到，shard version 和 collection version 形式均为 「25550573|83||5f59e113f7f9b49e704c227f」，这即是一个 chunk version，通过 “|” 和 “||” 将版本信息分为三段：</p>
<ul>
<li>第一段为 <code>major version</code> : 整数，用于<strong>辨识路由指向是否发生变化，以便各节点及时更新路由</strong>。比如在发生chunk 在 shard 之间迁移时会增加</li>
<li>第二段为 <code>minor version</code> : 整数，主要用于记录<strong>不影响路由指向的一些变化</strong>。比如chunk 发生 split 时增加</li>
<li>第三段为 <code>epoch</code> : objectID，标识集合的唯一实例，用于<strong>辨识集合是否发生了变化</strong>。只有当 collection 被 drop 或者 collection的shardKey发生refined时 会重新生成</li>
</ul>
<p><strong>shard version</strong> 为 sharded collection 在目标shard上最高的 chunk version</p>
<p><strong>collection version</strong> 为 sharded collection 在所有shard上最高的 chunk version</p>
<blockquote>
<p>下文 “路由更新触发场景” - “场景一：请求触发” 中就描述了使用 shard version 来触发路由更新的典型应用场景。</p>
</blockquote>
<h2 id="路由信息存储"><a href="#路由信息存储" class="headerlink" title="路由信息存储"></a>路由信息存储</h2><p>sharded collection 的路由信息被记录在 configServer 的 <a href="https://docs.mongodb.com/manual/reference/config-database/#config.chunks" target="_blank" rel="noopener">config.chunks</a> 集合中，而 mongos&amp;shardServer 则按需从 configServer 中加载到本地缓存(CatalogCache)中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.chunks</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"sdb.sColl-name_106.0"</span>,</span><br><span class="line">        "lastmod" : Timestamp(4, 2),</span><br><span class="line">        "lastmodEpoch" : ObjectId("5f3ce659e6957ccdd6a56364"),</span><br><span class="line">        "ns" : "sdb.sColl",</span><br><span class="line">        "min" : &#123;</span><br><span class="line">                "name" : 106</span><br><span class="line">        &#125;,</span><br><span class="line">        "max" : &#123;</span><br><span class="line">                "name" : 107</span><br><span class="line">        &#125;,</span><br><span class="line">        "shard" : "mongod8320",</span><br><span class="line">        "history" : [</span><br><span class="line">                &#123;</span><br><span class="line">                        "validAfter" : Timestamp(1598001590, 84),</span><br><span class="line">                        "shard" : "mongod8320"</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中记录的 document 表示该 chunk ：</p>
<ul>
<li>所属的 namespace 为 “sdb.sColl”，其 epoch 为 “5f3ce659e6957ccdd6a56364”</li>
<li>chunk区间为 {“name”: 106} ~ {“name”: 107}，chunk版本为 {major=4, minor=2}，在 mongod8320 的shard上</li>
<li>同时记录了一些历史信息</li>
</ul>
<h2 id="路由更新触发场景"><a href="#路由更新触发场景" class="headerlink" title="路由更新触发场景"></a>路由更新触发场景</h2><p>路由更新采用 “lazy” 的机制，非必须的场景下不会进行路由更新。主要有2种场景会进行路由刷新：</p>
<h3 id="场景一：请求触发"><a href="#场景一：请求触发" class="headerlink" title="场景一：请求触发"></a>场景一：请求触发</h3><p>mongos 收到客户端请求后，根据当前 CatalogCache 缓存中的路由信息，为客户端请求增加一个 <strong>「shardVersion」</strong> 的元信息。然后按照路由信息将请求分发到目标shard上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  insert: "sCollName", </span><br><span class="line">  documents: [ &#123; _id: ObjectId('5f685824c800cd1689ca3be8'), name: xxxx &#125; ], </span><br><span class="line">  shardVersion: [ Timestamp(5, 1), ObjectId('5f3ce659e6957ccdd6a56364') ], </span><br><span class="line">  $db: "sdb"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shardServer 收到 mongos 发来的请求后，提取其中的 <strong>「shardVersion」</strong> 字段，并与本地存储的 <strong>「shardVersion」</strong>进行比较。比较二者 <code>epoch &amp; majorVersion</code> 是否相同，相同则认为可以进行写入。如果版本不匹配，则抛出一个 <code>StaleConfigInfo</code> 异常。对于该异常，shardServer&amp;mongos 均会进行处理，逻辑基本一致：如果本地路由信息是低版本的，则进行路由刷新。</p>
<h3 id="场景二：特殊请求"><a href="#场景二：特殊请求" class="headerlink" title="场景二：特殊请求"></a>场景二：特殊请求</h3><ul>
<li>一些命令执行一定会触发路由信息变化，比如 <code>moveChunk</code></li>
<li>受其他节点行为影响，收到 <code>forceRoutingTableRefresh</code> 命令，强制刷新</li>
<li>一些行为必须要获取最新的路由信息，比如 <code>cleanupOrphaned</code></li>
</ul>
<h2 id="路由刷新行为"><a href="#路由刷新行为" class="headerlink" title="路由刷新行为"></a>路由刷新行为</h2><p><img src="https://wangxin201492.github.io/techImages/MongoDB-cache-refresh.png" alt="MongoDB-cache-refresh"></p>
<p>具体的刷新行为分为两步：</p>
<p>第一步：从config节点拉取权威的路由信息，并进行CatalogCache路由信息刷新。实际最终是通过 <code>ConfigServerCatalogCacheLoader</code> 线程来进行的，构造一个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"ns"</span>: namespace,</span><br><span class="line">  "lastmod": &#123; $gte: sinceVersion&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求来获取路由信息。如果本地没有collection的路由信息，则会那么全量获取路由信息，<code>sinceVersion</code> = (0,0) ；否则只需增量获取路由信息， <code>sinceVersion</code> = 本地路由信息中最大的版本号，即 <strong>shard version</strong>。</p>
<p><code>ConfigServerCatalogCacheLoader</code> 获得到路由信息以后，会刷新 CatalogCache中的路由信息，此时系统日志会打印上文中看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:43.853+0800 I SH_REFR [ConfigServerCatalogCacheLoader-20] Refresh for collection sdb.sColl from version 25550573|83||5f59e113f7f9b49e704c227f to version 25550574|264||5f59e113f7f9b49e704c227f took 8676ms</span><br></pre></td></tr></table></figure>



<p>第二步：更新 <code>MetadataManager</code>(用于维护集合的元信息，并提供对部分场景获取一个一致性的路由信息等功能) 中的 路由信息。更新 <code>MetadataManager</code> 时为了保证一致性，会给 collection 增加一个 <strong>X锁</strong>。更新过程中，系统日志会打印上文看到的第二条日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-19T16:40:43.853+0800 I SHARDING [conn1527] Updating collection metadata for collection sdb.sColl from collection version: 25550573|83||5f59e113f7f9b49e704c227f, shard version: 25550573|72||5f59e113f7f9b49e704c227f to collection version: 25550574|264||5f59e113f7f9b49e704c227f, shard version: 25550574|248||5f59e113f7f9b49e704c227f</span><br></pre></td></tr></table></figure>

<p><strong>这里也即是文章开篇提到影响我们性能的日志，根因还是由于更新元信息的X锁导致。</strong></p>
<h2 id="3-6-版本对-chunk-version-管理的变化"><a href="#3-6-版本对-chunk-version-管理的变化" class="headerlink" title="3.6+版本对 chunk version 管理的变化"></a>3.6+版本对 chunk version 管理的变化</h2><p>那么，为什么 3.4版本 没有问题，而到了 4.0版本 却发生了性能退化呢？这里直接给出答案：<strong>3.6&amp;4.0的最新小版本当中，当shard进行 splitChunk 时，如果 shardVersion == collectionVersion ，则会增加 major version，进而触发路由刷新。</strong>而3.4版本中只会增加 minor version。这里首先来看下 splitChunk 的基本流程，随后我们再来详述为什么要做这样的改动</p>
<h3 id="splitChunk-流程"><a href="#splitChunk-流程" class="headerlink" title="splitChunk 流程"></a>splitChunk 流程</h3><p><img src="https://wangxin201492.github.io/techImages/MongoDB-splitChunk.png" alt="MongoDB-splitChunk"></p>
<ul>
<li><strong>「auto-spliting触发」</strong>：在 4.0及以前的版本中，sharding实例的 auto-spliting 是由 mongos 来触发的。每次有写入请求时，mongos都会记录对应chunk的写入量，并判断是否要向 shardServer 下发一次 <code>splitChunk</code> 请求。判断标准：<code>dataWrittenBytes &gt;= maxChunkSize / 5(固定值)</code>。</li>
<li><strong>「splitVector + splitChunk」</strong>：向 chunk所在的shard 下发一个 <code>splitVector</code> 请求，获取对该chunk进行拆分的拆分点。该过程会根据索引进行一定的数据扫描及计算，详见：<a href="https://developer.aliyun.com/article/119494" target="_blank" rel="noopener">SplitVector命令</a>。若 <code>splitVector</code> 获取到了具体的拆分点，则再次向 chunk所在的shard 下发一个 <code>splitChunk</code> 请求，进行实际的拆分。</li>
<li><strong>「_configsvrCommitChunkSplit」</strong>：shardServer 收到 <code>splitChunk</code> 请求后，首先获取一个分布式锁，然后向 configServer 下发一个 <code>_configsvrCommitChunkSplit</code>。configServer 收到该请求后进行数据更新，完成splitChunk，过程中会有 chunk 版本信息的变化。</li>
<li><strong>「route refresh」</strong>：上述流程正常完成后，mongos进行路由刷新。</li>
</ul>
<h3 id="splitChunk-时，chunk-version变化"><a href="#splitChunk-时，chunk-version变化" class="headerlink" title="splitChunk 时，chunk version变化"></a>splitChunk 时，chunk version变化</h3><p>在 <a href="https://jira.mongodb.org/browse/SERVER-41480" target="_blank" rel="noopener">SERVER-41480</a> 中，对splitChunk时，chunk version版本管理进行了调整</p>
<p>在3.4版本以及3.6、4.0较早的小版本中，<strong>「_configsvrCommitChunkSplit」</strong> 只会增加 chunk 的minor version。</p>
<blockquote>
<p>The original reasoning for this was to prevent unnecessary routing table refreshes on the routers, which don’t ordinarily need to know about chunk splits (since they don’t change targeting information).</p>
</blockquote>
<p>根本原因是为了保护 mongos 不做必须要的路由刷新，因为 splitChunk 并不会改变路由目标，所以 mongos 不需要感知。</p>
<p>但是只进行小版本的自增，如果用户进行单调递增的写入，容易造成较大的性能开销。</p>
<p><img src="https://wangxin201492.github.io/techImages/MongoDB-SERVER-41480.png" alt="MongoDB-SERVER-41480"></p>
<p>假设 sharding实例有2个mongos：mongosA、mongosB，2个shard：shardA(chunkRange: MinKey ~ 0)，shardB(chunkRange: 0 ~ Maxkey)。用户持续单调递增写入。</p>
<ul>
<li><strong>T1时刻</strong>：mongosB首先判断chunk满足<strong>「auto-spliting触发」</strong> 条件，向 shardB 发送<strong>「splitVector + splitChunk」</strong>，在请求正常结束后，mongosB触发路由刷新。此时，shardB 的 chunkRange 为 0 ~ 100，100 ~ Maxkey。</li>
<li>随后在一定时间内（比如<strong>T2时刻</strong>），mongosB无法满足<strong>「auto-spliting触发」</strong> 条件，而mongosA持续判断满足条件，向shardB发送 <strong>「splitVector + splitChunk」</strong>，但最终在<strong>「_configsvrCommitChunkSplit」</strong>步骤，由于 mongosA 的路由表不是最新的，所以无法按照其请求将 0 ~ Maxkey 进行拆分，最终无法成功执行。由于整个流程没有完整结束，所以 mongosA 也无法进行 路由表更新，则<strong>在这段时间内持续会有这样的无效请求</strong>。</li>
</ul>
<p>而如上文描述的，<code>splitVector</code> 根据索引进行一定的数据扫描、计算，<code>splitChunk</code> 会获取分布式锁，均为耗时较高的请求，所以这种场景对性能的影响不可忽视。</p>
<p>在 <strong>SERVER-41480</strong>中对上述问题进行修复，修复的方式是如果 shardVersion == collectionVersion (即 collection上次的 chunk split 也发生在该shard上) ，则会增加 major version，以触发各节点路由的刷新。修复的版本为<code>3.6.15</code>, <code>4.0.13</code>, <code>4.3.1</code>, <code>4.2.2</code>。</p>
<p>而这个修复则导致了开篇我们遇到的问题，确切些来说，<strong>任何在 shardVersion == collectionVersion 的 shard 上进行 split 操作都会导致全局路由的刷新。</strong></p>
<h2 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h2><p><a href="https://jira.mongodb.org/browse/SERVER-49233" target="_blank" rel="noopener">SERVER-49233</a> 中对这个问题进行了详细的阐述：</p>
<blockquote>
<p>we chose a solution, which erred on the side of correctness, with the reasoning that on most systems auto-splits are happening rarely and are not happening at the same time across all shards.</p>
</blockquote>
<p>我们选择的方案，宁可过于注重正确性（<strong>SERVER-41480</strong>），理由是在大多数的系统中，auto-split很少发生，而且不会同时在所有shard上发生。</p>
<blockquote>
<p>However, this logic seems to be causing more harm than good in the case of almost uniform writes across all chunks. If it is the case that all shards are doing splits almost in unison, under this fix there will constantly be a bump in the collection version, which means constant stalls due to StaleShardVersion.</p>
</blockquote>
<p>然而，在对所有chunk进行均衡写入的情况下，这个逻辑似乎弊大于利。如果这种场景下，所有的shard同时进行split，那么在 <strong>SERVER-41480</strong> 修复下，collection version 将不断出现颠簸，也就意味着不断由于 <code>StaleShardVersion</code> 而导致不断暂停。</p>
<p><img src="https://wangxin201492.github.io/techImages/MongoDB-SERVER-49233.png" alt="MongoDB-SERVER-49233"></p>
<p>举例来详细说明下这个问题：假设某sharding实例有4个shard，各持有2个chunk，当前时刻major version=N。客户端对sharding实例的所有chunk进行均衡的写入，某时刻mongosA判断所有chunk符合split条件，依次对各shard进行连续的 split chunk 触发。为了便于说明，假设如图所示，在T1，T2，T3，T4时刻，依次在ShardA、shardB、shardC、shardD进行连续的chunk split触发，那么：</p>
<ul>
<li>T1.1时刻 chunk1 发生 split，使得 shardA 的 shardVersion == collection；T1.2时刻 chunk2 发生 split，触发 configServer major version ++ ，此时最新的major version=N+1；随后的T1.3时刻，shardA感知后刷新本地major version=N+1</li>
<li>随后的T2、T3、T4时刻依次发生上述流程。</li>
<li>最终在T5时刻，mongosA 在触发完split chunk后主动刷新路由表，感知major version = N+4</li>
</ul>
<p>那么当系统中另外一个mongos（未发生更新，路由表中major version=N）向shard（比如shardB）发送请求时</p>
<ul>
<li>在第一次请求交互后，mongosX感知自身major version落后，与configServer交互，更新本地路由表后下发第二次请求</li>
<li>第二次请求中，shardB感知自身major version落后，通过configServer拉取并更新路由表</li>
<li>在第三次请求中，双方均获得最新的路由表，而完成此次请求</li>
<li>mongos&amp;shard之间感知路由表落后靠请求交互时的 <code>StaleShardVersion</code> 来完成，而路由表更新的过程中，所有需要依赖该集合路由表完成的请求，都需要<strong>等待路由表更新完成</strong>后才能继续。所以上述过程即jira中描述的：<strong>不断由于</strong> <strong><code>StaleShardVersion</code></strong> <strong>而导致不断暂停。</strong></li>
</ul>
<p>同时 <strong>SERVER-49233</strong> 提供了具体的解决方案，在 <code>3.6.19</code>、<code>4.0.20</code>、<code>4.2.9</code> 及后续的版本中，提供 <code>incrementChunkMajorVersionOnChunkSplit</code> 参数， 默认为 false（即 <code>splitChunk</code> 不会增加major version），可在配置文件或者通过启动setParameter的方式设置为true。</p>
<p>而由于 auto-spliting 逻辑在 4.2版本 修改为在 shardServer 上触发(<a href="https://jira.mongodb.org/browse/SERVER-34448" target="_blank" rel="noopener">SERVER-34448</a>)， 也就不会再有 mongos 频繁下发无效 splitChunk 的场景。 所以对于 4.4 版本， <a href="https://jira.mongodb.org/browse/SERVER-49433" target="_blank" rel="noopener">SERVER-49433</a> 直接将增加 major version 的逻辑回滚掉，只会增加 minor version。（4.2版本由于中间版本提供了 major version 逻辑，所以提供 <code>incrementChunkMajorVersionOnChunkSplit</code> 来让用户选择）</p>
<p>这里对各版本行为总结如下：</p>
<ul>
<li>只会增加 minor version：<code>3.4</code>所有版本、<code>3.6.15</code> 之前的版本、<code>4.0.13</code>之前的版本、<code>4.2.2</code>之前的版本、<code>4.4</code>（暂未发布）</li>
<li>shardVersion == collectionVersion 会增加 major version，否则增加minor version：<code>3.6.15</code>~ <code>3.6.18</code>（包含）之间的版本、<code>4.0.13</code> ~ <code>4.0.19</code>（包含）之间的版本、<code>4.2.2</code> ~ <code>4.2.8</code>（包含）之间的版本</li>
<li>提供 <code>incrementChunkMajorVersionOnChunkSplit</code> 参数，默认只增加 minor version：<code>3.6.19</code>及后续版本、<code>4.0.20</code>及后续版本、<code>4.2.9</code>及后续版本</li>
</ul>
<h2 id="使用场景与解决方案"><a href="#使用场景与解决方案" class="headerlink" title="使用场景与解决方案"></a>使用场景与解决方案</h2><table>
<thead>
<tr>
<th>MongoDB版本</th>
<th>使用场景</th>
<th>修复方案</th>
</tr>
</thead>
<tbody><tr>
<td>4.2以下</td>
<td>数据写入固定在某些Shard</td>
<td>采用可以增加major version的版本（或设置 <code>incrementChunkMajorVersionOnChunkSplit</code> = true）</td>
</tr>
<tr>
<td>4.2以下</td>
<td>数据在shard之间写入较均衡</td>
<td>采用仅增加minor version的版本（或设置 <code>incrementChunkMajorVersionOnChunkSplit</code> = false）</td>
</tr>
<tr>
<td>4.2</td>
<td>数据写入固定在某些Shard</td>
<td>由于4.2版本 splitChunk 在shardServer上触发，所以无需关心</td>
</tr>
<tr>
<td>4.2</td>
<td>数据在shard之间写入较均衡</td>
<td>采用仅增加minor version的版本（或设置 <code>incrementChunkMajorVersionOnChunkSplit</code> = false）</td>
</tr>
</tbody></table>
<p><a href="https://www.aliyun.com/product/mongodb" target="_blank" rel="noopener">阿里云MongoDB</a> 4.2版本中已经跟进了官方修复。遇到该问题的用户可以将实例升级到4.2的最新小版本，而后按需配置<code>incrementChunkMajorVersionOnChunkSplit</code>即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/LogicalSession/MongoDB-sharding-LogicalSession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/LogicalSession/MongoDB-sharding-LogicalSession/" itemprop="url">MongoDB LogicalSession机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-05T10:39:38+08:00">
                2021-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/LogicalSession/" itemprop="url" rel="index">
                    <span itemprop="name">LogicalSession</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<pre class="mermaid">classDiagram
    ServiceContext .. LogicalSessionCacheImpl
  LogicalSessionCacheImpl --> SessionsCollectionSharded
  LogicalSessionCacheImpl --> _reapSessionsOlderThanFn
  LogicalSessionCacheImpl --> LogicalSessionRecord
  LogicalSessionRecord .. sessionCollection
  _reapSessionsOlderThanFn -- MongoDSessionCatalog : shardServer&configServer
  _reapSessionsOlderThanFn -- RouterSessionCatalog : mongos
  MongoDSessionCatalog .. SessionCatalog
  RouterSessionCatalog .. SessionCatalog
  ServiceContext .. SessionCatalog
    SessionCatalog --> SessionRuntimeInfo
    SessionCatalog .. transactionCollection

  class LogicalSessionCacheImpl {
      // LogicalSessionId -> LogicalSessionRecord
      -LogicalSessionIdMap<LogicalSessionRecord> _activeSessions;
      -LogicalSessionIdSet _endingSessions;
      +vivify()
      -_refresh()
      -_reap()
  }
  class SessionCatalog {
      -LogicalSessionId -> SessionRuntimeInfo
  }
  class LogicalSessionRecord {
      +_id
      +lastUse
      +user
  }
  class sessionCollection {
      <<collection>>
  }
  class transactionCollection {
      <<collection>>
  }</pre>





<h2 id="LogicalSessionId"><a href="#LogicalSessionId" class="headerlink" title="LogicalSessionId"></a>LogicalSessionId</h2><h3 id="LogicalSession的标识-lsid"><a href="#LogicalSession的标识-lsid" class="headerlink" title="LogicalSession的标识 - lsid"></a>LogicalSession的标识 - lsid</h3><p>LogicalSession 由 “logical session id”(<code>lsid</code>) 标识。<code>lsid</code> 由两部分信息组成：</p>
<ul>
<li><code>id</code> - 全局唯一的id(UUID)，由 driver 或者 startSession命令 生成</li>
<li><code>uid</code>(user id) - 登录用户的唯一标识 // 如果 authentication 开启</li>
</ul>
<h3 id="logicalSession-信息-lsid-生成"><a href="#logicalSession-信息-lsid-生成" class="headerlink" title="logicalSession 信息(lsid) 生成"></a>logicalSession 信息(<code>lsid</code>) 生成</h3><p><code>lsid</code>可以在 driver 生成，也可以在 server 生成</p>
<ul>
<li>driver 生成 <code>lsid</code> ( src/mongo/shell/session.js 中的 <code>ServerSession</code> )：driver在链接Server前，通过 <code>Mongo.prototype.startSession</code> 获得一个 <code>ServerSession</code>， <code>ServerSession</code> 初始化时，进行 <code>this.handle = client._startSession();</code> （实际上调用 C++ <code>MongoBase::Functions::_startSession::call</code> ）中生成 <code>lsid</code>. <code>ServerSession</code>也 提供了 <code>injectSessionId</code> &amp; <code>assignTransactionNumber</code> 分别为 cmd append <code>lsid</code> &amp; <code>txnNumber</code> 字段。</li>
<li>server生成 <code>lsid</code>：则是提供了 <code>startSession</code> command 来支持（同时将 lsid 信息存储到 <code>logicalSessionCache</code> 中）。该命令返回一个UUID信息 <code>{ &quot;id&quot; : UUID(&quot;807bac7b-6a17-423e-9aaf-bb84682666bb&quot;) }</code></li>
</ul>
<h3 id="logicalSession-信息-lsid-处理"><a href="#logicalSession-信息-lsid-处理" class="headerlink" title="logicalSession 信息(lsid) 处理"></a>logicalSession 信息(<code>lsid</code>) 处理</h3><p>server 收到用户请求以后，在真正请求处理之前，会首先解析其中的<code>lsid</code> &amp; <code>txnNumber</code> 等信息并vivify（<code>initializeOperationSessionInfo</code>）。</p>
<p>vivify(<code>LogicalSessionCacheImpl::vivify()</code>) 是将lsid信息添加到 <code>logicalSessionCache</code> 并更新其缓存entry的 lastUse 时间，除了收到用户请求时会进行 vivify 外：</p>
<ul>
<li>cursor checkout - <code>CursorManager::pinCursor()</code> &amp; <code>ClusterCursorManager::checkOutCursor()</code></li>
<li><code>refreshSessions</code> command</li>
</ul>
<h3 id="存储lsid"><a href="#存储lsid" class="headerlink" title="存储lsid"></a>存储lsid</h3><p>每个节点（mongos、shard、config）都有一个 in-memory cache 缓存当前节点正在使用的 session 信息，称为 <code>logicalSessionCache</code> 。<code>logicalSessionCache</code> 中的每个 entry 包含：</p>
<ul>
<li><code>_id</code> - session 的 lsid</li>
<li><code>user</code> - session 的 登录用户名</li>
<li><code>lastUse</code> - session 上次使用的时间</li>
</ul>
<p><code>logicalSessionCache</code> 定期将 entry 信息持久化到 <code>config.system.sessions</code> 集合（被称为 <code>sessions collection</code>)中，这个集合的存储位置因MongoDB运行形态不同而改变：</p>
<table>
<thead>
<tr>
<th align="left">Cluster Type</th>
<th align="left">Sessions Collection 持久存储位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Standalone</code></td>
<td align="left"><code>logicalSessionCache</code> 所在的节点</td>
</tr>
<tr>
<td align="left"><code>ReplicaSet</code></td>
<td align="left">primary节点 并复制给 Seceondaries</td>
</tr>
<tr>
<td align="left"><code>ShardedCluster</code></td>
<td align="left">作为一个 sharded collection 存在 - 可以存在在各个shard上，且有多个chunk</td>
</tr>
</tbody></table>
<p> <code>config.system.sessions</code> 集合中，在 <code>lastUse</code> 字段上会创建一个 TTL 索引，索引过期时间默认为 30min。也就是说如果一个 session 超过 30min 没有被使用，那么 TTL索引 就会将这个 session 在 <code>config.system.sessions</code> 中清理掉。</p>
<h2 id="LogicalSessionCache-的-refresh机制-amp-reap机制"><a href="#LogicalSessionCache-的-refresh机制-amp-reap机制" class="headerlink" title="LogicalSessionCache 的 refresh机制 &amp; reap机制"></a>LogicalSessionCache 的 refresh机制 &amp; reap机制</h2><p><code>LogicalSessionCache</code> 中有 <code>_activeSessions</code> 和 <code>_endingSessions</code> 2个成员变量来存储 LogicalSession 信息。</p>
<ul>
<li><code>_activeSessions</code> 是一个 LogicalSessionId –&gt; LogicalSessionRecord 的 map结构<ul>
<li>上文提到 LogicalSessionCache 中的每个 cache entry 实际上就是 <code>LogicalSessionRecord</code>。该结构体中包含 <code>_id</code> / <code>lastUse</code> / <code>user</code> 几个field。而系统在对某个 lsid 进行 vivify 的行为，就是在 <code>_activeSessions</code> 检索对应的 <code>LogicalSessionRecord</code>，如果能检索到，则更新其 <code>lastUse</code> ，检索不到则构造一个 <code>LogicalSessionRecord</code> 添加到 <code>_activeSessions</code>。</li>
</ul>
</li>
<li><code>_endingSessions</code> 是存储 LogicalSessionId 的 一个set结构。主要用来标识通过 <code>endSessions</code> 命令显式关闭的session</li>
</ul>
<p><code>_activeSessions</code> &amp; <code>_endingSessions</code> 在接下来描述的 refresh机制 &amp; reap机制 中会与 <code>config.system.sessions</code> 集合交互，进行缓存信息的刷新。</p>
<p>refresh &amp; reap 机制都是定时执行的，受 <code>logicalSessionRefreshMillis</code> 配置影响，默认时间间隔为 5min。</p>
<h4 id="refresh-机制-–-LogicalSessionCacheImpl-refresh"><a href="#refresh-机制-–-LogicalSessionCacheImpl-refresh" class="headerlink" title="refresh 机制 – LogicalSessionCacheImpl::_refresh()"></a>refresh 机制 – <code>LogicalSessionCacheImpl::_refresh()</code></h4><h5 id="step1-初始状态处理"><a href="#step1-初始状态处理" class="headerlink" title="step1 - 初始状态处理"></a>step1 - 初始状态处理</h5><p>确认 <code>config.system.sessions</code> 状态正常</p>
<ol>
<li><code>ShardedCluster</code>的 <code>config.system.sessions</code> 以 sharded collection 的方式存在<ul>
<li>对于 mongos&amp;shardServer，这里只会检查 <code>config.system.sessions</code> 集合是否存在。分片集群环境下，该集合的创建由 configServer 负责</li>
<li>对于 configServer<ul>
<li>检查 <code>config.system.sessions</code> 不存在，则会给自己发送一个 <code>_configsvrShardCollection</code> 的命令进行 shardCollection (shardKey: { _id: 1})</li>
<li>向 <code>config.system.sessions</code> 相关的shard 发送 <code>createIndexes</code> 命令，{ “lastUse”: 1 } ，TTL 索引 ， 超时时间为 <strong>localLogicalSessionTimeoutMinutes</strong> 配置（默认30min）</li>
</ul>
</li>
</ul>
</li>
<li><code>ReplicaSet</code> - primary节点 并复制给 Seceondaries。验证index是否正确，如果不正确，primary节点直接进行修正（collMod or createIndexes），secondary节点则将请求发送给primary</li>
<li><code>Standalone</code> - <code>config.system.sessions</code> 存储在当前节点。行为同 ReplicaSet 的 primary节点</li>
</ol>
<h5 id="step2-session-管理"><a href="#step2-session-管理" class="headerlink" title="step2 - session 管理"></a>step2 - session 管理</h5><p><strong>step2.1</strong> - 获取<code>activeSessions</code> &amp; <code>explicitlyEndingSessions</code> // 当前活跃的session 和 显示关闭的session</p>
<ol>
<li>通过加锁+swap的方式 拿到 <code>_activeSessions</code> &amp; <code>_endingSessions</code> 中存储的信息，分别存储到 <code>activeSessions</code> &amp; <code>explicitlyEndingSessions</code></li>
<li>从 <code>activeSessions</code> 清理掉 <code>explicitlyEndingSessions</code> 中的 lsid</li>
<li>获取正在运行的client的lsid，如果这些lsid没在 <code>explicitlyEndingSessions</code> 中则并添加到 <code>activeSessions</code></li>
</ol>
<p><strong>step2.2</strong> - 将 <code>activeSessions</code> 中的 session 更新到 <code>config.system.sessions</code></p>
<blockquote>
<p>md step1: All sessions that have been used on this node since the last refresh will be upserted to the sessions collection. This means that sessions that already exist in the sessions collection will just have their <code>lastUse</code> fields updated.</p>
</blockquote>
<p>对 <code>config.system.sessions</code> 进行如下操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"update"</span>: <span class="string">"config.system.sessions"</span>,</span><br><span class="line">	<span class="attr">"ordered"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"allowImplicitCollectionCreation"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"writeConcern"</span>: <span class="string">"majority"</span>,</span><br><span class="line">	<span class="attr">"docSeq"</span>: [</span><br><span class="line">		&#123;"q": &#123;"_id": &lt;lsid&gt; &#125;, "u": &#123;&#123; $currentDate : &#123; lastUse : true &#125;, $setOnInsert : &#123; user : &lt;user&gt; &#125; &#125; &#125;, upsert: true&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>step2.3</strong> - 将 <code>explicitlyEndingSessions</code> 中的 session 从 <code>config.system.sessions</code> 中移除</p>
<blockquote>
<p>md step2: All sessions that have been ended in the cache on this node (via the endSessions command) will be removed from the sessions collection.</p>
</blockquote>
<p>对 <code>config.system.sessions</code> 进行如下操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"delete"</span>: <span class="string">"config.system.sessions"</span>,</span><br><span class="line">	<span class="attr">"ordered"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"writeConcern"</span>: <span class="string">"majority"</span>,</span><br><span class="line">	<span class="attr">"docSeq"</span>: [</span><br><span class="line">		&#123;"q": &#123;"_id": &lt;lsid&gt; &#125;, limit: 0&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="step3-cursor-管理"><a href="#step3-cursor-管理" class="headerlink" title="step3 - cursor 管理"></a>step3 - cursor 管理</h5><p><strong>step3.1</strong> - 获取 <code>openCursorSessions</code> // 处于打开状态的cursor对应的session</p>
<ol>
<li>从 <code>CursorManager</code> 中拿到所有未处于 killPending 状态的cursor 对应的session</li>
<li>排除在 <code>_activeSessions</code> 中的session，因为前面对 <code>_activeSessions</code> &amp; <code>activeSessions</code> 进行swap，所以在 <code>_activeSessions</code> 中的session是新进入的请求，没有refresh到 <code>config.system.sessions</code>，所以需要排除</li>
</ol>
<p><strong>step3.2</strong> - 从 <code>config.system.sessions</code> 获取 <code>openCursorSessions</code> 中已经被remove的session（ <code>removedSessions</code>）</p>
<blockquote>
<p>md step3: Sessions that have expired from the sessions collection will be removed from the logical session cache on this node.</p>
</blockquote>
<p>这里实际上就是将 sessions 以 1000 为单位拆分成多个 batch，依次去 <code>config.system.sessions</code> 查询，过滤出不存在的session</p>
<p><strong>step3.3</strong> - 关闭<code>removedSessions</code> 和 <code>explicitlyEndingSessions</code> 对应的 cursor</p>
<blockquote>
<p>md step4: All cursors registered on this node that match sessions that have been ended (md step 2) or were expired (md step 3) will be killed.</p>
</blockquote>
<h4 id="reap-机制-–-LogicalSessionCacheImpl-reap"><a href="#reap-机制-–-LogicalSessionCacheImpl-reap" class="headerlink" title="reap 机制 – LogicalSessionCacheImpl::_reap()"></a>reap 机制 – <code>LogicalSessionCacheImpl::_reap()</code></h4><p>mongos&amp;shardServer都会有一个 <code>SessionCatalog</code> 的组件来记录事务的一些运行状态</p>
<p>reap机制就是从 <code>SessionCatalog</code> 中提取可能已经 expired 的session（上次活跃时间距离现在超过 <code>gTransactionRecordMinimumLifetimeMinutes</code>（30min））的session。</p>
<p>再从 <code>config.system.sessions</code> 中获取上面session中确实已经被删除的session，将这些session在 <code>SessionCatalog</code> 中删除</p>
<p>此外，primary节点中还会有一个 <code>config.transactions</code> 集合存储与 <code>SessionCatalog</code> 对应的记录作为持久化。所以还会其中与上面提到的session中对齐的信息，（分批删除，单次最多10000条）</p>
<blockquote>
<p>config.transaction  / SessionCatalog / MongoDSessionCatalog 会参与并记录当前节点的一些在执行的一些事务状态</p>
</blockquote>
<h2 id="LogicalSession-与-其他组件-的关系"><a href="#LogicalSession-与-其他组件-的关系" class="headerlink" title="LogicalSession 与 其他组件 的关系"></a>LogicalSession 与 其他组件 的关系</h2><h3 id="LogicalSession-与-opCtx-Cursor-的关系"><a href="#LogicalSession-与-opCtx-Cursor-的关系" class="headerlink" title="LogicalSession 与 opCtx/Cursor 的关系"></a>LogicalSession 与 opCtx/Cursor 的关系</h3><p>首先简单说下 <code>cursor</code> 和 <code>opCtx</code> 的关系。<code>cursor</code> 可能会被理解为是依附在 <code>opCtx</code> 中。但实际上 <code>cursor</code> 是一直存在的，而 <code>opCtx</code> 只有用户真正请求的时候才会被创建。<code>cursor</code> 在被使用命令使用的时候从 <code>ClusterCursorManager</code> 中 checkOut 出来，这时会reattach到 <code>opCtx</code> 中，而命令执行完需要再checkIn回 <code>ClusterCursorManager</code> 中，此时deattachFrom opCtx。</p>
<p><code>opCtx</code> 中有 <code>setLogicalSessionId</code> 的入口，但是注释中说明可能只会设置一次：May only be called once for the lifetime of the operation. 这里主要会在请求初始化的时候，进行 <code>setLogicalSessionId</code> （即在 <code>initializeOperationSessionInfo</code>中进行）。其他场景有内部交互时新建 opCtx 也会set lsid。</p>
<p><code>cursor</code> 中只在创建是可以指定lsid，后续只能getLsid。也就是说 cursor 和 lsid 是强绑定的关系。而在对 <code>cursor</code> checkOut时，也会默认基于 cursor 中存储的 lsid 进行校验。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/mongo/s/query/cluster_cursor_manager.cpp:348</span></span><br><span class="line"><span class="comment">// Check if the user is coauthorized to access this cursor.</span></span><br><span class="line"><span class="keyword">auto</span> authCheckStatus = authChecker(entry-&gt;getAuthenticatedUsers());</span><br><span class="line"><span class="keyword">if</span> (!authCheckStatus.isOK()) &#123;</span><br><span class="line">  <span class="keyword">return</span> authCheckStatus.withContext(str::stream()</span><br><span class="line">                                     &lt;&lt; <span class="string">"cursor id "</span> &lt;&lt; cursorId</span><br><span class="line">                                     &lt;&lt; <span class="string">" was not created by the authenticated user"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下其中一个满足时才会允许checkOut：</p>
<ul>
<li>context session id must match cursor session id. // lsid 匹配</li>
<li>user must be magic special (__system, or background task, etc)  // 内部任务或账号</li>
</ul>
<p>Q：sessionA创建了cursor，而sessionB使用cursor的id进行getMore 的行为是怎样的？</p>
<p>sessionB 提供的 lsid 需要与cursor中存储的 lsid 匹配才能checkOut成功（即进行getMore）</p>
<p>Q：session空闲，cursor一定空闲么？</p>
<p>是的，cursor使用的时候会更新其上存储的lsid的lastUse，即创建当前cursor的session</p>
<p>Q：cursor空闲，session一定空闲么？</p>
<p>不是，session可能执行非cursor相关的命令</p>
<h3 id="LogicalSession-与-txnNumber-的关系"><a href="#LogicalSession-与-txnNumber-的关系" class="headerlink" title="LogicalSession 与 txnNumber 的关系"></a>LogicalSession 与 txnNumber 的关系</h3><p>使用 <a href="https://docs.mongodb.com/manual/core/transactions-in-applications/#mongo-shell-example" target="_blank" rel="noopener">官方文档</a> 中提供的命令执行事务。 // 这里不执行最后的 <code>session.endSession();</code></p>
<p>命令中显示进行了 <code>startSession()</code>，所以这里使用的lsid为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs8400:PRIMARY&gt; session = db.getMongo().startSession( &#123; <span class="attr">readPreference</span>: &#123; <span class="attr">mode</span>: <span class="string">"primary"</span> &#125; &#125; );</span><br><span class="line">session &#123; <span class="string">"id"</span> : UUID(<span class="string">"97d5f526-6e95-4394-b6cf-683480499cdd"</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>最终server端打印的请求执行结果日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-03-09T15:03:03.297+0800 I  TXN      [conn20] transaction parameters:&#123; lsid: &#123; id: UUID(&quot;97d5f526-6e95-4394-b6cf-683480499cdd&quot;), uid: BinData(0, C77E46E0CE3E66F5656583BC39832C6A39F0DD4BFCB780E25591864F05D3058E) &#125;, txnNumber: 0, autocommit: false ... terminationCause:committed timeActiveMicros:595 timeInactiveMicros:2572309 ...  wasPrepared:0, 2572ms</span><br></pre></td></tr></table></figure>

<p>可以看到 <strong>txnNumber = 0</strong> </p>
<p>重复执行 transaction 相关命令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start a transaction</span></span><br><span class="line">session.startTransaction( &#123; <span class="attr">readConcern</span>: &#123; <span class="attr">level</span>: <span class="string">"local"</span> &#125;, <span class="attr">writeConcern</span>: &#123; <span class="attr">w</span>: <span class="string">"majority"</span> &#125; &#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations inside the transaction</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   coll1.insertOne( &#123; <span class="attr">abc</span>: <span class="number">1</span> &#125; );</span><br><span class="line">   coll2.insertOne( &#123; <span class="attr">xyz</span>: <span class="number">999</span> &#125; );</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   <span class="comment">// Abort transaction on error</span></span><br><span class="line">   session.abortTransaction();</span><br><span class="line">   <span class="keyword">throw</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction using write concern set at transaction start</span></span><br><span class="line">session.commitTransaction();</span><br></pre></td></tr></table></figure>

<p>这里没有 <code>startSession</code>，所以在server看到的日志为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-03-09T15:04:15.058+0800 I  TXN      [conn20] transaction parameters:&#123; lsid: &#123; id: UUID(&quot;97d5f526-6e95-4394-b6cf-683480499cdd&quot;), uid: BinData(0, C77E46E0CE3E66F5656583BC39832C6A39F0DD4BFCB780E25591864F05D3058E) &#125;, txnNumber: 1, autocommit: false ... terminationCause:committed timeActiveMicros:482 timeInactiveMicros:924948 ... wasPrepared:0, 925ms</span><br></pre></td></tr></table></figure>

<p>可以看到 lsid与上文相同，<strong>txnNumber = 1</strong></p>
<h2 id="LogicalSession-相关指标"><a href="#LogicalSession-相关指标" class="headerlink" title="LogicalSession 相关指标"></a>LogicalSession 相关指标</h2><p>以mongos输出为例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.serverStatus().logicalSessionRecordCache</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"activeSessionsCount"</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="attr">"sessionsCollectionJobCount"</span> : <span class="number">4321</span>,</span><br><span class="line">	<span class="attr">"lastSessionsCollectionJobDurationMillis"</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="attr">"lastSessionsCollectionJobTimestamp"</span> : ISODate(<span class="string">"2021-03-11T11:46:11.029Z"</span>),</span><br><span class="line">	<span class="attr">"lastSessionsCollectionJobEntriesRefreshed"</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"lastSessionsCollectionJobEntriesEnded"</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"lastSessionsCollectionJobCursorsClosed"</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"transactionReaperJobCount"</span> : <span class="number">4321</span>,</span><br><span class="line">	<span class="attr">"lastTransactionReaperJobDurationMillis"</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="attr">"lastTransactionReaperJobTimestamp"</span> : ISODate(<span class="string">"2021-03-11T11:46:11.029Z"</span>),</span><br><span class="line">	<span class="attr">"lastTransactionReaperJobEntriesCleanedUp"</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"sessionCatalogSize"</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>activeSessionsCount : 上次刷新以来，缓存在内存中的本地活跃session数量</strong></li>
<li><strong>sessionsCollectionJobCount : session refresh执行次数</strong></li>
<li><strong>lastSessionsCollectionJobDurationMillis : 上次session refresh执行耗时</strong></li>
<li>lastSessionsCollectionJobTimestamp : 上次session refresh发生的时间点</li>
<li><strong>lastSessionsCollectionJobEntriesRefreshed : 上次session refresh期间，刷新的session数量</strong></li>
<li><strong>lastSessionsCollectionJobEntriesEnded : 上次session refresh期间，结束的session数量</strong></li>
<li><strong>lastSessionsCollectionJobCursorsClosed : 上次session refresh期间，关闭的cursor数量</strong></li>
<li><strong>transactionReaperJobCount : transaction reaper执行次数</strong></li>
<li><strong>lastTransactionReaperJobDurationMillis : 上次transaction reaper执行耗时</strong></li>
<li>lastTransactionReaperJobTimestamp : 上次transaction reaper发生的时间点</li>
<li><strong>lastTransactionReaperJobEntriesCleanedUp : 上次transaction reaper清理的entry数量</strong></li>
<li><strong>sessionCatalogSize : [4.2] 内存中缓存的session数量</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/StaleConfig/MongoDB-sharding-StaleConfig/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/StaleConfig/MongoDB-sharding-StaleConfig/" itemprop="url">MongoDB sharding 路由刷新策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-21T10:05:48+08:00">
                2020-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/StaleConfig/" itemprop="url" rel="index">
                    <span itemprop="name">StaleConfig</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-mongos节点-收到用户-insert-请求"><a href="#1-mongos节点-收到用户-insert-请求" class="headerlink" title="1. mongos节点 收到用户 insert 请求"></a>1. mongos节点 收到用户 insert 请求</h2><p>mongos 收到一个 insert 请求后，会经过如下流程处理将请求发送给 shard 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongos::handleRequest() --&gt; Strategy::clientCommand() --&gt; runCommand() --&gt; execCommandClient() --&gt; ClusterWriteCmd::InvocationBase::run() --&gt; ClusterWriteCmd::InvocationBase::runImpl() --&gt; ClusterWriter::write() --&gt; BatchWriteExec::executeBatch() --&gt; MultiStatementTransactionRequestsSender()</span><br></pre></td></tr></table></figure>

<p>在 <code>ClusterWriter::write()</code> 中会准备一个 <code>ChunkManagerTargeter</code> 来维保存目标 namespace 在 <code>CatalogCache</code> 中的路由信息，方便后续请求处理。</p>
<p>主要代码逻辑在 <code>BatchWriteExec::executeBatch()</code> 中，主要是封装 <code>BatchWriteOp</code> 的几个核心方法来完成具体的请求处理工作：</p>
<p>首先，根据请求的目标shard、order 等参数来将请求分成多个批次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status targetStatus = batchOp.targetBatch(targeter, recordTargetErrors, &amp;childBatches);</span><br></pre></td></tr></table></figure>

<p>然后逐批构造请求，并将请求通过 <code>MultiStatementTransactionRequestsSender</code> 依次发送到shard，并等待接收结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> request = [&amp;] &#123; <span class="keyword">const</span> <span class="keyword">auto</span> shardBatchRequest(batchOp.buildBatchRequest(*nextBatch));</span><br><span class="line">...</span><br><span class="line"><span class="function">MultiStatementTransactionRequestsSender <span class="title">ars</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  opCtx,</span></span></span><br><span class="line"><span class="function"><span class="params">  Grid::<span class="built_in">get</span>(opCtx)-&gt;getExecutorPool()-&gt;getArbitraryExecutor(),</span></span></span><br><span class="line"><span class="function"><span class="params">  clientRequest.getNS().db().toString(),</span></span></span><br><span class="line"><span class="function"><span class="params">  requests,</span></span></span><br><span class="line"><span class="function"><span class="params">  kPrimaryOnlyReadPreference,</span></span></span><br><span class="line"><span class="function"><span class="params">  isRetryableWrite ? Shard::RetryPolicy::kIdempotent : Shard::RetryPolicy::kNoRetry)</span></span>;</span><br></pre></td></tr></table></figure>



<p>在请求构造(<code>BatchWriteOp::buildBatchRequest()</code>)的的时候，设置请求的 <code>shardVersion</code>。这里实际是为请求设置了一个 <code>shardVersion</code> 字段，设置的值则为刚开始提到的 <code>CatalogCache</code> 中保存的 namespace 路由信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setShardVersion(targetedBatch.getEndpoint().shardVersion);</span><br></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  insert: "sCollName", </span><br><span class="line">  documents: [ &#123; _id: ObjectId('5f685824c800cd1689ca3be8'), name: xxxx &#125; ], </span><br><span class="line">  shardVersion: [ Timestamp(5, 1), ObjectId('5f3ce659e6957ccdd6a56364') ], </span><br><span class="line">  $db: "sdb"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-shard节点-收到-mongos节点-转发过来携带-shardVersion-的-insert-请求"><a href="#2-shard节点-收到-mongos节点-转发过来携带-shardVersion-的-insert-请求" class="headerlink" title="2. shard节点 收到 mongos节点 转发过来携带 shardVersion 的 insert 请求"></a>2. shard节点 收到 mongos节点 转发过来携带 <code>shardVersion</code> 的 insert 请求</h2><p>正常情况下， shard节点 按照如下流程处理 insert 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongod::handleRequest() --&gt; ServiceEntryPointCommon::handleRequest() --&gt; receivedCommands() --&gt; execCommandDatabase() --&gt; runCommandImpl() --&gt; WriteCommand::InvocationBase::run() --&gt; CmdInsert::Invocation::runImpl() --&gt; performInserts() --&gt; insertBatchAndHandleErrors() --&gt; acquireCollection()</span><br></pre></td></tr></table></figure>



<p>在 <code>execCommandDatabase()</code> 中，会提取请求中的 <code>shardVersion</code>和<code>databaseVersion</code> 字段信息，存储到 <code>OperationShardingState</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!opCtx-&gt;getClient()-&gt;isInDirectClient() &amp;&amp;</span><br><span class="line">            readConcernArgs.getLevel() != repl::ReadConcernLevel::kAvailableReadConcern &amp;&amp;</span><br><span class="line">            (iAmPrimary ||</span><br><span class="line">             (readConcernArgs.hasLevel() || readConcernArgs.getArgsAfterClusterTime()))) &#123;</span><br><span class="line">  oss.initializeClientRoutingVersions(invocation-&gt;ns(), request.body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>只有执行了<code>oss.initializeClientRoutingVersions()</code>，后续才会进行shardVersion比对。那么不进行shardVersion比对的场景是：</p>
<ol>
<li>reacConcern指定为available</li>
<li>从secondary读取且readConcern没有指定任何的参数</li>
</ol>
<h3 id="2-1-是否可以进行写入"><a href="#2-1-是否可以进行写入" class="headerlink" title="2.1 是否可以进行写入"></a>2.1 是否可以进行写入</h3><p>在 <code>acquireCollection()</code> 时，会判断请求是否可以进行写入( <code>assertCanWrite_inlock()</code> )。判断的标准则是比对 <strong>当前节点存储的shardVersion</strong> 和 <strong>收到mongos发送来的shardVersion</strong>，比较二者 <code>epoch &amp; majorVersion</code> 是否相同，相同则认为可以进行写入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can we write to this data and not have a problem?</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isWriteCompatibleWith</span><span class="params">(<span class="keyword">const</span> ChunkVersion&amp; other)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> epoch() == other.epoch() &amp;&amp; majorVersion() == other.majorVersion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则会抛出一个 <code>StaleConfigInfo</code> 异常。</p>
<h3 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2 异常处理"></a>2.2 异常处理</h3><p>该异常在 <code>insertBatchAndHandleErrors()</code> 中进行捕获，并 <code>handleError()</code>。对于异常为 <code>StaleConfigInfo</code> ，处理手段是将其设置到 <code>OperationShardingState</code> 中，并将其结果添加到向上游返回的输出中，且认为代码无须向下执行，继续直接返回给上游。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ex.extraInfo&lt;StaleConfigInfo&gt;()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!opCtx-&gt;getClient()-&gt;isInDirectClient()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; oss = OperationShardingState::<span class="built_in">get</span>(opCtx);</span><br><span class="line">            oss.setShardingOperationFailedStatus(ex.toStatus());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't try doing more ops since they will fail with the same error.</span></span><br><span class="line">        <span class="comment">// Command reply serializer will handle repeating this error if needed.</span></span><br><span class="line">        out-&gt;results.emplace_back(ex.toStatus());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>execCommandDatabase()</code> 进入析构流程时，析构 <code>ScopedOperationCompletionShardingActions</code> 会处理上面提及的 <code>StaleConfigInfo</code>。在 <code>onShardVersionMismatch</code> 接管异常处理工作，比对 本地shardVersion 是否大于 接收的版本。如果是则无需处理，否则进行 <code>forceShardFilteringMetadataRefresh</code> 强制刷新。</p>
<p>而无论是否进行了刷新，都会将 <code>StaleConfigInfo</code> 返回给上游 mongos</p>
<h2 id="3-mongos-处理-StaleConfigInfo"><a href="#3-mongos-处理-StaleConfigInfo" class="headerlink" title="3. mongos 处理 StaleConfigInfo"></a>3. mongos 处理 <code>StaleConfigInfo</code></h2><p>续 <strong>阶段1</strong> ， <code>MultiStatementTransactionRequestsSender()</code> 收到结果以后，通过 <code>BatchWriteOp::noteBatchResponse()</code> 处理 response</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch was ok, note response</span></span><br><span class="line">batchOp.noteBatchResponse(*batch, batchedCommandResponse, &amp;trackedErrors);</span><br></pre></td></tr></table></figure>



<p><code>BatchWriteOp::noteBatchResponse()</code> 的入参中有一个 <code>BatchedCommandResponse</code> 对象记录所有节点返回的结果。而 <code>BatchWriteOp</code> 中的 <code>_writeOps</code> 则记录了向各个节点下发的请求，根据response结果一一标记对应的request。最终在 <code>WriteOp::_updateOpState()</code> 中对 当前writeOp 进行标记。如果 <code>writeError == StaleShardVersion</code> 或者 <code>writeError == CannotImplicitlyCreateCollection</code>，则当前 writeOp 的状态仍然保留为 <code>WriteOpState_Ready</code>，而如果遇到其他异常则被标记位 <code>WriteOpState_Error</code>，请求正常完成则被标记为 <code>WriteOpState_Completed</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finish the response (with error, if needed)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == writeError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ordered || !lastError) &#123;</span><br><span class="line">        writeOp.noteWriteComplete(*<span class="built_in">write</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We didn't actually apply this write - cancel so we can retarget</span></span><br><span class="line">        dassert(writeOp.getNumTargeted() == <span class="number">1u</span>);</span><br><span class="line">        writeOp.cancelWrites(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    writeOp.noteWriteError(*<span class="built_in">write</span>, *writeError);</span><br><span class="line">    lastError = writeError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随后仍然会将 <code>StaleConfigInfo</code> 异常信息添加到 targeter 中，并在接下来的逻辑中进行刷新（如果本地版本更老）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!staleErrors.empty()) &#123;</span><br><span class="line">  noteStaleResponses(staleErrors, &amp;targeter);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Status refreshStatus = targeter.refreshIfNeeded(opCtx, &amp;targeterChanged);</span><br></pre></td></tr></table></figure>



<p>刷新的方式是首先标记版本过期，需要刷新。然后重新 <code>init</code> 时会获取路由信息而出发刷新。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status ChunkManagerTargeter::_refreshNow(OperationContext* opCtx) &#123;</span><br><span class="line">    Grid::<span class="built_in">get</span>(opCtx)-&gt;catalogCache()-&gt;onStaleShardVersion(<span class="built_in">std</span>::<span class="built_in">move</span>(*_routingInfo));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> init(opCtx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/splitChunk/MongoDB-sharding-splitChunk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/splitChunk/MongoDB-sharding-splitChunk/" itemprop="url">MongoDB Sharding splitChunk实现流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-02T16:43:32+08:00">
                2020-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/splitChunk/" itemprop="url" rel="index">
                    <span itemprop="name">splitChunk</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="autoSplit"><a href="#autoSplit" class="headerlink" title="autoSplit"></a>autoSplit</h3><blockquote>
<p>shard&amp;config 节点，会有 PeriodicBalancerConfigRefresher 定时任务每隔 30s 进行 balancer&amp;split 配置刷新</p>
<p>mongos 节点，会有 Uptime-reporter 线程每隔 10s 进行 balancer&amp;split 配置刷新</p>
</blockquote>
<ol>
<li>每当有插入或者更新操作时，会触发 <code>ShardServerOpObserver</code> 的 <code>onInserts</code> / <code>onUpdate</code></li>
<li>这2个方法都会调用 <code>incrementChunkOnInsertOrUpdate</code> 来判断是否需要进行 split chunk：chunk size 超出配置值，且开启 autoSplit</li>
<li>如果需要进行 split chunk， 则 <code>ChunkSplitter</code> 会接管后续的 split 流程</li>
<li>通过 <code>splitVector</code> 来获取具体的 <code>splitPoint</code>，然后调用 <code>splitChunk</code> 进行实际的 split chunk 操作</li>
</ol>
<h4 id="4-2-之前版本，autoSplit由mongos触发"><a href="#4-2-之前版本，autoSplit由mongos触发" class="headerlink" title="4.2 之前版本，autoSplit由mongos触发"></a>4.2 之前版本，autoSplit由mongos触发</h4><p>mongos 中 <code>updateChunkWriteStatsAndSplitIfNeeded</code> 记录每个 chunk 写入的大小，如果总更新量超过 maxChunkSizeBytes / 5 ，则会向 chunk 所在的 shard 发送一个 <code>splitVector</code> 请求来询问是否需要进行 split 。如果需要，则向 该shard 再发送一个 <code>splitChunk</code> 请求 进行实际的 split</p>
<h3 id="split-Command"><a href="#split-Command" class="headerlink" title="split Command"></a>split Command</h3><ol>
<li>mongos 收到 <code>split</code> 请求。判断合法性后计算 <code>splitPoint</code>，然后构造一个 <code>splitChunk</code> 请求，发送给 shard 节点</li>
<li>shard节点 收到 <code>splitChunk</code> 请求。解析相关参数，然后 调用 <code>splitChunk</code> 进行实际的 split chunk 操作</li>
</ol>
<h2 id="splitChunk"><a href="#splitChunk" class="headerlink" title="splitChunk"></a>splitChunk</h2><ol>
<li>shard 节点首先从 config 节点获取一个 <strong>why = splitting chunk chunkRange in namespace</strong> 的分布式锁</li>
<li>然后发送一个 <code>_configsvrCommitChunkSplit</code> 请求给 config 节点</li>
<li>config 节点判断 config.chunks 中的内容与 请求参数 之间的合法性。</li>
<li>然后构造一个 <code>applyOps</code> 请求进行 config.chunks 集合的更新，然后进行 config.changelog 集合</li>
<li>上述流程结束后，会判断此次 split 的边界是否有 topChunk ，如果存在的话，则将该新的chunkRange返回上游。<ol>
<li>如果是split command 的请求，不会对 topChunk 做任何处理</li>
<li>如果是 autoSplit ，会进行 topChunk 的处理，但是不是依赖这里返回的 topChunk，而是 ChunkSplitter 自行计算的结果</li>
</ol>
</li>
<li>析构，释放分布式锁。</li>
</ol>
<h2 id="topChunk-Optimization"><a href="#topChunk-Optimization" class="headerlink" title="topChunk Optimization"></a>topChunk Optimization</h2><p>包含 MinKey 或者 MaxKey 的 chunk 被称作 <code>topChunk</code>。如果 topChunk 被 split，那么可能用户有更大的概率对 shardKey 进行单调递增或单调递减的插入。这种情况下 <code>ChunkSplitter</code> 会主动向 configServer 请求尝试 moveChunk</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/shardCollection/MongoDB-sharding-shardCollection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/shardCollection/MongoDB-sharding-shardCollection/" itemprop="url">MongoDB sharding shardCollection实现流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-13T15:46:07+08:00">
                2020-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/shardCollection/" itemprop="url" rel="index">
                    <span itemprop="name">shardCollection</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="mongos-ShardCollectionCmd-run"><a href="#mongos-ShardCollectionCmd-run" class="headerlink" title="mongos : ShardCollectionCmd::run()"></a>mongos : <code>ShardCollectionCmd::run()</code></h2><p>mongos 收到 <code>shardCollection</code> 后，将请求解析并封装成一个 <code>_configsvrShardCollection</code>(ConfigsvrShardCollectionRequest) 请求，发送给 config节点</p>
<h2 id="config-ConfigSvrShardCollectionCommand-run"><a href="#config-ConfigSvrShardCollectionCommand-run" class="headerlink" title="config : ConfigSvrShardCollectionCommand::run()"></a>config : <code>ConfigSvrShardCollectionCommand::run()</code></h2><ol>
<li>解析 <code>_configsvrShardCollection</code> 请求</li>
<li>给 namespace &amp; database 均增加 “shardCollection” 的分布式锁</li>
<li>确认 database 已经是 sharded 的</li>
<li>如果 database == “config” ，确认 namespace == “config.system.sessions” 且其 count() == 0</li>
<li>构造一个 <code>_shardsvrShardCollection</code>(ShardsvrShardCollection) 请求，发送给 database 的 <strong>primaryShard</strong></li>
</ol>
<h2 id="shard-ShardsvrShardCollectionCommand-run"><a href="#shard-ShardsvrShardCollectionCommand-run" class="headerlink" title="shard : ShardsvrShardCollectionCommand::run()"></a>shard : <code>ShardsvrShardCollectionCommand::run()</code></h2><p>解析 <code>_shardsvrShardCollection</code> 请求</p>
<p>将请求注册到 <code>ActiveShardCollectionRegistry</code> 中，</p>
<ol>
<li><strong>如果没有同 namespace 的 shardCollection 运行，则注册成功，继续进行 shard 操作</strong></li>
<li>如果有同 namespace 的请求，请求相同，则通过 promise/future 方式等待请求完成直接获取结果。请求不同则报错（<em>ConflictingOperationInProgress</em>）</li>
</ol>
<p>主要的shard逻辑在 <code>shardCollection</code> 完成。</p>
<h3 id="确认-config-collections-中，对-namespace-的-shard-操作是否与当前-请求相同"><a href="#确认-config-collections-中，对-namespace-的-shard-操作是否与当前-请求相同" class="headerlink" title="确认 config.collections 中，对 namespace 的 shard 操作是否与当前 请求相同"></a>确认 <code>config.collections</code> 中，对 namespace 的 shard 操作是否与当前 请求相同</h3><ol>
<li>不同则报错 ：<em>AlreadyInitialized</em></li>
<li>相同则返回 <code>config.collections</code> 中的结果，进而直接将对应的 collection 返回给上游</li>
<li><strong>不存在，则继续进行 shard 操作</strong></li>
</ol>
<h3 id="确认-collection-的一些状态-：-calculateTargetState"><a href="#确认-collection-的一些状态-：-calculateTargetState" class="headerlink" title="确认 collection 的一些状态 ： calculateTargetState"></a>确认 collection 的一些状态 ： <code>calculateTargetState</code></h3><ol>
<li><code>config.chunks</code> 中有 namespace 的一些记录，报错：<em>ManualInterventionRequired</em>。需要手动请求可能因为之前 shard 操作导致有参与的chunk记录</li>
<li>判断 namespace 索引状况：<code>createCollectionOrValidateExisting</code><ol>
<li>所有的 unique index 必须以 shardKey 为 prefix。否则：<em>InvalidOptions</em></li>
<li>非空 collection 必须有一个有效 index</li>
<li>如果 shardKey 指定的是 unique的，必须有一个完全相同的 unique index</li>
<li>没有有效的 index， 且 collection 不为空则fail：<em>InvalidOptions</em></li>
<li>空 collection 则创建 需要的 index</li>
</ol>
</li>
<li><strong>isEmpty</strong> : collection 是否为 空</li>
<li><strong>tags</strong> : <code>config.tags</code> 中是否有 namespace 相关的 tag</li>
<li><strong>uuid</strong> : 是否有有效的 uuid 或者生成一个新的</li>
<li><strong>fromMapReduce</strong> : 是否来自于 mapReduce 请求</li>
<li><strong>splitPoint</strong> : 基于 tag / shardKey类型 / 是否指定 initialSplitPoints(mapReduce) / numInitialChunks 等参数确定<ol>
<li>mapReduce 场景下，指定了 initialSplitPoints ： splitPoint = initialSplitPoints</li>
<li>tag 为空 &amp;&amp; shardKey 为 hashed &amp;&amp; collection 为空，则将 chunk 按照 numInitialChunks 均分（未指定则默认为 shard * 2）</li>
</ol>
</li>
<li><strong>numContiguousChunksPerShard</strong> ： 每个 shard 持续的 chunk段</li>
</ol>
<p>在计算<code>calculateTargetState</code> 前，shardCollection会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From this point onward the collection can only be read, not written to, so it is safe to</span></span><br><span class="line"><span class="comment">// construct the prerequisites and generate the target state.</span></span><br><span class="line"><span class="function">CollectionCriticalSection <span class="title">critSec</span><span class="params">(opCtx, nss)</span></span></span><br></pre></td></tr></table></figure>

<p>通过一个 <code>CollectionCriticalSection</code> ，来将 collection 设置为只读，而在计算完<code>calculateTargetState</code> 后，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From this point onward, the collection can not be written to or read from.</span></span><br><span class="line">critSec.enterCommitPhase();</span><br></pre></td></tr></table></figure>

<p>继续将其设置为不可读写（直到shardCollection完成）。</p>
<p><code>CollectionCriticalSection</code> 是</p>
<h3 id="确定-ShardingOptimizationType-并进行具体的-chunk-分配"><a href="#确定-ShardingOptimizationType-并进行具体的-chunk-分配" class="headerlink" title="确定 ShardingOptimizationType 并进行具体的 chunk 分配"></a>确定 <code>ShardingOptimizationType</code> 并进行具体的 chunk 分配</h3><ol>
<li><strong>SplitPointsProvided</strong> : 提供了 splitPoint<ol>
<li>按照 splitPoint 将 chunk 分配到 shard 上(<code>generateShardCollectionInitialChunks</code>)</li>
</ol>
</li>
<li><strong>TagsProvidedWithEmptyCollection</strong> : tags 不为空 且 collection 不为空<ol>
<li>按照 tags 将 chunk 分配到 shard 上(<code>generateShardCollectionInitialZonedChunks</code>)</li>
</ol>
</li>
<li><strong>TagsProvidedWithNonEmptyCollection</strong> : tags 不为空 collection 为空<ol>
<li>将 <strong>$minKey ~ $maxKey</strong> 均分配到 primaryShard 上</li>
</ol>
</li>
<li><strong>EmptyCollection</strong> : collection 为空<ol>
<li>将 <strong>$minKey ~ $maxKey</strong> 均分配到 primaryShard 上</li>
</ol>
</li>
<li><strong>None</strong> : tags 为空 &amp;&amp; splitPoint 为空 &amp;&amp; collection 不为空<ol>
<li>将 maxChunkSizeBytes / maxChunkObjects / keyPattern 构造一个 <code>splitVector</code> 请求 发送给 primaryShard，获得一个 splitPoint 。然后根据结果将 chunk 拆分，但是都分配到 primaryShard</li>
</ol>
</li>
</ol>
<p>随后如果<code>ShardingOptimizationType != None &amp;&amp; !fromMapReduce</code> ，发送给其他相关shard发送一个  <code>_cloneCollectionOptionsFromPrimaryShard</code> 来触发其从primaryShard获取该 Collection的相关信息。具体实现则使用 <code>moveChunk</code> 时用到的 <code>MigrationDestinationManager::cloneCollectionIndexesAndOptions()</code> 来完成。</p>
<h3 id="更新config元信息及其他shard路由信息"><a href="#更新config元信息及其他shard路由信息" class="headerlink" title="更新config元信息及其他shard路由信息"></a>更新config元信息及其他shard路由信息</h3><p>上一步中会获得一个 <code>ShardCollectionConfig</code> 实际上是 <code>std::vector&lt;ChunkType&gt; chunks</code>。随后在 <code>writeChunkDocumentsAndRefreshShards</code> 中处理<code>ShardCollectionConfig</code>：</p>
<ol>
<li><strong>writeFirstChunksToConfig</strong>：写入 <code>config.chunks</code> 集合</li>
<li><strong>updateShardingCatalogEntryForCollection</strong>：更新 <code>config.collections</code> 集合</li>
<li><strong>refreshAllShards</strong>：强制刷新本地路由，基于最新的路由信息 构造一个 <code>_flushRoutingTableCacheUpdates</code> 请求，通知所有相关 shard</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/MongoDB-ServiceContext-Client-OperationContext/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/MongoDB-ServiceContext-Client-OperationContext/" itemprop="url">MongoDB中 ServiceContext/Client/OperationContext的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-03T11:03:12+08:00">
                2020-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ServiceContext"><a href="#ServiceContext" class="headerlink" title="ServiceContext"></a>ServiceContext</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class representing the context of a service, such as a MongoD database service or</span></span><br><span class="line"><span class="comment"> * a MongoS routing service.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A ServiceContext is the root of a hierarchy of contexts.  A ServiceContext owns</span></span><br><span class="line"><span class="comment"> * zero or more Clients, which in turn each own OperationContexts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceContext</span> <span class="title">final</span> :</span> <span class="keyword">public</span> Decorable&lt;ServiceContext&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一个mongod or mongos 进程中只有一个全局唯一的 <code>ServiceContext</code>：<code>ServiceContext</code> 代表一个service的上下文环境，一个 <code>ServiceContext</code> 是上下文层次中的根。一个 <code>ServiceContext</code> 拥有0个或多个 <code>Client</code>， 一个 <code>Client</code> 拥有各自的 <code>OperationContext</code></p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The database's concept of an outside "client".</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="title">final</span> :</span> <span class="keyword">public</span> Decorable&lt;<span class="built_in">Client</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一个外部链接对应一个 <code>Client</code></p>
<h2 id="OperationContext"><a href="#OperationContext" class="headerlink" title="OperationContext"></a>OperationContext</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class encompasses the state required by an operation and lives from the time a network</span></span><br><span class="line"><span class="comment"> * operation is dispatched until its execution is finished. Note that each "getmore" on a cursor</span></span><br><span class="line"><span class="comment"> * is a separate operation. On construction, an OperationContext associates itself with the</span></span><br><span class="line"><span class="comment"> * current client, and only on destruction it deassociates itself. At any time a client can be</span></span><br><span class="line"><span class="comment"> * associated with at most one OperationContext. Each OperationContext has a RecoveryUnit</span></span><br><span class="line"><span class="comment"> * associated with it, though the lifetime is not necesarily the same, see releaseRecoveryUnit</span></span><br><span class="line"><span class="comment"> * and setRecoveryUnit. The operation context also keeps track of some transaction state</span></span><br><span class="line"><span class="comment"> * (RecoveryUnitState) to reduce complexity and duplication in the storage-engine specific</span></span><br><span class="line"><span class="comment"> * RecoveryUnit and to allow better invariant checking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationContext</span> :</span> <span class="keyword">public</span> Interruptible, <span class="keyword">public</span> Decorable&lt;OperationContext&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该类包含了一个 operation 所需的所有状态，生命周期 从 网络分派 开始，到 执行完成 为止。<code>cursor</code> 上的每一个 <code>getmore</code> 都是一个独立的 operation。在 构造函数 中，一个 <code>OperationContext</code> 会被关联到当前的 <code>Client</code> 中，直到被销毁时才会取消关联。任何时间，每个 <code>Client</code> 最多只会被关联到一个 <code>OperationContext</code> 上。每个 <code>OperationContext</code> 也会持有 <code>RecoveryUnit</code>/<code>RecoveryUnitState</code> 等对象</p>
<h2 id="源码梳理"><a href="#源码梳理" class="headerlink" title="源码梳理"></a>源码梳理</h2><p>从源码上看，mongos 和 mongod 启动的时候都会通过 <code>setGlobalServiceContext(ServiceContext::make());</code> 来初始化一个 <code>ServiceContext</code>，这里最终将初始化好的 <code>ServiceContext</code> 放到 <code>globalServiceContext</code> 这个全局变量里，并提供一个 <code>getGlobalServiceContext()</code> 函数方便对象获取。</p>
<p>每有一个客户端连接到 mongod/mongos 时，会同时创建一个 <code>ServiceStateMachine</code> 用于管理该客户端连接生命周期中的状态，在 <code>ServiceStateMachine</code> 构造函数中，会调用 <code>ServiceContext-&gt;makeClient()</code> 来创建一个 <code>Client</code>对象，<code>makeClient()</code> 同时也会将创建好的 <code>Client</code> 对象添加到 <code>ServiceContext</code> 维护的 <code>stdx::unordered_set&lt;Client*&gt; _clients</code> 中。</p>
<p>在 <code>ServiceStateMachine</code> 对 <code>Client</code> 请求进行状态管理时，<code>Process</code> 为请求处理的状态，对该状态的处理在 <code>ServiceStateMachine::_processMessage()</code> 完成。这个方法中通过 <code>Client::getCurrent()-&gt;makeOperationContext();</code> 来构建一个 <code>OperationContext</code>，并在方法结束前将 <code>OperationContext</code> reset掉。</p>
<p>上面过程会涉及到2个自增的ID，这里简单说下：</p>
<ul>
<li>每有客户端连接时，会创建 <code>Session</code> 对象，基于这个 <code>Session</code> 对象创建上面提及的 <code>ServiceStateMachine</code>。<code>Session</code> 创建的时候则会通过 <code>AtomicWord&lt;unsigned long long&gt; sessionIdCounter</code> 来拿到一个唯一自增ID。mongod/mongos 会创建唯一的线程来处理 <code>Client</code> 的请求，该线程名称 <code>conn123</code> 中的 123 即是 上面获取到的sessionId</li>
<li><code>ServiceContext::makeOperationContext()</code> 创建 <code>OperationContext</code> 时会传入一个id用于唯一标识该 <code>OperationContext</code>，这个ID的获取是通过 <code>ServiceContext</code> 维护的 <code>AtomicWord&lt;unsigned&gt; _nextOpId</code> 拿到的。这个 ID 即为 <code>killOp</code>/<code>currentOp</code> 等命令中展示的 <code>opid</code></li>
</ul>
<p>同时 <code>ServiceContext</code> 提供了一个 <code>ClientObserver</code> 类用于 <code>Client</code> / <code>OperationContext</code> 构造和析构时的hook。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer interface implemented to hook client and operation context creation and</span></span><br><span class="line"><span class="comment"> * destruction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientObserver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCreateClient</span><span class="params">(<span class="built_in">Client</span>* client)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDestroyClient</span><span class="params">(<span class="built_in">Client</span>* client)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCreateOperationContext</span><span class="params">(OperationContext* opCtx)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDestroyOperationContext</span><span class="params">(OperationContext* opCtx)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ClientObserver</code> 的子类实现上述 virtual 函数，并通过 <code>ServiceContext::registerClientObserver()</code> 将自身注册到 <code>ServiceContext</code> 的 <code>std::vector&lt;ClientObserverHolder&gt; _clientObservers;</code> 中。那么在上文描述到的创建 <code>Client</code> 的函数 <code>ServiceContext::makeClient()</code> 和创建 <code>OperationContext</code> 函数 <code>ServiceContext::makeOperationContext()</code> 中则会依次遍历 <code>_clientObservers</code> 来调用对应的hook函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/ImplicitlyCreateCollection/MongoDB-sharding-ImplicitlyCreateCollection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/ImplicitlyCreateCollection/MongoDB-sharding-ImplicitlyCreateCollection/" itemprop="url">MongoDB sharding 隐式创建collection</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-31T13:21:15+08:00">
                2020-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/ImplicitlyCreateCollection/" itemprop="url" rel="index">
                    <span itemprop="name">ImplicitlyCreateCollection</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-mongos节点-收到用户-insert-请求"><a href="#1-mongos节点-收到用户-insert-请求" class="headerlink" title="1. mongos节点 收到用户 insert 请求"></a>1. mongos节点 收到用户 insert 请求</h2><p>mongos 收到一个 insert 请求后，会经过如下流程处理将请求发送给 shard 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongos::handleRequest() --&gt; Strategy::clientCommand() --&gt; runCommand() --&gt; execCommandClient() --&gt; ClusterWriteCmd::InvocationBase::run() --&gt; ClusterWriteCmd::InvocationBase::runImpl() --&gt; ClusterWriter::write() --&gt; BatchWriteExec::executeBatch() --&gt; MultiStatementTransactionRequestsSender()</span><br></pre></td></tr></table></figure>

<p>在发送给 shard 节点的请求中，会通过 <code>allowImplicitCollectionCreation</code> 字段来控制是否允许 shard 节点隐式创建collection。sharding状态下，该字段基本为 false，即不允许 shard 节点隐式创建collection</p>
<ul>
<li>对于 <code>insert</code> / <code>update</code> / <code>delete</code> 这三类请求，会在 <code>ClusterWriteCmd::InvocationBase::runImpl()</code> 中进行 <code>batchedRequest.setAllowImplicitCreate(false);</code> </li>
<li><code>src/mongo/s/cluster_commands_helpers.cpp</code> 中也提供了 <code>scatterGatherVersionedTargetByRoutingTable</code> / <code>scatterGatherUnversionedTargetAllShards</code> / <code>scatterGatherOnlyVersionIfUnsharded</code> / <code>executeCommandAgainstDatabasePrimary</code> 函数。如果请求包中不显式声明 <code>allowImplicitCollectionCreation</code> ，则默认为 <code>false</code> <ul>
<li>但是 <strong>renameCollection</strong> 及 <strong>covertToCapped</strong> 会将 <code>appendAllowImplicitCreate</code> 声明为 <code>true</code>(可以隐式创建collection)</li>
</ul>
</li>
</ul>
<blockquote>
<p>shard节点可以直接创建collection，即为<strong>隐式创建collection</strong>(rs实例均采用这种方式)。否则需要和 config 交互来完成 collection 的创建，即为<strong>显式创建collection</strong></p>
</blockquote>
<h2 id="2-shard节点-收到-mongos节点-转发过来携带-allowImplicitCollectionCreation-false的-insert-请求"><a href="#2-shard节点-收到-mongos节点-转发过来携带-allowImplicitCollectionCreation-false的-insert-请求" class="headerlink" title="2. shard节点 收到 mongos节点 转发过来携带 allowImplicitCollectionCreation=false的 insert 请求"></a>2. shard节点 收到 mongos节点 转发过来携带 <code>allowImplicitCollectionCreation=false</code>的 insert 请求</h2><p>正常情况下， shard节点 按照如下流程处理 insert 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceEntryPointMongod::handleRequest() --&gt; ServiceEntryPointCommon::handleRequest() --&gt; receivedCommands() --&gt; execCommandDatabase() --&gt; runCommandImpl() --&gt; WriteCommand::InvocationBase::run() --&gt; CmdInsert::Invocation::runImpl() --&gt; performInserts() --&gt; insertBatchAndHandleErrors() --&gt; acquireCollection() --&gt; makeCollection() --&gt; DatabaseImpl::userCreateNS() --&gt; createCollection()</span><br></pre></td></tr></table></figure>



<p>而由于 <code>allowImplicitCollectionCreation=false</code> ，在 <code>execCommandDatabase()</code> 时会将 <code>allowImplicitCollectionCreation</code> 设置到 <code>OperationShardingState</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oss.setAllowImplicitCollectionCreation(allowImplicitCollectionCreationField);</span><br></pre></td></tr></table></figure>



<p><code>createCollection()</code> 中则获取该值，判断为false，进行uassert，产生异常，向上抛出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uassert(CannotImplicitlyCreateCollectionInfo(nss), <span class="string">"request doesn't allow collection to be created implicitly"</span>, OperationShardingState::<span class="built_in">get</span>(opCtx).allowImplicitCollectionCreation());</span><br></pre></td></tr></table></figure>



<p>异常在 <code>insertBatchAndHandleErrors</code> 中被 catch 住，在 <code>handleError()</code> 中判断异常为 <code>CannotImplicitlyCreateCollectionInfo</code> ，将异常信息设置到 <code>OperationShardingState</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ex.extraInfo&lt;CannotImplicitlyCreateCollectionInfo&gt;()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; oss = OperationShardingState::<span class="built_in">get</span>(opCtx);</span><br><span class="line">  oss.setShardingOperationFailedStatus(ex.toStatus());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此原有处理流程结束， 退回到 <code>execCommandDatabase()</code> 中触发析构逻辑，在 <code>ScopedOperationCompletionShardingActions</code> 进行析构的时候处理之前设置到 <code>OperationShardingState</code> 中的异常状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> scoped = behaviors.scopedOperationCompletionShardingActions(opCtx);</span><br></pre></td></tr></table></figure>



<p><code>ScopedOperationCompletionShardingActions</code> 的析构函数中，会通过 <code>onCannotImplicitlyCreateCollection</code> 函数向 config节点 下发一个 <code>_configsvrCreateCollection</code> 请求。发生异常则日志记录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScopedOperationCompletionShardingActions::~ScopedOperationCompletionShardingActions() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> cannotImplicitCreateCollInfo = status-&gt;extraInfo&lt;CannotImplicitlyCreateCollectionInfo&gt;()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ShardingState::<span class="built_in">get</span>(_opCtx)-&gt;enabled()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> handleCannotImplicitCreateStatus = onCannotImplicitlyCreateCollection(_opCtx, cannotImplicitCreateCollInfo-&gt;getNss());</span><br><span class="line">            <span class="keyword">if</span> (!handleCannotImplicitCreateStatus.isOK())</span><br><span class="line">                <span class="built_in">log</span>() &lt;&lt; <span class="string">"Failed to handle CannotImplicitlyCreateCollection exception"</span> &lt;&lt; causedBy(redact(handleCannotImplicitCreateStatus));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-config节点-处理-configsvrCreateCollection-请求"><a href="#3-config节点-处理-configsvrCreateCollection-请求" class="headerlink" title="3. config节点 处理 _configsvrCreateCollection 请求"></a>3. config节点 处理 <code>_configsvrCreateCollection</code> 请求</h2><p>config节点 收到 <code>_configsvrCreateCollection</code> 请求后，在 <code>ConfigSvrCreateCollectionCommand::typedRun()</code> 中进行处理</p>
<ol>
<li>首先通过和 <code>config.locks</code> 交互获取 <code>collection</code> 对应 namespace 和 database 的分布式锁</li>
<li>然后通过 <code>ShardingCatalogManager::createCollection()</code> 和 primaryShard 交互，完成collection创建</li>
</ol>
<h2 id="4-shard节点-处理-configsvrCreateCollection-结果"><a href="#4-shard节点-处理-configsvrCreateCollection-结果" class="headerlink" title="4. shard节点 处理 _configsvrCreateCollection 结果"></a>4. shard节点 处理 <code>_configsvrCreateCollection</code> 结果</h2><p>如 <strong>阶段2</strong> 中提到 <code>ScopedOperationCompletionShardingActions</code> 代码中，如 <code>_configsvrCreateCollection</code> 结果未按预期完成，则打印”Failed to handle CannotImplicitlyCreateCollection exception”日志记录。随后继续进行 <code>insert</code> 请求处理，此时因发生了 <code>CannotImplicitlyCreateCollectionInfo</code> 异常，所以最终 shard节点 向 mongos节点 返回一个 “request doesn’t allow collection to be created implicitly” 错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  n: 0,</span><br><span class="line">  writeErrors: [ &#123; </span><br><span class="line">    index: 0,</span><br><span class="line">    code: 227,</span><br><span class="line">    ns: "xxx.xxx",</span><br><span class="line">    errmsg: "request doesn't allow collection to be created implicitly" </span><br><span class="line">    &#125; ],</span><br><span class="line">  opTime: &#123; ts: Timestamp(1596026022, 1), t: 87 &#125;,</span><br><span class="line">  electionId: ObjectId('7fffffff0000000000000057'),</span><br><span class="line">  ok: 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-mongos节点-处理第一次-insert-结果"><a href="#5-mongos节点-处理第一次-insert-结果" class="headerlink" title="5. mongos节点 处理第一次 insert 结果"></a>5. mongos节点 处理第一次 <code>insert</code> 结果</h2><p>如 <strong>阶段1</strong> 中描述，mongos节点 <code>BatchWriteExec::executeBatch()</code> 中构造 <code>MultiStatementTransactionRequestsSender()</code> 向下游分发，并等待返回结果。</p>
<p>收到结果后，通过 <code>BatchWriteOp::noteBatchResponse()</code> 处理 response</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch was ok, note response</span></span><br><span class="line">batchOp.noteBatchResponse(*batch, batchedCommandResponse, &amp;trackedErrors);</span><br></pre></td></tr></table></figure>



<p><code>BatchWriteOp::noteBatchResponse()</code> 的入参中有一个 <code>BatchedCommandResponse</code> 对象记录所有节点返回的结果。而 <code>BatchWriteOp</code> 中的 <code>_writeOps</code> 则记录了向各个节点下发的请求，根据response结果一一标记对应的request。最终在 <code>WriteOp::_updateOpState()</code> 中对 当前writeOp 进行标记。如果 <code>writeError == StaleShardVersion</code> 或者 <code>writeError == CannotImplicitlyCreateCollection</code>，则当前 writeOp 的状态仍然保留为 <code>WriteOpState_Ready</code>，而如果遇到其他异常则被标记位 <code>WriteOpState_Error</code>，请求正常完成则被标记为 <code>WriteOpState_Completed</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finish the response (with error, if needed)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == writeError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ordered || !lastError) &#123;</span><br><span class="line">        writeOp.noteWriteComplete(*<span class="built_in">write</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We didn't actually apply this write - cancel so we can retarget</span></span><br><span class="line">        dassert(writeOp.getNumTargeted() == <span class="number">1u</span>);</span><br><span class="line">        writeOp.cancelWrites(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    writeOp.noteWriteError(*<span class="built_in">write</span>, *writeError);</span><br><span class="line">    lastError = writeError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随后在 <code>BatchWriteExec::executeBatch()</code> 中判断 <code>batchOp.isFinished()</code> (有 <code>WriteOpState_Error</code> 则为 true，有<code>WriteOpState_Ready</code> 则为false)，此时由于 <strong>阶段4</strong> 中返回的是 <code>CannotImplicitlyCreateCollection</code>，所以 <code>batchOp.isFinished()</code> 的结果为 false。则继续构建 insert 请求下发给 shard节点进行重试。</p>
<h2 id="6-shard节点-处理第二次-insert-请求-amp-mongos节点-处理第二次-insert-结果"><a href="#6-shard节点-处理第二次-insert-请求-amp-mongos节点-处理第二次-insert-结果" class="headerlink" title="6. shard节点 处理第二次 insert 请求 &amp; mongos节点 处理第二次 insert 结果"></a>6. shard节点 处理第二次 <code>insert</code> 请求 &amp; mongos节点 处理第二次 <code>insert</code> 结果</h2><p>由于 <strong>阶段3</strong> 中 config节点 已经触发 shard节点 完成collection的创建了，所以此时按照 <strong>阶段2</strong> 中的正常流程 <code>insertBatchAndHandleErrors</code> 继续处理完成，最终返回用户一个处理完成的 insert 请求结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  n: 1,</span><br><span class="line">  opTime: &#123; ts: Timestamp(1596026028, 6), t: 87 &#125;,</span><br><span class="line">  electionId: ObjectId('7fffffff0000000000000057'),</span><br><span class="line">  ok: 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mongos节点 收到结果后按照 <strong>阶段5</strong> 中描述的由于没有error，则将结果组装后正常返回给上游用户</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/lock/OCC/OCC-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/lock/OCC/OCC-overview/" itemprop="url">关于乐观锁的探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T16:41:56+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/lock/" itemprop="url" rel="index">
                    <span itemprop="name">lock</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/lock/OCC/" itemprop="url" rel="index">
                    <span itemprop="name">OCC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>乐观并发控制</strong>（又名“<strong>乐观锁</strong>”，Optimistic Concurrency Control，缩写“OCC”）</p>
</blockquote>
<h2 id="为什么要使用锁"><a href="#为什么要使用锁" class="headerlink" title="为什么要使用锁"></a>为什么要使用锁</h2><p>在多线程编程领域，基本上所有的编程模型都采用了“<strong>并发访问串行处理</strong>”的策略，而方法就是给临界资源加一把锁</p>
<h2 id="并发控制策略-：乐观锁、悲观锁"><a href="#并发控制策略-：乐观锁、悲观锁" class="headerlink" title="并发控制策略 ：乐观锁、悲观锁"></a>并发控制策略 ：乐观锁、悲观锁</h2><p>锁的一种宏观分类方式是<strong>悲观锁</strong>和<strong>乐观锁</strong>。悲观锁与乐观锁<strong>并不是特指某个锁</strong>，而是在并发情况下的两种不同策略。</p>
<ul>
<li>悲观锁(Pessimistic Lock) : 就是很悲观，每次去拿数据的时候都认为别人会修改。所以<strong>每次在拿数据的时候都会上锁</strong>。这样别人想拿数据就被挡住，直到悲观锁被释放。</li>
<li>乐观锁(Optimistic Lock) : 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，<strong>更新前检查在读取至更新这段时间别人有没有修改过这个数据</strong>。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）。</li>
</ul>
<p>缺点：悲观锁阻塞事务，乐观锁回滚重试。</p>
<h3 id="悲观锁的代价"><a href="#悲观锁的代价" class="headerlink" title="悲观锁的代价"></a>悲观锁的代价</h3><p>日常用到的加锁基本都是悲观锁。悲观锁是用来做并发最简单的方式，其代价也是最高的：</p>
<ul>
<li>加锁、释放锁会需要操作系统进行上下文切换和调度延时，在上下文切换的时候，cpu之前缓存的指令和数据都将失效，这个过程将增加系统开销。</li>
<li>多个线程同时竞争锁，锁竞争机制本身需要消耗系统资源。没有获取到锁的线程会被挂起直至获取锁，在线程被挂起和恢复执行的过程中也存在很大开销。</li>
<li>等待锁的线程会阻塞，影响实际的使用体验。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(Priority Inversion)。</li>
</ul>
<h3 id="乐观锁、悲观锁的选择"><a href="#乐观锁、悲观锁的选择" class="headerlink" title="乐观锁、悲观锁的选择"></a>乐观锁、悲观锁的选择</h3><p>适用场景考虑几个因素：</p>
<ol>
<li>响应速度：需要响应速度快使用乐观锁</li>
<li>冲突频率：<ol>
<li>对于资源竞争较少（多读场景、线程冲突较轻）的情况选择<strong>乐观锁</strong> ：使用悲观锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而乐观锁操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（多写场景，线程冲突严重）的场景选择<strong>悲观锁</strong> ：乐观锁自旋的概率会比较大，从而浪费更多的CPU资源，效率低于悲观锁。</li>
</ol>
</li>
<li>重试代价：代价高则用悲观锁</li>
</ol>
<h2 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h2><p>乐观锁允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为<strong>无锁编程</strong>。</p>
<p>换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！（下文描述的版本号机制也是基于 MySQL 中提供了一个原子操作，这个原子操作最终也可能是一个CAS或者悲观锁）</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</p>
<p><strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<p><strong>CAS利用CPU指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。</strong></p>
<h4 id="CAS-带来的问题"><a href="#CAS-带来的问题" class="headerlink" title="CAS 带来的问题"></a>CAS 带来的问题</h4><ol>
<li><code>ABA</code>问题：比如说一个线程<code>T1</code>从内存位置<code>V</code>中取出<code>A</code>，这时候另一个线程<code>T2</code>也从内存中取出<code>A</code>，并且<code>T2</code>进行了一些操作变成了<code>B</code>，然后<code>T2</code>又将<code>V</code>位置的数据变成<code>A</code>，这时候线程<code>T1</code>进行<code>CAS</code>操作发现内存中仍然是<code>A</code>，然后<code>T1</code>操作成功。尽管线程<code>T1</code>的<code>CAS</code>操作成功，但可能存在潜藏的问题。</li>
<li>循环时间长开销大：自旋<code>CAS</code>（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。</li>
</ol>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set name &#x3D; &#39;XXX&#39;, version &#x3D; version + 1 where id &#x3D; #&#123;id&#125; and version &#x3D; #&#123;version&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="MVCC-：-Multi-Version-Concurrency-Control-即多版本并发控制"><a href="#MVCC-：-Multi-Version-Concurrency-Control-即多版本并发控制" class="headerlink" title="MVCC ： Multi-Version Concurrency Control, 即多版本并发控制"></a>MVCC ： Multi-Version Concurrency Control, 即<strong>多版本并发控制</strong></h3><p>MVCC 是实现乐观锁的一种方案，用空间（多版本）以及回滚成本（冲突），保证可重复读且没有幻读（读小于自己事务ID的版本）避免（或减少）加锁。</p>
<h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><ol>
<li><strong>多版本并发控制</strong>（MVCC），来实现 MySQL 上的<code>多事务``并发访问</code>时，隔离级别控制；</li>
<li><strong>数据版本</strong>：并发事务执行时，同一行数据有多个版本</li>
<li><strong>事务版本</strong>：每个事务都有一个事务版本</li>
<li>版本有序 ：版本是通过<code>时间</code>来标识的<ul>
<li><strong>数据版本</strong>：包含<code>创建版本</code>（创建时间）、<code>删除版本</code>（删除时间）</li>
<li><strong>事务版本</strong>：事务的<code>创建时间</code>，作为<code>事务版本</code></li>
<li>Note：<strong>数据版本</strong>，并不包含<code>更新版本</code>（更新时间），因为，在多事务并发情况下，更新操作，实际是：<code>删除原数据</code> + <code>新增新数据</code></li>
</ul>
</li>
</ol>
<p><img src="https://wangxin201492.github.io/techImages/mvcc-version-relation.png" alt="mvcc-version-relation.png"></p>
<h4 id="MVCC-本质"><a href="#MVCC-本质" class="headerlink" title="MVCC 本质"></a>MVCC 本质</h4><ol>
<li>本质使用了<code>copy-on-write</code>（写时复制），为每个数据保留多份 snapshot</li>
<li>不同 snapshot 之间，使用<code>指针</code>连接成<code>链表</code>；</li>
<li>创建事务，能看到的 snapshot 是受限的，是链表上，<code>小于等于</code>当前事务版本的<code>最大版本</code>（读取已提交：离当前事务<code>最近</code>的<code>已提交</code>版本）</li>
<li><code>update</code> 操作，创建一个新的 snapshot，并使用事务版本，作为创建版本；</li>
</ol>
<p><img src="https://wangxin201492.github.io/techImages/mvcc-snapshot-list.png" alt="mvcc-snapshot-list.png"></p>
<h4 id="MVCC-历史数据清理"><a href="#MVCC-历史数据清理" class="headerlink" title="MVCC 历史数据清理"></a>MVCC 历史数据清理</h4><p>// TODO</p>
<h4 id="MVCC在事务中使用"><a href="#MVCC在事务中使用" class="headerlink" title="MVCC在事务中使用"></a>MVCC在事务中使用</h4><p>MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）</p>
<ol>
<li>Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC。原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。</li>
<li>串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。</li>
</ol>
<p>通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。</p>
<p>RR 和 RC 隔离级别生成 ReadView 时间不同</p>
<ol>
<li>在 <code>RR</code> 隔离级别下，每个事务 <code>touch first read</code> 时（本质上就是执行第一个 <code>SELECT</code> 语句时，后续所有的 <code>SELECT</code> 都是复用这个 <code>ReadView</code> ，其它 <code>update</code> , <code>delete</code> , <code>insert</code> 语句和一致性读 <code>snapshot</code> 的建立没有关系），会将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code> 。</li>
<li>在 <code>RC</code> 隔离级别下，每个 <code>SELECT</code> 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code> 。</li>
</ol>
<p>二者的区别就在于生成 <code>ReadView</code> 的时间点不同，一个是事务之后第一个 <code>SELECT</code> 语句开始、一个是事务中每条 <code>SELECT</code> 语句开始。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71156910</a></li>
<li><a href="https://segmentfault.com/a/1190000016611415" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016611415</a></li>
<li><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="noopener">https://juejin.im/post/5b4977ae5188251b146b2fc8</a></li>
<li><a href="https://segmentfault.com/a/1190000015239603" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015239603</a></li>
<li><a href="http://ningg.top/inside-mysql-transaction-and-mvcc/" target="_blank" rel="noopener">http://ningg.top/inside-mysql-transaction-and-mvcc/</a></li>
<li><a href="https://www.codercto.com/a/88775.html" target="_blank" rel="noopener">https://www.codercto.com/a/88775.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangxin201492</p>
              <p class="site-description motion-element" itemprop="description">my blogs</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wangxin201492" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wangxin201492@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangxin201492</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
