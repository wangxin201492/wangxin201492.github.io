---
title: 关于乐观锁的探索
date: 2020-06-16 16:41:56
tags:
- lock
- OCC
categories:
- lock
- OCC
---

> **乐观并发控制**（又名“**乐观锁**”，Optimistic Concurrency Control，缩写“OCC”）

## 为什么要使用锁

在多线程编程领域，基本上所有的编程模型都采用了“**并发访问串行处理**”的策略，而方法就是给临界资源加一把锁

## 并发控制策略 ：乐观锁、悲观锁

锁的一种宏观分类方式是**悲观锁**和**乐观锁**。悲观锁与乐观锁**并不是特指某个锁**，而是在并发情况下的两种不同策略。

* 悲观锁(Pessimistic Lock) : 就是很悲观，每次去拿数据的时候都认为别人会修改。所以**每次在拿数据的时候都会上锁**。这样别人想拿数据就被挡住，直到悲观锁被释放。
* 乐观锁(Optimistic Lock) : 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，**更新前检查在读取至更新这段时间别人有没有修改过这个数据**。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）。



缺点：悲观锁阻塞事务，乐观锁回滚重试。

### 悲观锁的代价

日常用到的加锁基本都是悲观锁。悲观锁是用来做并发最简单的方式，其代价也是最高的：

* 加锁、释放锁会需要操作系统进行上下文切换和调度延时，在上下文切换的时候，cpu之前缓存的指令和数据都将失效，这个过程将增加系统开销。
* 多个线程同时竞争锁，锁竞争机制本身需要消耗系统资源。没有获取到锁的线程会被挂起直至获取锁，在线程被挂起和恢复执行的过程中也存在很大开销。
* 等待锁的线程会阻塞，影响实际的使用体验。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(Priority Inversion)。



### 乐观锁、悲观锁的选择

适用场景考虑几个因素：

1. 响应速度：需要响应速度快使用乐观锁
2. 冲突频率：
   1. 对于资源竞争较少（多读场景、线程冲突较轻）的情况选择**乐观锁** ：使用悲观锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而乐观锁操作自旋几率较少，因此可以获得更高的性能。
   2. 对于资源竞争严重（多写场景，线程冲突严重）的场景选择**悲观锁** ：乐观锁自旋的概率会比较大，从而浪费更多的CPU资源，效率低于悲观锁。
3. 重试代价：代价高则用悲观锁



## 乐观锁实现

乐观锁允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为**无锁编程**。



换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！（下文描述的版本号机制也是基于 MySQL 中提供了一个原子操作，这个原子操作最终也可能是一个CAS或者悲观锁）

### CAS

即**compare and swap（比较与交换）**，是一种有名的**无锁算法**。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。



**CAS算法**涉及到三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。



**CAS利用CPU指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。**

#### CAS 带来的问题

1. `ABA`问题：比如说一个线程`T1`从内存位置`V`中取出`A`，这时候另一个线程`T2`也从内存中取出`A`，并且`T2`进行了一些操作变成了`B`，然后`T2`又将`V`位置的数据变成`A`，这时候线程`T1`进行`CAS`操作发现内存中仍然是`A`，然后`T1`操作成功。尽管线程`T1`的`CAS`操作成功，但可能存在潜藏的问题。
2. 循环时间长开销大：自旋`CAS`（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。
3. 只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。



### 版本号机制

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

```mysql
update table set name = 'XXX', version = version + 1 where id = #{id} and version = #{version};
```



### MVCC ： Multi-Version Concurrency Control, 即**多版本并发控制**

MVCC 是实现乐观锁的一种方案，用空间（多版本）以及回滚成本（冲突），保证可重复读且没有幻读（读小于自己事务ID的版本）避免（或减少）加锁。

#### 整体思路

1. **多版本并发控制**（MVCC），来实现 MySQL 上的`多事务``并发访问`时，隔离级别控制；
2. **数据版本**：并发事务执行时，同一行数据有多个版本
3. **事务版本**：每个事务都有一个事务版本
4. 版本有序 ：版本是通过`时间`来标识的
   - **数据版本**：包含`创建版本`（创建时间）、`删除版本`（删除时间）
   - **事务版本**：事务的`创建时间`，作为`事务版本`
   - Note：**数据版本**，并不包含`更新版本`（更新时间），因为，在多事务并发情况下，更新操作，实际是：`删除原数据` + `新增新数据`

![mvcc-version-relation.png](https://wangxin201492.github.io/techImages/mvcc-version-relation.png)

#### MVCC 本质

1. 本质使用了`copy-on-write`（写时复制），为每个数据保留多份 snapshot
2. 不同 snapshot 之间，使用`指针`连接成`链表`；
3. 创建事务，能看到的 snapshot 是受限的，是链表上，`小于等于`当前事务版本的`最大版本`（读取已提交：离当前事务`最近`的`已提交`版本）
4. `update` 操作，创建一个新的 snapshot，并使用事务版本，作为创建版本；

![mvcc-snapshot-list.png](https://wangxin201492.github.io/techImages/mvcc-snapshot-list.png)

#### MVCC 历史数据清理

// TODO



#### MVCC在事务中使用

MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）

1. Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC。原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
2. 串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。



通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。



RR 和 RC 隔离级别生成 ReadView 时间不同

1. 在 `RR` 隔离级别下，每个事务 `touch first read` 时（本质上就是执行第一个 `SELECT` 语句时，后续所有的 `SELECT` 都是复用这个 `ReadView` ，其它 `update` , `delete` , `insert` 语句和一致性读 `snapshot` 的建立没有关系），会将当前系统中的所有的活跃事务拷贝到一个列表生成 ` ReadView` 。
2. 在 `RC` 隔离级别下，每个 `SELECT` 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 `ReadView` 。

二者的区别就在于生成 `ReadView` 的时间点不同，一个是事务之后第一个 `SELECT` 语句开始、一个是事务中每条 `SELECT` 语句开始。



## 参考资料

* https://zhuanlan.zhihu.com/p/71156910
* https://segmentfault.com/a/1190000016611415
* https://juejin.im/post/5b4977ae5188251b146b2fc8
* https://segmentfault.com/a/1190000015239603
* http://ningg.top/inside-mysql-transaction-and-mvcc/
* https://www.codercto.com/a/88775.html