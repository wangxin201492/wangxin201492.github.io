<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="wangxin201492">
<meta property="og:url" content="https://wangxin201492.github.io/page/2/index.html">
<meta property="og:site_name" content="wangxin201492">
<meta property="og:description" content="my blogs">
<meta property="article:author" content="wangxin201492">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangxin201492.github.io/page/2/"/>





  <title>wangxin201492</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b4b40ab284f92e7b4921a8198acda5b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wangxin201492</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/MongoDB-ReplicaSetMonitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/MongoDB-ReplicaSetMonitor/" itemprop="url">MongoDB ReplicaSetMonitor对shard探测机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-27T12:59:24+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>sharding实例对后端 shard 会进行状态探测，以发现 shard 是否有节点更新（ 选主、节点加入、节点异常）。提供探测能力的核心类为 <code>ReplicaSetMonitor</code> 及相关类。</p>
<p>对于状态探测的基本逻辑应该也比较好构思：<strong>定期状态探测、探测结果存储、探测结果查询</strong>。MongoDB中也按照这个逻辑来完成的： </p>
<ul>
<li><p><code>ReplicaSetMonitor</code> 提供状态查询的接口，以及定期探测触发能力。状态信息存储在 <code>_state</code> (<code>SetState</code>类型成员变量) 中</p>
</li>
<li><p><code>SetState</code> 存储 ReplicaSet shard 的状态信息。包装 Node 记录各个 Node 的信息，持有一个 <code>ScanState</code> 记录该 ReplicaSet 当前正在 scan 的信息</p>
</li>
<li><p>Refresher 进行实际的状态探测，提供一个 static 方法 <code>ensureScanInProgress</code> 来初始化一个 Refresher 进行探测。</p>
<ul>
<li><code>Refresher</code> 与 <code>SetState</code> 是一一绑定的，只有 <code>SetState</code> 在被探测状态，才会有对应的 <code>Refresher</code> 产生</li>
</ul>
</li>
<li><p><code>ScanState</code> 记录 <code>Refresher</code> 探测过程中的状态信息。<code>ScanState</code> 会被 <code>SetState::currentScan</code> 及 <code>Refresher::_scan</code> 持有，一般情况下这2个 scan 是相同的，但是可能存在并发的场景导致指向的不是同一个 scan， 这时候以 <code>SetState::currentScan</code> 为准。</p>
</li>
</ul>
<p>ReplicaSetMonitor / SetState / Refresher / ScanState 具体关系参考下图：</p>
<p><img src="https://wangxin201492.github.io/techImages/MongoDB-ReplicaSetMonitor.png" alt="MongoDB-ReplicaSetMonitor.png"></p>
<h2 id="探测目标-shard-要求"><a href="#探测目标-shard-要求" class="headerlink" title="探测目标 shard 要求"></a>探测目标 shard 要求</h2><p><strong>只有以 ReplicaSet 方式启动的 shard(包含 config )，才会持有一个 <code>ReplicaSetMonitor</code> 类的成员。</strong>即只有 ReplicaSet shard 才会被探测，以 Standalong 方式启动的 shard 不会进行探测</p>
<h2 id="探测触发"><a href="#探测触发" class="headerlink" title="探测触发"></a>探测触发</h2><p>ReplicaSetMonitor 中会<strong>定期进行 shard 状态探测</strong>，如果当前维系的状态<strong>不能满足其他代码的 ReadPreference 要求，也会下发探测</strong></p>
<h3 id="定期探测"><a href="#定期探测" class="headerlink" title="定期探测"></a>定期探测</h3><p><code>ReplicaSetMonitor</code> 初始化时会调用<code>_scheduleRefresh</code>，而后通过 <code>_scheduleRefresh</code> 和 <code>_doScheduledRefresh</code> 两个函数相互调用及 <code>TaskExecutor::scheduleWorkAt</code> 完成:</p>
<ul>
<li><code>_scheduleRefresh</code>中通过使用 <code>TaskExecutor::scheduleWorkAt</code> 注册定时任务，定时任务负责调用 <code>_doScheduledRefresh</code></li>
<li><code>_doScheduledRefresh</code> 负责调用 <code>Refresher::ensureScanInProgress</code> 进行 <code>Refresher</code> 新建与 探测下发。同时根据当前 <code>SetState</code> 的状态来决定下次刷新的周期，然后调用 <code>_scheduleRefresh</code> 注册新的定时任务</li>
</ul>
<p>默认情况下，定时任务每隔 <strong>kDefaultRefreshPeriod (30s)</strong> 执行一次。但是如果 SetState 的 waiters 结构中非空，则会将周期调整为 <strong>kExpeditedRefreshPeriod (500ms)</strong> 。SetState 的 waiters 结构中 数据添加在下文按需探测时，数据清理在探测执行完成时。</p>
<h3 id="按需探测"><a href="#按需探测" class="headerlink" title="按需探测"></a>按需探测</h3><p>代码中需要按照某种 ReadPreference 获得 shard 的部分节点地址时，会调用 ReplicaSetMonitor 提供 <code>getHostsOrRefresh</code> 函数。如果当前持有的 shard 信息不能满足 ReadPreference 时，会构造一个 promise-future，返回 future ，然后将 promise 添加到 SetState 的 waiter 中，并立即下发刷新。</p>
<ul>
<li>如果刷新结果能满足 ReadPreference ，则返回对应的host</li>
<li>如果不能满足，则会按照上文描述，下次 <code>_doScheduledRefresh</code> 被调用时，将刷新周期改为 <strong>500ms</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ReplicaSetMonitor::_doScheduledRefresh(<span class="keyword">const</span> CallbackHandle&amp; currentHandle) &#123;</span><br><span class="line">    ....</span><br><span class="line">    Refresher::ensureScanInProgress(_state, lk);</span><br><span class="line"></span><br><span class="line">    Milliseconds period = _state-&gt;refreshPeriod;</span><br><span class="line">    <span class="keyword">if</span> (_state-&gt;isExpedited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_state-&gt;waiters.empty()) &#123;</span><br><span class="line">            <span class="comment">// No current waiters so we can stop the expedited scanning.</span></span><br><span class="line">            _state-&gt;isExpedited = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            period = <span class="built_in">std</span>::<span class="built_in">min</span>(period, kExpeditedRefreshPeriod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _scheduleRefresh(_state-&gt;now() + period, lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="探测方式"><a href="#探测方式" class="headerlink" title="探测方式"></a>探测方式</h2><p>探测的核心 就是发送 <strong>isMaster()</strong> 命令并处理返回结果。</p>
<p>探测的中间状态记录在上文描述的 <strong>ScanState</strong> 中，主要持有几个 成员 来实现：</p>
<ul>
<li><strong>hostsToScan</strong> : 待执行队列</li>
<li><strong>possibleNodes</strong> :     非primary节点返回的node集合</li>
<li><strong>waitingFor</strong> : 已经发送命令，等待返回的集合</li>
<li><strong>triedHosts</strong> : 已经下发isMaster命令的集合</li>
</ul>
<p>探测过程有一个简单的状态机：<strong>CONTACT_HOST</strong>、<strong>WAIT</strong>、<strong>DONE</strong>，基于上面描述的 ScanState 持有的几个成员来判断：</p>
<ul>
<li><strong>CONTACT_HOST</strong> : 链接当前实例。如果 <strong>hostsToScan</strong> 中有 host，则会返回该 host 并标记状态为 <strong>CONTACT_HOST</strong></li>
<li><strong>WAIT</strong> : 等待 response 。如果 <strong>hostsToScan</strong> 为空，而 <strong>waitingFor</strong> 不为空则标记为 WAIT 状态</li>
<li><strong>DONE</strong> : Refresh 完成。如果 <code>_scan != _set-&gt;currentScan</code> 或者 <strong>hostsToScan</strong> &amp; <strong>waitingFor</strong> 均为空，则为 <strong>DONE</strong> 状态</li>
</ul>
<p>状态流转都在<code>getNextStep</code>中实现，用于<code>scheduleNetworkRequests</code>调度流转。</p>
<p><code>IsMasterReply</code> : 记录isMaster必要的返回信息</p>
<h3 id="请求下发"><a href="#请求下发" class="headerlink" title="请求下发"></a>请求下发</h3><p><code>scheduleNetworkRequests</code> 通过 <code>getNextStep</code> 依次从 <strong>hostsToScan</strong> 拿到一个host信息，并将 host 信息插入到 <strong>waitingFor</strong> 及 <strong>triedHosts</strong> 这 2 个 set 中。然后针对这个 host 调用 <code>scheduleIsMaster</code> </p>
<p><code>scheduleIsMaster</code> 构建一个 isMaster 的request ，提交给 executor ，并注册回调：</p>
<ul>
<li>如果当前 Refresher 的 <code>_scan</code> 和 <code>_set-&gt;currentScan</code> 不同，则忽略返回结果</li>
<li>如果返回结果是 ok，则调用 <code>receivedIsMaster</code>；否则调用 <code>failedHost</code></li>
</ul>
<h3 id="response处理"><a href="#response处理" class="headerlink" title="response处理"></a>response处理</h3><p><code>receivedIsMaster</code> : 将 host 从 waitingFor 中清理掉，然后构建一个 <code>IsMasterReply</code></p>
<ul>
<li>如果 <code>IsMasterReply</code> 的结果不是 ok ， 则会标记当前 host 为 fail</li>
<li>如果 reply 中 setName 和 _set 中的 name 不匹配，则会标记当前 host 为 fail</li>
<li>如果 reply 声明自己是 primary 节点， 则会调用 <code>receivedIsMasterFromMaster</code></li>
<li>找到 primary 节点以后的 reply 处理： 将 reply 更新到对应的 <code>_set</code> 的 node 上，并在 notify 中判断是否有已经满足 <code>_set-&gt;waiter</code> 的 promise，有则返回</li>
<li>未找到 primary 节点前的 reply 处理： 将 reply 的 member 全部加到 <strong>possibleNodes</strong> 中，如果在 reply 中声明了 primary 节点的地址且该 primary </li>
<li>在 <strong>triedHosts</strong> 中，则将该节点重新添加会 <strong>hostsToScan</strong>。然后将该 reply 记录到 <strong>unconfirmedReplies</strong> 中</li>
</ul>
<p><code>receivedIsMasterFromMaster</code> 处理逻辑比较多，简单整理了下：</p>
<ul>
<li>有效性判断：判断 <code>configVersion</code> / <code>electionId</code> 的有效性</li>
<li>状态存储：将 reply 的结果更新到 <code>SetState</code> 中。更新nodes / seedNodes / seedConnStr / workingConnstr</li>
<li>清理<code>ScanState</code> 中记录的信息：<strong>triedHost</strong> / <strong>waiitingFor</strong> / <strong>unconfirmedReplies</strong></li>
<li>如果 primary 有变化，则会通知所有的 listener 状态变更。</li>
</ul>
<p><code>failedHost</code> : 将 host从 <strong>waitingFor</strong> 中移除，并将node标记为 fail</p>
<p>无论<code>receivedIsMaster</code> 还是 <code>failedHost</code> 执行完成后，都会调用 <code>scheduleNetworkRequests</code> 重新调度（可能有新加入 <strong>hostsToScan</strong> 的节点）</p>
<h2 id="周边类"><a href="#周边类" class="headerlink" title="周边类"></a>周边类</h2><p><code>ReplicaSetMonitorManager</code> 是负责 <code>ReplicaSetMonitor</code> 的管理类，维护一个 map 结构 （记录 setName 和 <code>ReplicaSetMonitor</code>），一个<code>TaskExecutor</code> 用于所有 <code>ReplicaSetMonitor</code> 命令执行，以及一个<code>ReplicaSetChangeNotifier</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/command/serverStatus/MongoDB-request-counter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/command/serverStatus/MongoDB-request-counter/" itemprop="url">MongoDB 请求计数逻辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-22T17:25:43+08:00">
                2020-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/serverStatus/" itemprop="url" rel="index">
                    <span itemprop="name">serverStatus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>mongos上一个find请求堆栈主要路径是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#0 mongo::(anonymous namespace)::ClusterFindCmd::Invocation::run  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;cluster_find_cmd.cpp:205</span><br><span class="line"></span><br><span class="line">#1 0x00007f3701fae26a in mongo::(anonymous namespace)::execCommandClient  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:303</span><br><span class="line"></span><br><span class="line">#2 0x00007f3701faff38 in mongo::(anonymous namespace)::runCommand  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:489</span><br><span class="line"></span><br><span class="line">#3 0x00007f3701fb1f76 in mongo::Strategy::clientCommand at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:800</span><br><span class="line"></span><br><span class="line">#4 0x00007f3701e243cc in mongo::ServiceEntryPointMongos::handleRequest  at src&#x2F;mongo&#x2F;s&#x2F;service_entry_point_mongos.cpp:95</span><br><span class="line"></span><br><span class="line">#5 0x00007f3701e7d5e2 in mongo::ServiceStateMachine::_processMessage  at src&#x2F;mongo&#x2F;transport&#x2F;service_state_machine.cpp:452</span><br></pre></td></tr></table></figure>



<p><code>db.serverStatus()</code> 输出结果中有3个地方对请求进行了计数，这里简单整理下</p>
<ol>
<li><code>db.serverStatus().network.numRequests</code>(简称<strong>requests计数</strong>） – 对应在堆栈中#5（即 <code>ServiceStateMachine::_processMessage()</code>）进行计数。表示<strong>接收的网络包数量</strong></li>
<li><code>db.serverStatus().metrics.commands.*.total &amp; failed</code>（简称<strong>metrics计数</strong>） – 对应在堆栈中#1（即 <code>execCommandClient()</code> ）进行计数。表示<strong>不同命令执行的次数</strong></li>
<li><code>db.serverStatus().opcounters</code>（简称<strong>opcounters计数</strong>） – 对应在堆栈中#0（即 <code>Invocation::run()</code>）即进行计数。表示<strong>requests计数</strong></li>
</ol>
<p><strong>requests计数</strong>和<strong>metrics计数</strong>的逻辑是固定的，而对于opcounters计数会根据请求的不同有一定gap。</p>
<h2 id="opcounters-计数分析"><a href="#opcounters-计数分析" class="headerlink" title="opcounters 计数分析"></a>opcounters 计数分析</h2><p><code>db.serverStatus().opcounters</code> 包含如下结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"insert"</span> : NumberLong(<span class="number">6</span>),</span><br><span class="line">        <span class="attr">"query"</span> : NumberLong(<span class="number">1</span>),</span><br><span class="line">        <span class="attr">"update"</span> : NumberLong(<span class="number">2</span>),</span><br><span class="line">        <span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">        <span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">        <span class="attr">"command"</span> : NumberLong(<span class="number">75</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>ServiceEntryPointMongos::handleRequest()</code>中对计数场景进行了区分：</p>
<h3 id="计数场景1：-opcode-OP-MSG-或者-opcode-OP-QUERY-且-namespace的collection部分-“-cmd”"><a href="#计数场景1：-opcode-OP-MSG-或者-opcode-OP-QUERY-且-namespace的collection部分-“-cmd”" class="headerlink" title="计数场景1：(opcode == OP_MSG) 或者 (opcode == OP_QUERY 且 namespace的collection部分 == “$cmd”)"></a>计数场景1：(<code>opcode == OP_MSG</code>) 或者 (<code>opcode == OP_QUERY</code> 且 namespace的collection部分 == “$cmd”)</h3><p>按照上面举例的find堆栈 <code>clientCommand()</code> –&gt; <code>runCommand()</code> –&gt; <code>execCommandClient()</code> –&gt; <code>Invocation::run()</code> 依次调用。这里所有的command都会继承 Command 类，该类提供一个 <code>shouldAffectCommandCounter()</code> 返回True。</p>
<ul>
<li>insert / update / delete / query / getmore 请求重写了 <code>shouldAffectCommandCounter()</code> 返回 false ，在 <code>Invocation::run()</code> 中完成计数</li>
<li>其余请求均作为 command，在 <code>execCommandClient()</code> 中完成计数</li>
</ul>
<h3 id="计数场景2：opcode-OP-QUERY-且-namespace的collection部分-“-cmd”"><a href="#计数场景2：opcode-OP-QUERY-且-namespace的collection部分-“-cmd”" class="headerlink" title="计数场景2：opcode == OP_QUERY 且 namespace的collection部分 != “$cmd”"></a>计数场景2：<code>opcode == OP_QUERY</code> 且 namespace的collection部分 != “$cmd”</h3><p>直接调用 <code>Strategy::queryOp()</code>， 并在其中完成计数</p>
<h3 id="计数场景3：opcode-OP-GET-MORE"><a href="#计数场景3：opcode-OP-GET-MORE" class="headerlink" title="计数场景3：opcode == OP_GET_MORE"></a>计数场景3：<code>opcode == OP_GET_MORE</code></h3><p>直接调用 <code>Strategy::getMore()</code>，并在其中完成计数</p>
<h3 id="计数场景4：opcode-OP-KILL-CURSORS"><a href="#计数场景4：opcode-OP-KILL-CURSORS" class="headerlink" title="计数场景4：opcode == OP_KILL_CURSORS"></a>计数场景4：<code>opcode == OP_KILL_CURSORS</code></h3><p>直接调用 <code>Strategy::killCursors()</code>，并在其中调用 <code>OpCounters::gotOp()</code></p>
<p>gotOp 对 OP_KILL_CURSORS / OP_REPLY 不进行计数，即这两种场景不会记录在 opcounters 中</p>
<h3 id="计数场景5：opcode-OP-INSERT-OP-UPDATE-OP-DELETE"><a href="#计数场景5：opcode-OP-INSERT-OP-UPDATE-OP-DELETE" class="headerlink" title="计数场景5：opcode == OP_INSERT / OP_UPDATE / OP_DELETE"></a>计数场景5：<code>opcode == OP_INSERT / OP_UPDATE / OP_DELETE</code></h3><p>按照场景1堆栈 <code>Strategy::writeOp()</code> –&gt; <code>runCommand()</code> –&gt; <code>execCommandClient()</code> –&gt; <code>Invocation::run()</code> 依次调用，同场景1</p>
<h3 id="对insert-update-delete-请求的计数说明"><a href="#对insert-update-delete-请求的计数说明" class="headerlink" title="对insert / update / delete 请求的计数说明"></a>对<code>insert / update / delete</code> 请求的计数说明</h3><p>对于insert / update / delete 请求，会在 <code>Invocation::run()</code> 中完成计数，但是对这3个请求的处理不是简单的+1完成的。增加的数量为 <code>batchedRequest.sizeWriteOps()</code>。由于3.6版本中新增了 OP_MSG 的协议类型，支持这3种请求携带多条数据：即 OP_MSG 协议中 <strong>kind=Document Sequence 的 sections 字段</strong>。这3种请求的具体实现，都重写了 Command 类提供的 parse 函数，基于原有的 request 构建了一个额外的 <code>BatchedCommandRequest</code> ，调用的是 <code>BatchedCommandRequest::parseInsert()</code> 函数。</p>
<p>实际执行验证来看：</p>
<p>通过insert插入一个BSONArray，opcounters.insert 会增加 array 的 size。和上面的分析是对齐的</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"insert"</span> : NumberLong(<span class="number">2</span>),</span><br><span class="line">	<span class="attr">"query"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"update"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"command"</span> : NumberLong(<span class="number">58</span>)</span><br><span class="line">&#125;</span><br><span class="line">mongos&gt; db.collection.insert([&#123;name: "B"&#125;,&#123;name: "C"&#125;])</span><br><span class="line">BulkWriteResult(&#123;</span><br><span class="line">	"writeErrors" : [ ],</span><br><span class="line">	"writeConcernErrors" : [ ],</span><br><span class="line">	"nInserted" : 2,</span><br><span class="line">	"nUpserted" : 0,</span><br><span class="line">	"nMatched" : 0,</span><br><span class="line">	"nModified" : 0,</span><br><span class="line">	"nRemoved" : 0,</span><br><span class="line">	"upserted" : [ ]</span><br><span class="line">&#125;)</span><br><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"insert"</span> : NumberLong(<span class="number">4</span>),</span><br><span class="line">	<span class="attr">"query"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"update"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"command"</span> : NumberLong(<span class="number">62</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而 <code>db.colleciton.update()</code> / <code>db.colleciton.delete()</code> 并不像 <code>insert()</code> 一样支持多条记录的修改。这几个函数都是被 mongo shell 封装过的，具体通过 insert / update / delete 进行多条document修改可以参考<a href="https://docs.mongodb.com/manual/reference/command/nav-crud/" target="_blank" rel="noopener">官网文档</a>中提供的命令，分别对应有 inserts / updates / deletes 字段支持多条document修改</p>
<p><strong>Notice:</strong> 按照上面的分析，对于opcode == OP_QUERY / OP_GET_MORE / OP_KILL_CURSORS 的场景，对metrics计数应该是有缺失的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/command/serverStatus/MongoDB-serverStatus-implement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/command/serverStatus/MongoDB-serverStatus-implement/" itemprop="url">MongoDB serverStatus实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-21T13:15:09+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/serverStatus/" itemprop="url" rel="index">
                    <span itemprop="name">serverStatus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>[TOC]</p>
<p> <code>CmdServerStatus</code> 的 run() 函数是 <code>serverStatus</code> 命令的具体实现</p>
<ul>
<li>首先将一些全局信息添加到result中</li>
<li>遍历<code>_sections</code>，调用<code>appendSection</code>，将所有注册的<code>Section</code>结果添加到result中</li>
<li>调用<code>MetricTree::theMetricTree-&gt;appendTo()</code>，将所有<code>Metric</code>指标添加到result中</li>
<li>其他一些信息的补充</li>
</ul>
<p>同时 <code>CmdServerStatus</code> 还维护了一个 <code>_sections</code> （map结构）存储section名称和具体 <code>ServerStatusSection</code> 的对应关系。提供 <code>addSection</code> 函数将制定section添加到 <code>_sections</code> 中</p>
<h2 id="Section指标"><a href="#Section指标" class="headerlink" title="Section指标"></a>Section指标</h2><p><code>ServerStatusSection</code> 是所有 <code>section</code> 指标的基类，构造方法调用 <code>CmdServerStatusInstantiator::getInstance()-&gt;addSection()</code> 将自身注册到 <code>CmdServerStatus</code> 中。并声明 virtual 函数 <code>includeByDefault</code> , <code>addRequiredPrivileges</code> , <code>generateSection</code> , <code>appendSection</code> 由子类定义实现，子类主要需要按需求定义<code>includeByDefault</code> , <code>generateSection</code> 的具体实现。</p>
<ul>
<li><code>includeByDefault</code> 用于说明是否默认被包含</li>
<li><code>generateSection</code>&amp;<code>appendSection</code>   一般实现其中一个即可，父类方法中<code>appendSection</code> 调用了 <code>generateSection</code> ，所以一般只需要实现 <code>generateSection</code> 即可。</li>
</ul>
<p><code>CmdServerStatusInstantiator</code> 是包装 <code>CmdServerStatus</code> 用于获取 <code>CmdServerStatus</code> 单例对象的一个struct，提供 <code>getInstance()</code> 完成单例对象获取。所以上面讲到的 <code>ServerStatusSection</code> 构造时调用 <code>CmdServerStatusInstantiator::getInstance()-&gt;addSection()</code> ，最终完成了自身到 <code>CmdServerStatus</code> 的 _sections 注册。</p>
<p>serverStatus命令运行时将遍历自身的 _sections ，依次根据 <code>includeByDefault</code> 配置，调用其 appendSection 完成 response BSON 的构建。</p>
<blockquote>
<p>其他 Command 都是在类声明的时候同时定义了一个对象，完成到 CommandMap 的注册。而 <code>CmdServerStatus</code> 由于需要 <code>CmdServerStatusInstantiator</code> 构建单例对象，所以是在 <code>CmdServerStatusInstantiator</code> 声明时定义了一个对象，完成 <code>CmdServerStatus</code> 到 CommandMap 的注册行为。</p>
</blockquote>
<h2 id="Metric指标"><a href="#Metric指标" class="headerlink" title="Metric指标"></a>Metric指标</h2><p><code>MetricTree</code>维护了一个树状结构(下文简称Tree) 用于存储所有的 metric指标 及其 path 对应关系，同时提供一个静态变量 <code>theMetricTree</code> 对外提供服务。同时提供 <code>add</code> 和 <code>appendTo</code> 函数分别用于将 Tree 添加到 <code>theMetricTree</code> 以及将 Tree 的数据以BSON的形式输出。</p>
<ul>
<li><p><code>add</code> 函数用于将 <code>ServerStatusMetric</code> 添加到 <code>Tree</code> : <code>Tree</code> 维护 <code>metrics path</code> 和 <code>ServerStatusMetric</code> 的对应关系，内部是由 2 个 map 构成的，如果当前 <code>metrics path</code> 是叶子节点（即 path 中不存在”.”），那么存储到``path –&gt; ServerStatusMetric<code>的 map 中，反之取出 path 的第一级路径，存储到 第一级路径 --&gt;</code>MetricTree` （不存在则新加一个） ，然后递归调用完成添加</p>
</li>
<li><ul>
<li>如果 path 是以 “.” 为开头，则添加到 Tree 的顶级路径，否则会在提供的 path 前添加 “metrics.” 前缀（即添加到metrics的子节点上）</li>
</ul>
</li>
<li><p><code>appendTo</code> 函数用于将 <code>Tree</code> 的数据以BSON的形式输出 ： 对于非叶子节点，会递归调用 <code>appendTo</code> 函数。对于叶子节点则会调用 <code>ServerStatusMetric</code> 的 <code>appendAtLeaf</code> 函数。最终根据所有 <code>ServerStatusMetric</code> 的 path 产生对应的的BSON</p>
</li>
</ul>
<p><code>ServerStatusMetric</code> 是所有 metric指标 的基类，主要提供构造方法调用 <code>MetricTree::theMetricTree-&gt;add(this)</code> 将自身注册到 <code>MetricTree</code> 中。并声明一个 <code>virtual appendAtLeaf</code> 函数由子类定义实现。该类有4个子类：</p>
<ul>
<li><p>模板类 <code>ServerStatusMetricField</code> 是一个被广泛应用的子类。增加一个T，用于实现大多数需求：都是 k-v 的结构， <code>appendAtLeaf</code>将 <strong>k &amp; v</strong> 直接append到bson中</p>
</li>
<li><ul>
<li>举例场景：所有command的一个成员变量，用于做类似命令与请求次数的绑定，便于serverStatus拿到结果</li>
</ul>
</li>
<li><p><code>MemBase (= .mem.bits )</code> ，获取MongoDB使用的内存信息</p>
</li>
<li><p><code>ClusterCursorStats (= cursor )</code>，cursor 信息</p>
</li>
<li><p><code>ReplExecutorSSM (= repl.executor )</code>，// TODO</p>
</li>
</ul>
<p>serverStatus命令运行时，将调用 <code>theMetricTree</code> 的 <code>appendTo</code> 函数，完成 response BSON 的构建</p>
<h2 id="Section指标-amp-Metric指标-实现对比"><a href="#Section指标-amp-Metric指标-实现对比" class="headerlink" title="Section指标 &amp; Metric指标 实现对比"></a>Section指标 &amp; Metric指标 实现对比</h2><p>ServerStatusMetric 和 ServerStatusSection 下文统称为Impl</p>
<table>
<thead>
<tr>
<th></th>
<th>Section指标</th>
<th>Metric指标</th>
</tr>
</thead>
<tbody><tr>
<td>都有一个单例的对象管理</td>
<td>CmdServerStatusInstantiator::getInstance()</td>
<td>MetricTree::theMetricTree</td>
</tr>
<tr>
<td>都是 name – Impl  的对应关系</td>
<td>CmdServerStatus  中_sections是一个map结构  name – ServerStatusSection</td>
<td>ServerStatusMetric中基于2个map结构实现了一个树状结构  叶子节点也都是  name – ServerStatusMetric</td>
</tr>
<tr>
<td>Impl都提供一个函数将结果  append 到 response 中</td>
<td>generateSection&amp;appendSection</td>
<td>appendTo</td>
</tr>
</tbody></table>
<p>区别应该有2点：</p>
<ol>
<li><code>ServerStatusSection</code>的append函数 <code>generateSection</code>&amp;<code>appendSection</code> 包含了 opCtx 和 configElement 。定义分别是<ul>
<li>`virtual BSONObj generateSection(OperationContext* opCtx, const BSONElement&amp;      configElement) const;``</li>
<li>``virtual void appendSection(OperationContext* opCtx, const BSONElement&amp;      configElement, BSONObjBuilder* result) const;`</li>
</ul>
</li>
<li><code>ServerStatusSection</code>提供了 <code>includeByDefault</code> 和 <code>addRequiredPrivileges</code> 对输出结构的控制力更强一些</li>
</ol>
<p>看起来是对于serverStatus默认添加且是计数行为的使用 <code>ServerStatusMetric</code> 比较方便简单一些。其他情况尤其对于 opCtx 有依赖或者需要控制对serverStatus输出的还是使用 <code>ServerStatusSection</code> 操控力更强一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/linux/linux-subsys-IO/linux-io-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux/linux-subsys-IO/linux-io-overview/" itemprop="url">Linux IO子系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-20T16:00:27+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/linux-subsys-IO/" itemprop="url" rel="index">
                    <span itemprop="name">linux_subsys_IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用于IO读写的函数"><a href="#用于IO读写的函数" class="headerlink" title="用于IO读写的函数"></a>用于IO读写的函数</h2><p>应用程序通过<code>read</code>/<code>write</code>/<code>sync</code>函数和底层交互进行读写。读写过程依次会经历<code>stdio buffer</code>/<code>kernel buffer</code>/<code>disk</code>。大致流程见下图【图1】：<br><img src="https://wangxin201492.github.io/techImages/linux-io-buffers.png" alt="linux-io-buffers.png"><br><code>read</code>用于数据读取，<code>write</code>用于数据写入，这两个行为默认情况下(<code>bufferedIO</code>)都是写入<code>kernel buffer</code>中，而<code>sync</code>则是将数据从<code>kernel buffer</code>刷入<code>disk</code></p>
<h4 id="read-write-sync相关的函数区分"><a href="#read-write-sync相关的函数区分" class="headerlink" title="read/write/sync相关的函数区分"></a><code>read</code>/<code>write</code>/<code>sync</code>相关的函数区分</h4><p><img src="https://wangxin201492.github.io/techImages/linux-io-function-read-write-sync.png" alt="linux-io-function-read-write-sync.png"><br>上图【图2】描述的比较清楚</p>
<ul>
<li><code>fread</code>/<code>fwrite</code>是stdio提供的方法，数据仅和<code>stdio buffer</code> 交互</li>
<li><code>read</code>/<code>write</code>是系统调用，以默认<code>bufferIO</code>形式调用时，数据仅和<code>kernel buffer</code>交互。而以<code>directIO</code>形式调用，则会跨过<code>kernel buffer</code>，直接和物理设备交互<ul>
<li><code>pread</code>/<code>pwrite</code>同样是系统调用，可以认为是<code>seek</code>+<code>read</code>/<code>write</code></li>
</ul>
</li>
<li><code>fflush</code>则是将<code>stdio buffer</code>数据刷入<code>kernel buffer</code></li>
</ul>
<p><code>sync</code>/<code>fsync</code>/<code>fdatasync</code>:</p>
<ul>
<li>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。</li>
<li>fsync将内核缓冲区中的内容真正写入磁盘</li>
<li>fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。</li>
</ul>
<p>相关阅读：<a href="https://luoming1224.github.io/2018/11/30/[Unix%E7%BC%96%E7%A8%8B]fread%20fwrite%20fflush%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://luoming1224.github.io/2018/11/30/[Unix%E7%BC%96%E7%A8%8B]fread%20fwrite%20fflush%E5%AE%9E%E7%8E%B0/</a></p>
<h3 id="一次完整的读取流程简述"><a href="#一次完整的读取流程简述" class="headerlink" title="一次完整的读取流程简述"></a>一次完整的读取流程简述</h3><p>IO简化的技术栈【图3】中也有相关描述，更加直观一些：<br><img src="https://wangxin201492.github.io/techImages/linux-io-stack-overview.png" alt="linux-io-stack-overview.png"></p>
<p>传统的Buffered IO使用read读取文件的过程什么样的？假设要去读一个冷文件（Cache中不存在），open(2)打开文件内核后建立了一系列的数据结构，接下来调用read(2)，到达文件系统这一层，发现Page Cache中不存在该位置的磁盘映射，然后创建相应的Page Cache并和相关的扇区关联。然后请求继续到达块设备层，在IO队列里排队，接受一系列的调度后到达设备驱动层，此时一般使用DMA方式读取相应的磁盘扇区到Cache中，然后read(2)拷贝数据到用户提供的用户态buffer中去（read(2)的参数指出的）。</p>
<h2 id="IO读写的一些重要特性"><a href="#IO读写的一些重要特性" class="headerlink" title="IO读写的一些重要特性"></a>IO读写的一些重要特性</h2><h3 id="IO类型"><a href="#IO类型" class="headerlink" title="IO类型"></a>IO类型</h3><h4 id="根据是否利用标准库缓存，可以把文件I-O分为缓冲I-O与非缓冲I-O"><a href="#根据是否利用标准库缓存，可以把文件I-O分为缓冲I-O与非缓冲I-O" class="headerlink" title="根据是否利用标准库缓存，可以把文件I/O分为缓冲I/O与非缓冲I/O"></a>根据是否利用标准库缓存，可以把文件I/O分为缓冲I/O与非缓冲I/O</h4><p>缓冲I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调用访问文件<br>非缓冲I/O，是指通过系统调用来访问文件，不再经过标准库缓存<br>注意，这里的 缓冲，是指标准库内部实现的缓存，比如很多程序到换行时才真正输出，而换行之前是被标准库暂时缓存起来了</p>
<h4 id="根据是否利用操作系统的页缓存，可以把文件I-O分为直接I-O和非直接I-O"><a href="#根据是否利用操作系统的页缓存，可以把文件I-O分为直接I-O和非直接I-O" class="headerlink" title="根据是否利用操作系统的页缓存，可以把文件I/O分为直接I/O和非直接I/O"></a>根据是否利用操作系统的页缓存，可以把文件I/O分为直接I/O和非直接I/O</h4><p>直接I/O，是指跳过操作系统页缓存，直接跟文件系统交互来访问文件<br>非直接I/O，在文件读写时，先经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘<br>要实现直接I/O，需要在系统调用中指定O_DIRECT标志，不设置默认是非直接I/O<br>注意，直接I/O和非直接I/O本质上还是和文件系统交互，如果在数据库等场景中，可以跳过文件系统读写磁盘的情况，就是裸I/</p>
<h4 id="根据应用程序是否阻塞自身运行，可以把文件I-O分为阻塞I-O和非阻塞I-O"><a href="#根据应用程序是否阻塞自身运行，可以把文件I-O分为阻塞I-O和非阻塞I-O" class="headerlink" title="根据应用程序是否阻塞自身运行，可以把文件I/O分为阻塞I/O和非阻塞I/O"></a>根据应用程序是否阻塞自身运行，可以把文件I/O分为阻塞I/O和非阻塞I/O</h4><h4 id="是指应用程序执行I-O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务"><a href="#是指应用程序执行I-O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务" class="headerlink" title="是指应用程序执行I/O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务"></a>是指应用程序执行I/O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务</h4><p>非阻塞I/O，是指应用程序执行I/O操作后，不会阻塞当前的线程，可以继续执行其他的人物，随后再通过轮询或者事件通知的形式，获取调用的结果<br>比如访问管道或者网络套接字时，设置O_NONBLOCK标志，就表示用非阻塞方式访问，默认是阻塞访问</p>
<h4 id="根据是否等待响应结果，可以把文件I-O分为同步和异步I-O"><a href="#根据是否等待响应结果，可以把文件I-O分为同步和异步I-O" class="headerlink" title="根据是否等待响应结果，可以把文件I/O分为同步和异步I/O"></a>根据是否等待响应结果，可以把文件I/O分为同步和异步I/O</h4><p>同步I/O，是指应用程序执行I/O操作后，要一直等到整个I/O完成后，才能获得I/O响应<br>异步I/O，是指应用程序执行I/O操作后，不用等待完成和完成后的响应，而是继续执行就可以，等到这次I/O完成后，响应会用事件通知的方式，告诉应用程序</p>
<h4 id="顺序访问-Sequential-Access-amp-随机访问-Random-Access"><a href="#顺序访问-Sequential-Access-amp-随机访问-Random-Access" class="headerlink" title="顺序访问(Sequential Access)&amp;随机访问(Random Access)"></a>顺序访问(Sequential Access)&amp;随机访问(Random Access)</h4><p>连续和随机，取决于本次IO的初始扇区地址，和上一次IO的结束扇区地址是否连续。如果是，则本次IO是一个连续IO；如果不连续，算一次随机IO。</p>
<ul>
<li>连续IO：因为本次初始扇区和上次结束扇区相隔很近，则磁头几乎不用换道或换道时间极短；</li>
<li>随机IO：磁头需要很长的换道时间，如果随机IO很多，导致磁头不停换道，效率会大大降底</li>
</ul>
<h3 id="磁盘预读-read-ahead"><a href="#磁盘预读-read-ahead" class="headerlink" title="磁盘预读(read ahead)"></a>磁盘预读(read ahead)</h3><h3 id="write-back、write-through、page-cache"><a href="#write-back、write-through、page-cache" class="headerlink" title="write back、write through、page cache"></a>write back、write through、page cache</h3><h3 id="读写过程中的数据拷贝（zero-copy）"><a href="#读写过程中的数据拷贝（zero-copy）" class="headerlink" title="读写过程中的数据拷贝（zero-copy）"></a>读写过程中的数据拷贝（zero-copy）</h3><p>整个过程有几次拷贝？从磁盘到Page Cache算第一次的话，从Page Cache到用户态buffer就是第二次了。</p>
<p>而mmap(2)做了什么？mmap(2)直接把Page Cache映射到了用户态的地址空间里了，所以mmap(2)的方式读文件是没有第二次拷贝过程的。</p>
<p>那Direct IO做了什么？这个机制更狠，直接让用户态和块IO层对接，直接放弃Page Cache，从磁盘直接和用户态拷贝数据。好处是什么？写操作直接映射进程的buffer到磁盘扇区，以DMA的方式传输数据，减少了原本需要到Page Cache层的一次拷贝，提升了写的效率。对于读而言，第一次肯定也是快于传统的方式的，但是之后的读就不如传统方式了（当然也可以在用户态自己做Cache，有些商用数据库就是这么做的）。</p>
<blockquote>
<p>除了传统的Buffered IO可以比较自由的用偏移+长度的方式读写文件之外，mmap(2)和Direct IO均有数据按页对齐的要求，Direct IO还限制读写必须是底层存储设备块大小的整数倍（甚至Linux 2.4还要求是文件系统逻辑块的整数倍）。所以接口越来越底层，换来表面上的效率提升的背后，需要在应用程序这一层做更多的事情。所以想用好这些高级特性，除了深刻理解其背后的机制之外，也要在系统设计上下一番功夫。</p>
</blockquote>
<h3 id="顺序IO模式-Queue-Mode-并发IO模式-Burst-Mode"><a href="#顺序IO模式-Queue-Mode-并发IO模式-Burst-Mode" class="headerlink" title="顺序IO模式(Queue Mode)/并发IO模式(Burst Mode)"></a>顺序IO模式(Queue Mode)/并发IO模式(Burst Mode)</h3><p>磁盘控制器可能会一次对磁盘组发出一连串的IO命令，如果磁盘组一次只能执行一个IO命令时称为顺序IO;当磁盘组能同时执行多个IO命令时，称为并发IO。</p>
<p>并发IO只能发生在由多个磁盘组成的磁盘组上，单块磁盘只能一次处理一个IO命令。</p>
<h3 id="缺页中断（Page-Fault）"><a href="#缺页中断（Page-Fault）" class="headerlink" title="缺页中断（Page Fault）"></a>缺页中断（Page Fault）</h3><h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><ol>
<li>提高IO效率原则： 顺序写，随机读</li>
<li>重点监控 rkB/s 和 和 wkB/s</li>
<li>%util接近100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈</li>
<li>await与svctm相差很大的时候，要注意磁盘的IO性能。差值越小，说明队列时间越短，反之则队列时间越长。说明系统出了问题。</li>
</ol>
<p>规避IO负载过高：</p>
<ul>
<li>如果服务器用来做日志分析，注意随机读和顺序写，避免定期的压缩、解压大日志。</li>
<li>如果是前端应用服务器，要避免程序频繁打本地日志、或者异常日志</li>
<li>如果是存储服务（mysql、nosql），尽量将服务部署在单独的节点上，做读写分离降低压力</li>
</ul>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ol>
<li><a href="https://www.cnblogs.com/muahao/p/6596545.html" target="_blank" rel="noopener">https://www.cnblogs.com/muahao/p/6596545.html</a></li>
<li><a href="https://testerhome.com/articles/21493" target="_blank" rel="noopener">https://testerhome.com/articles/21493</a></li>
<li><a href="http://blog.chinaunix.net/uid-667478-id-2384354.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-667478-id-2384354.html</a></li>
<li><a href="http://www.0xffffff.org/2017/05/01/41-linux-io/" target="_blank" rel="noopener">http://www.0xffffff.org/2017/05/01/41-linux-io/</a></li>
<li><a href="https://blog.csdn.net/hixiaoxiaoniao/article/details/86295712" target="_blank" rel="noopener">https://blog.csdn.net/hixiaoxiaoniao/article/details/86295712</a></li>
</ol>
<hr>
<h1 id="IO栈及各层功能"><a href="#IO栈及各层功能" class="headerlink" title="IO栈及各层功能"></a>IO栈及各层功能</h1><p>上文【图3】中可以看到，IO行为依次经历“应用层”、“内核层”、“块层”、“设备层”和磁盘交互。按照下图将这个层次再进一步的划分下：“文件系统层”（包含“VFS”、“Page Cache”）、“Block层”（包含“device mapper”）、“device层”</p>
<ul>
<li>文件系统层，以 write(2) 为例，内核拷贝了write(2)参数指定的用户态数据到文件系统Cache中，并适时向下层同步</li>
<li>块层，管理块设备的IO队列，对IO请求进行合并、排序（还记得操作系统课程学习过的IO调度算法吗？）</li>
<li>设备层，通过DMA与内存直接交互，完成数据和具体设备之间的交互</li>
</ul>
<p><img src="https://wangxin201492.github.io/techImages/linux-io-stack-overview-detail.png" alt="linux-io-stack-overview-detail.png"></p>
<h2 id="文件系统层"><a href="#文件系统层" class="headerlink" title="文件系统层"></a>文件系统层</h2><h3 id="缺页中断-–-page-fault"><a href="#缺页中断-–-page-fault" class="headerlink" title="缺页中断 – page fault"></a>缺页中断 – page fault</h3><p>当程序启动的时候，Linux 内核首先检查 CPU 的缓存和物理内存，如果数据已经在内存里就忽略，如果数据不在内存里就引起一个<strong>缺页中断（Page Fault）</strong>，然后从硬盘读取缺页，并把缺页缓存到物理内存里。<br>缺页中断可分为主缺页中断（Major Page Fault）和次缺页中断（Minor Page Fault）</p>
<ul>
<li>要从磁盘读取数据而产生的中断是主缺页中断</li>
<li>数据已经被读入内存并被缓存起来，从内存缓存区中而不是直接从硬盘中读取数据而产生的中断是次 缺页中断(page cache?)</li>
</ul>
<h3 id="磁盘预读-–-read-ahead"><a href="#磁盘预读-–-read-ahead" class="headerlink" title="磁盘预读 – read ahead"></a>磁盘预读 – read ahead</h3><h4 id="顺序性检测"><a href="#顺序性检测" class="headerlink" title="顺序性检测"></a>顺序性检测</h4><p>为了保证预读命中率，Linux只对顺序读(sequential read)进行预读。内核通过验证如下两个条件来判定一个read()是否顺序读：</p>
<ol>
<li>这是文件被打开后的第一次读，并且读的是文件首部；</li>
<li>当前的读请求与前一（记录的）读请求在文件内的位置是连续的。</li>
</ol>
<p>如果不满足上述顺序性条件，就判定为随机读</p>
<h4 id="预读的大小"><a href="#预读的大小" class="headerlink" title="预读的大小"></a>预读的大小</h4><p>Linux采用了一个快速的窗口扩张过程：</p>
<ul>
<li>首次预读： readahead_size = read_size * 2; // or *4</li>
<li>后续预读： readahead_size *= 2;<ul>
<li>后续的预读窗口将逐次倍增，直到达到系统设定的最大预读大小，其缺省值是128KB。</li>
<li>调整大小：blockdev –setra 2048 /dev/sda</li>
</ul>
</li>
</ul>
<h3 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h3><p>page cache有三种类型：</p>
<ol>
<li>Read pages只读页（或代码页）<ul>
<li>那些通过主缺页中断从硬盘读取的页面，包括不能修改的静态文件、可执行文件、库文件等。当内核需要它们的时候把它们读到 内存中，当内存不足的时候，内核就释放它们到空闲列表，当程序再次需要它们的时候需要通过缺页中断再次读到内存。</li>
</ul>
</li>
<li>Dirty pages，脏页<ul>
<li>指那些在内存中被修改过的数据页，比如文本文件等。这些文件由 pdflush 负责同步到硬盘，内存不足的时候由 kswapd 和 pdflush 把数据写回硬盘并释放内存。</li>
</ul>
</li>
<li>Anonymous pages，匿名页<ul>
<li>那些属于某个进程但是又和任何文件无关联，不能被同步到硬盘上，内存不足的时候由 kswapd 负责将它们写到交换分区并释放内存。</li>
</ul>
</li>
</ol>
<h3 id="Write-Through（写穿）和Write-back（写回）-–-page-cache同步"><a href="#Write-Through（写穿）和Write-back（写回）-–-page-cache同步" class="headerlink" title="Write Through（写穿）和Write back（写回） – page cache同步"></a>Write Through（写穿）和Write back（写回） – page cache同步</h3><p>广义上Cache的同步方式有两种，即Write Through（写穿）和Write back（写回）. 从名字上就能看出这两种方式都是从写操作的不同处理方式引出的概念（纯读的话就不存在Cache一致性了，不是么）。对应到Linux的Page Cache上</p>
<ul>
<li>Write Through就是指write(2)操作将数据拷贝到Page Cache后立即和下层进行同步的写操作，完成下层的更新后才返回。</li>
<li>而Write back正好相反，指的是写完Page Cache就可以返回了。Page Cache到下层的更新操作是异步进行的。</li>
</ul>
<p>Linux下Buffered IO默认使用的是Write back机制，即文件操作的写只写到Page Cache就返回，之后Page Cache到磁盘的更新操作是异步进行的。Page Cache中被修改的内存页称之为脏页（Dirty Page），脏页在特定的时候被一个叫做pdflush(Page Dirty Flush)的内核线程写入磁盘，写入的时机和条件如下：</p>
<p>当空闲内存低于一个特定的阈值时，内核必须将脏页写回磁盘，以便释放内存。<br>当脏页在内存中驻留时间超过一个特定的阈值时，内核必须将超时的脏页写回磁盘。<br>用户进程调用sync(2)、fsync(2)、fdatasync(2)系统调用时，内核会执行相应的写回操作。<br>刷新策略由以下几个参数决定（数值单位均为1/100秒）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># flush每隔5秒执行一次</span><br><span class="line">root@082caa3dfb1d &#x2F; $ sysctl vm.dirty_writeback_centisecs</span><br><span class="line">vm.dirty_writeback_centisecs &#x3D; 500</span><br><span class="line"># 内存中驻留30秒以上的脏数据将由flush在下一次执行时写入磁盘</span><br><span class="line">root@082caa3dfb1d &#x2F; $ sysctl vm.dirty_expire_centisecs</span><br><span class="line">vm.dirty_expire_centisecs &#x3D; 3000</span><br><span class="line"># 若脏页占总物理内存10％以上，则触发flush把脏数据写回磁盘</span><br><span class="line">root@082caa3dfb1d &#x2F; $ sysctl vm.dirty_background_ratio</span><br><span class="line">vm.dirty_background_ratio &#x3D; 10</span><br></pre></td></tr></table></figure>

<p>默认是写回方式，如果想指定某个文件是写穿方式呢？即写操作的可靠性压倒效率的时候，能否做到呢？当然能，除了之前提到的fsync(2)之类的系统调用外，在open(2)打开文件时，传入O_SYNC这个flag即可实现。这里给篇参考文章[5]，不再赘述（更好的选择是去读TLPI相关章节）。</p>
<p>文件读写遭遇断电时，数据还安全吗？相信你有自己的答案了。使用O_SYNC或者fsync(2)刷新文件就能保证安全吗？现代磁盘一般都内置了缓存，代码层面上也只能讲数据刷新到磁盘的缓存了。当数据已经进入到磁盘的高速缓存时断电了会怎么样？这个恐怕不能一概而论了。不过可以使用hdparm -W0命令关掉这个缓存，相应的，磁盘性能必然会降低。</p>
<h3 id="文件系统与inode"><a href="#文件系统与inode" class="headerlink" title="文件系统与inode"></a>文件系统与inode</h3><p><img src="https://wangxin201492.github.io/techImages/linux-filesystem-inode.png" alt="linux-filesystem-inode.png"></p>
<p>应用程序在访问文件时都会先打开文件，在内核中，对应每个进程，都会有一个文件描述符表表示这个进程打开的文件，但是用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引（一个整数），这些索引就被称为文件描述符。当调用open 打开一个文件或创建一个新文件时,内核分配一个文件描述符并返回给用户程序,该文件描述符表项中的指针指向新打开的文件。</p>
<p>文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块–file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程。</p>
<p>file对象中包含一个指针，指向dentry对象。dentry对象代表一个独立的文件路径，如果一个文件路径被打开多次，那么会建立多个file对象，但它们都指向同一个dentry对象。inode对象代表一个独立文件，inode 对象包含了最终对文件进行操作所需的所有信息，如文件系统类型、文件的操作方法、文件的权限、访问日期等。</p>
<h3 id="文件系统磁盘布局"><a href="#文件系统磁盘布局" class="headerlink" title="文件系统磁盘布局"></a>文件系统磁盘布局</h3><p><img src="https://wangxin201492.github.io/techImages/linux-filesystem-ext-blocks.png" alt="linux-filesystem-ext-blocks.png"></p>
<p>ext3文件系统将其所管理的磁盘或者分区(引导块除外)中的块划分到不同的块组中。每个块组大小相同，当然最后一个块组所管理的块可能会少一些，其大小在文件系统创建时决定，主要取决于文件系统的块大小。每个块组包含一个块位图块，一个inode位图块，一个或多个块用于描述 inode 表和用于存储文件数据的数据块，除此之外，还有可能包含超级块和所有块组描述符表。<br>块位图用于描述该块组所管理的块的分配状态，如果某个块对应的位未置位，那么代表该块未分配，可以进行分配使用。inode位图用于描述该块组所管理的inode的分配状态，每个inode对应文件系统中唯一的一个号，如果inode位图中相应位置位，那么代表该inode已经分配出去；否则可以使用。</p>
<h3 id="日志文件系统和非日志文件系统"><a href="#日志文件系统和非日志文件系统" class="headerlink" title="日志文件系统和非日志文件系统"></a>日志文件系统和非日志文件系统</h3><p>文件内容的修改涉及到两部分：实际文件内容的修改 和 文件元(metadata)信息的修改。所以在修改一个成功之后，修改另一个之前，此时系统崩溃，就会导致两者的不一致。所以提出了日志文件系统的概念。</p>
<p>所谓的日志文件系统(Journaling file system)，就是在实际修改文件内容和文件元信息之前，将他们的修改先写到一个日志中(journal log)。这样的话，如果发生系统崩溃，就可以使用日志进行恢复。当然，写日志会对文件系统的性能有一定的影响。除了ext2之外，其它文件系统几乎都是日志文件系统。</p>
<p>日志文件系统的处理过程是：1）先写日志；2）然后写实际的文件系统；3）删除日志；</p>
<p>日志文件系统又可以分成三种类型：</p>
<ol>
<li>日志模式(journal): 将所有的元数据和数据改变均写入日志，对性能影响最大；</li>
<li>预定模式(ordered): 只记录元数据的变化, 在数据写入磁盘后再修改元数据，对性能影响中等；</li>
<li>写回模式(writeback): 只记录元数据的修改变化，对数据修改顺序无要求，对性能影响最小；</li>
</ol>
<p>我们可以在/etc/fstab 文件中修改文件系统的日志模式。<br>/dev/sdb1 /testfs ext3 defaults,data=writeback 0 0</p>
<h3 id="相关阅读-1"><a href="#相关阅读-1" class="headerlink" title="相关阅读"></a>相关阅读</h3><ol>
<li><a href="http://www.sysnote.org/2015/08/06/fs-io-map/" target="_blank" rel="noopener">http://www.sysnote.org/2015/08/06/fs-io-map/</a></li>
<li><a href="http://oliveryang.net/2016/05/linux-file-system-basic-4/" target="_blank" rel="noopener">http://oliveryang.net/2016/05/linux-file-system-basic-4/</a></li>
<li><a href="https://www.cnblogs.com/digdeep/p/4857987.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4857987.html</a></li>
</ol>
<h2 id="Block层"><a href="#Block层" class="headerlink" title="Block层"></a>Block层</h2><h3 id="block-IO"><a href="#block-IO" class="headerlink" title="block IO"></a>block IO</h3><p>一个I/O请求进入block layer之后，可能会经历下面的过程：</p>
<ul>
<li>Remap: 可能被DM(Device Mapper)或MD(Multiple Device, Software RAID) remap到其它设备</li>
<li>Split: 可能会因为I/O请求与扇区边界未对齐、或者size太大而被分拆(split)成多个物理I/O</li>
<li>Merge: 可能会因为与其它I/O请求的物理位置相邻而合并(merge)成一个I/O</li>
<li>被IO Scheduler依照调度策略发送给driver</li>
<li>被driver提交给硬件，经过HBA、电缆（光纤、网线等）、交换机（SAN或网络）、最后到达存储设备，设备完成IO请求之后再把结果发回。</li>
</ul>
<h3 id="device-mapper层"><a href="#device-mapper层" class="headerlink" title="device mapper层"></a>device mapper层</h3><h2 id="device层"><a href="#device层" class="headerlink" title="device层"></a>device层</h2><h3 id="机械磁盘基本结构"><a href="#机械磁盘基本结构" class="headerlink" title="机械磁盘基本结构"></a>机械磁盘基本结构</h3><p><img src="https://wangxin201492.github.io/techImages/linux-disk-HDD-overview.png" alt="linux-disk-HDD-overview.png"><br>硬盘由三部分组成，物理结构，数据结构，存储容量</p>
<ul>
<li>数据结构:<ul>
<li>扇区：磁盘上每个磁道被分为若干个弧段，这些弧段便是硬盘的扇区。硬盘的第一个扇区，叫做引导扇区。</li>
<li>磁道：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹 叫做磁道</li>
</ul>
</li>
<li>物理结构<ul>
<li>盘片：硬盘有多个盘片，每个盘片有2面。</li>
<li>磁头：每面一个磁头</li>
</ul>
</li>
<li>存储容量 = 磁头数<em>磁道数</em>每道扇区数*每扇区字节数</li>
</ul>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>固态硬盘(Solid State Disk)，通常缩写为SSD，由固态电子元器件组成，固态磁盘不需要磁道寻址，所以不管是连续I/O，还是随机I/O的性能，都比机械磁盘要好得多</p>
<h4 id="机械硬盘-amp-固态硬盘"><a href="#机械硬盘-amp-固态硬盘" class="headerlink" title="机械硬盘&amp;固态硬盘"></a>机械硬盘&amp;固态硬盘</h4><p>无论机械盘还是固态磁盘，相同磁盘的随机I/O都要比连续I/O慢很多</p>
<ul>
<li>对机械磁盘来说，由于随机I/O需要更多的磁头晕倒和盘片旋转，它的性能自然比连续I/O慢</li>
<li>对于固态磁盘，虽然它的随机性能比机械硬盘好很多，但同样存在“先擦除再写入”的限制，随机读写会导致大量的垃圾回收，导致随机I/O的性能比连续I/O还是差了很多</li>
<li>连续I/O还可以通过预读取的方式，来减少I/O请求的次数，这也是其性能优异的一个原因，很多性能优化的方案，都会从这个角度出发，来优化I/O性能</li>
</ul>
<p>机械磁盘和固态硬盘还有一个最小的读写单位</p>
<ul>
<li>机械磁盘的最小读写单位是扇区，一般为512字节</li>
<li>固态硬盘的最小读写单位是页，通常大小是4KB，8KB等</li>
</ul>
<p>由于每次读写512字节这么小的单位效率很低，所以文件系统会把连续的扇区，组成逻辑块，然后以逻辑快作为最小单位来管理数据，常见的逻辑块大小是4KB，也就是连续8个扇区，或者一个独立的页，都可以组成一个逻辑块</p>
<h3 id="磁盘读取数据花费的时间"><a href="#磁盘读取数据花费的时间" class="headerlink" title="磁盘读取数据花费的时间"></a>磁盘读取数据花费的时间</h3><h4 id="寻道时间"><a href="#寻道时间" class="headerlink" title="寻道时间"></a>寻道时间</h4><p>磁盘的驱动臂(Actuator Arm)带读写磁头(Head)离开着陆区(Landing Zone，位于内圈没有数据的区域)，移动到要操作的初始数据块所在的磁道(Track)的正上方，这个过程被称为寻址(Seeking)，对应消耗的时间被称为寻址时间(Seek Time)</p>
<p>考虑到被读写的数据可能在磁盘的任意一个磁道，既有可能在磁盘的最内圈(寻址时间最短)，也可能在磁盘的最外圈(寻址时间最长)，所以在计算中我们只考虑平均寻址时间，也就是磁盘参数中标明的那个平均寻址时间，这里就采用当前最多的10krmp硬盘的5ms。</p>
<p>目前磁盘的平均寻道时间一般在3－15ms。</p>
<h4 id="旋转延迟"><a href="#旋转延迟" class="headerlink" title="旋转延迟"></a>旋转延迟</h4><p>但是找到对应磁道还不能马上读取数据，这时候磁头要等到磁盘盘片(Platter)旋转到初始数据块所在的扇区(Sector)落在读写磁头正上方的之后才能开始读取数据，在这个等待盘片旋转到可操作扇区的过程中消耗的时间称为旋转延时(Rotational Delay)</p>
<p>和寻址一样，当磁头定位到磁道之后有可能正好在要读写扇区之上，这时候是不需要额外额延时就可以立刻读写到数据，但是最坏的情况确实要磁盘旋转整整一圈之后磁头才能读取到数据，所以这里我们也考虑的是平均旋转延时，对于10krpm的磁盘就是(60s/15k)*(1/2) = 2ms。</p>
<h4 id="数据传输时间"><a href="#数据传输时间" class="headerlink" title="数据传输时间"></a>数据传输时间</h4><p>接下来就随着盘片的旋转，磁头不断的读/写相应的数据块，直到完成这次IO所需要操作的全部数据，这个过程称为数据传送(Data Transfer)，对应的时间称为传送时间(Transfer Time)</p>
<p>磁盘参数提供我们的最大的传输速度，当然要达到这种速度是很有难度的，但是这个速度却是磁盘纯读写磁盘的速度，因此只要给定了单次 IO的大小，我们就知道磁盘需要花费多少时间在数据传送上，这个时间就是IO Chunk Size / Max Transfer Rate。</p>
<p>目前IDE/ATA能达到133MB/s，SATA II可达到300MB/s的接口数据传输率</p>
<h3 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h3><h4 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h4><blockquote>
<p>在windows下叫做簇，在linux下如ext4系统中成为块(block)</p>
</blockquote>
<p>块是操作系统中最小的逻辑存储单位(虚拟出来的)，操作系统与磁盘打交道的最小单位是磁盘块，每个块可以包括2、4、8、16、32、64…2的n次方个扇区</p>
<p>优点：</p>
<ol>
<li>读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作</li>
<li>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位</li>
</ol>
<h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p>
<p>获取方式：<code>/usr/bin/time -v data</code></p>
<h4 id="扇区、块-簇、page的关系"><a href="#扇区、块-簇、page的关系" class="headerlink" title="扇区、块/簇、page的关系"></a>扇区、块/簇、page的关系</h4><ol>
<li>扇区： 硬盘的最小读写单元</li>
<li>块/簇： 是操作系统针对硬盘读写的最小单元</li>
<li>page： 是内存与操作系统之间操作的最小单元</li>
</ol>
<p>大小关系：扇区 &lt;= 块/簇 &lt;= page</p>
<p>目前接触到的扇区一般为512B，块为4KB，page为4KB</p>
<h3 id="磁盘类型一些名词区分"><a href="#磁盘类型一些名词区分" class="headerlink" title="磁盘类型一些名词区分"></a>磁盘类型一些名词区分</h3><h4 id="尺寸外形"><a href="#尺寸外形" class="headerlink" title="尺寸外形"></a>尺寸外形</h4><p>也就是设备的形状和大小，通常存储设备的尺寸外形包括如下：</p>
<ul>
<li>2.5寸或者3.5寸驱动器（在SFF标准中定义）</li>
<li>M.2 和 PCI Express（PCIe）（在PCI-SIG标准中定义）</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>也就是设备如何与计算机通信。常见的存储设备接口包括：</p>
<ul>
<li>SATA接口，通常用于2.5寸和3.5寸硬盘，有时候一些M.2设备也会使用</li>
<li>PCI Express(PCIe)接口， 用于M.2和PCIe设备</li>
<li>SAS（串行SCSI）和FC（Fibre Channel）接口</li>
</ul>
<p>仅用于服务器领域和数据中心 PCIe接口要比SATA接口快的多，SATA3最大带宽是6Gb/s，而基于4X PCIe的M.2接口最大可以达到32Gb/s。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>定义了如何在计算机与设备之间传输数据。常见的协议包括：</p>
<ul>
<li>用于SATA接口的AHCI或者ATA协议</li>
<li>用于PCIe接口的NVMe协议</li>
</ul>
<h4 id="为什么NVMe会这么快"><a href="#为什么NVMe会这么快" class="headerlink" title="为什么NVMe会这么快"></a>为什么NVMe会这么快</h4><blockquote>
<p>这里说的快是基于SSD设备的，如果是机械硬盘则不然</p>
</blockquote>
<p>由于SSD本身的物理特性，其数据的访问已经非常快了，性能的瓶颈就是出在计算机与设备连接的接口和协议上面。 </p>
<ul>
<li>对于SATA的SSD，类似于一个单臂的机器人，仓库生产的很快，但机器人每次只能拿一个，搬移的速度就比较慢。</li>
<li>然而对于基于NVMe的SSD，相当于这个机器人长了数百只手，这样速度显然就比前者快的多了。</li>
</ul>
<h3 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h3><p>IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。</p>
<h4 id="IOPS计算方法"><a href="#IOPS计算方法" class="headerlink" title="IOPS计算方法"></a>IOPS计算方法</h4><p>传统磁盘本质上一种机械装置，如FC, SAS, SATA磁盘，转速通常为5400/7200/10K/15K rpm不等。影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个I/O请求所花费的时间，它由<code>寻道时间</code>、<code>旋转延迟</code>和<code>数据传输时间</code>三部分构成。</p>
<p>理论上可以计算出磁盘的最大IOPS，即<code>IOPS = 1000 ms/ (Tseek + Troatation)</code>，忽略数据传输时间。假设磁盘平均物理寻道时间为3ms, 磁盘转速为7200,10K,15K rpm，则磁盘IOPS理论最大值分别为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;7200&#x2F;2)  &#x3D; 140</span><br><span class="line">IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;10000&#x2F;2) &#x3D; 167</span><br><span class="line">IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;15000&#x2F;2) &#x3D; 200</span><br></pre></td></tr></table></figure>

<p>固态硬盘SSD是一种电子装置， 避免了传统磁盘在寻道和旋转上的时间花费，存储单元寻址开销大大降低，因此IOPS可以非常高，能够达到数万甚至数十万。</p>
<h3 id="传输速度-Transfer-Rate-吞吐率-Throughput"><a href="#传输速度-Transfer-Rate-吞吐率-Throughput" class="headerlink" title="传输速度(Transfer Rate)/吞吐率(Throughput)"></a>传输速度(Transfer Rate)/吞吐率(Throughput)</h3><p>现在我们要说的传输速度(另一个常见的说法是吞吐率)不是磁盘上所表明的最大传输速度或者说理想传输速度，而是磁盘在实际使用的时候从磁盘系统总线上流过的数据量。有了IOPS数据之后我们是很容易就能计算出对应的传输速度来的</p>
<p><img src="https://wangxin201492.github.io/techImages/linux-io-size-effect-iops.png" alt="linux-io-size-effect-iops.png"></p>
<p>这里一定要明确一个概念，那就是尽管上面我们使用IOPS来计算传输速度，但是实际上传输速度和IOPS是没有直接关系，在没有缓存的情况下它们共同的决定因素都是对磁盘系统的访问方式以及单个IO的大小。</p>
<p>对磁盘进行随机访问时候我们可以利用IOPS来衡量一个磁盘系统的性能，此时的传输速度不会太大;但是当对磁盘进行连续访问时，此时的IOPS已经没有了参考的价值，这个时候限制实际传输速度却是磁盘的最大传输速度。</p>
<p>因此在实际的应用当中，<strong>只会用IOPS来衡量小IO的随机读写的性能，而当要衡量大IO连续读写的性能的时候就要采用传输速度而不能是IOPS了</strong></p>
<h2 id="相关阅读-2"><a href="#相关阅读-2" class="headerlink" title="相关阅读"></a>相关阅读</h2><ol>
<li><a href="https://blog.51cto.com/14449536/2431772" target="_blank" rel="noopener">https://blog.51cto.com/14449536/2431772</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/71932170" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71932170</a></li>
<li><a href="https://www.cnblogs.com/muahao/p/6596545.html" target="_blank" rel="noopener">https://www.cnblogs.com/muahao/p/6596545.html</a></li>
</ol>
<h3 id="内核代码分析"><a href="#内核代码分析" class="headerlink" title="内核代码分析"></a>内核代码分析</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/56823442" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56823442</a></li>
<li><a href="https://www.codeleading.com/article/22651695474/" target="_blank" rel="noopener">https://www.codeleading.com/article/22651695474/</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html</a></li>
<li><a href="http://oenhan.com/ext3-fs-directio" target="_blank" rel="noopener">http://oenhan.com/ext3-fs-directio</a></li>
<li><a href="http://oenhan.com/linux-kernel-read" target="_blank" rel="noopener">http://oenhan.com/linux-kernel-read</a></li>
</ol>
<hr>
<h2 id="IO监控工具"><a href="#IO监控工具" class="headerlink" title="IO监控工具"></a>IO监控工具</h2><p><img src="https://wangxin201492.github.io/techImages/linux-io-utils.png" alt="linux-io-utils.png"></p>
<h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>常用<code>iostat -dx 1 100</code>。iostat(1)和sar(1)都没有指标可以衡量硬盘设备的性能，这是因为它们所依赖的/proc/diskstats不提供这项数据</p>
<ul>
<li>IOPS：r/s &amp; w/s</li>
<li>带宽：rkB/s &amp; wkB/s</li>
<li>IO合并：rrqm/s &amp; wrqm/s。如果两个I/O操作发生在相邻的数据块时，它们可以被合并成一个，以提高效率，合并的操作通常是I/O scheduler（也叫elevator）负责的</li>
<li>avgrq-sz：每个I/O的平均扇区数</li>
<li>avgqu-sz：平均未完成的I/O请求数量（手册上说是队列里的平均I/O请求数量，更恰当的理解应该是平均未完成的I/O请求数量。）</li>
<li>svctm：已被废弃的指标，没什么意义，svctm=[util/tput]。iostat(1)和sar(1)的man page上都说了不要相信svctm，该指标将被废弃</li>
<li>%util：该硬盘设备的繁忙比率。表示该设备有I/O（即非空闲）的时间比率，不考虑I/O有多少，只考虑有没有。由于现代硬盘设备都有并行处理多个I/O请求的能力，所以%util即使达到100%也不意味着设备饱和了<ul>
<li>某硬盘处理单个I/O需要0.1秒，有能力同时处理10个I/O请求，那么当10个I/O请求依次顺序提交的时候，需要1秒才能全部完成，在1秒的采样周期里%util达到100%；而如果10个I/O请求一次性提交的话，0.1秒就全部完成，在1秒的采样周期里%util只有10%。可见，即使%util高达100%，硬盘也仍然有可能还有余力处理更多的I/O请求，即没有达到饱和状态</li>
</ul>
</li>
</ul>
<h3 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h3><p>这两个命令,都可以按进程统计IO状况,因此可以回答你以下二个问题</p>
<p>当前系统哪些进程在占用IO,百分比是多少?<br>占用IO的进程是在读?还是在写?读写量是多少?</p>
<h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u -r -d -t 1        </span><br><span class="line"># -d IO 信息,</span><br><span class="line"># -r 缺页及内存信息</span><br><span class="line"># -u CPU使用率</span><br><span class="line"># -t 以线程为统计单位</span><br><span class="line"># 1  1秒统计一次</span><br></pre></td></tr></table></figure>

<h3 id="block-dump-iodump"><a href="#block-dump-iodump" class="headerlink" title="block_dump, iodump"></a>block_dump, iodump</h3><p>iotop和 pidstat 用着很爽,但两者都依赖于/proc/pid/io文件导出的统计信息, 这个对于老一些的内核是没有的.因此只好用以上2个穷人版命令</p>
<h3 id="ioprofile"><a href="#ioprofile" class="headerlink" title="ioprofile"></a>ioprofile</h3><p>ioprofile 命令本质上是 lsof + strace, 具体下载可见 <a href="http://code.google.com/p/maatkit/" target="_blank" rel="noopener">http://code.google.com/p/maatkit/</a></p>
<p>ioprofile 可以回答你以下三个问题:</p>
<ul>
<li>当前进程某时间内,在业务层面读写了哪些文件(read, write)？</li>
<li>读写次数是多少?(read, write的调用次数)</li>
<li>读写数据量多少?(read, write的byte数)</li>
</ul>
<p>假设某个行为会触发程序一次IO动作,例如: “一个页面点击,导致后台读取A,B,C文件”<br>./io_event # 假设模拟一次IO行为,读取A文件一次, B文件500次, C文件500次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ioprofile  -p  &#96;pidof  io_event&#96; -c count   # 读写次数</span><br><span class="line">ioprofile  -p  &#96;pidof  io_event&#96; -c times   # 读写耗时</span><br><span class="line">ioprofile  -p  &#96;pidof  io_event&#96; -c sizes    # 读写大小</span><br></pre></td></tr></table></figure>

<h3 id="相关阅读-3"><a href="#相关阅读-3" class="headerlink" title="相关阅读"></a>相关阅读</h3><ol>
<li><a href="https://www.cnblogs.com/muahao/p/6564745.html" target="_blank" rel="noopener">https://www.cnblogs.com/muahao/p/6564745.html</a></li>
<li><a href="http://linuxperf.com/?p=156" target="_blank" rel="noopener">http://linuxperf.com/?p=156</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/shell/shell-and-subshell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shell/shell-and-subshell/" itemprop="url">【shell】shell与子shell那团乱麻</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-16T20:01:48+08:00">
                2015-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-fork-amp-source-amp-exec"><a href="#1-fork-amp-source-amp-exec" class="headerlink" title="1. fork &amp; source &amp; exec"></a>1. <code>fork</code> &amp; <code>source</code> &amp; <code>exec</code></h2><p>在运行shell脚本时候，有三种方式来调用外部的脚本，<code>exec(exec script.sh)</code>、<code>source(source script.sh)</code>、<code>fork(./script.sh)</code></p>
<h3 id="1-1-exec（exec-home-script-sh）："><a href="#1-1-exec（exec-home-script-sh）：" class="headerlink" title="1.1. exec（exec /home/script.sh）："></a>1.1. exec（exec /home/script.sh）：</h3><p>使用<code>exec</code>来调用脚本，被执行的脚本会继承当前shell的环境变量。<strong>但事实上<code>exec</code>产生了新的进程，他会把主shell的进程资源占用并替换脚本内容，继承了原主shell的PID号，即原主shell剩下的内容不会执行。</strong></p>
<h3 id="1-2-source（source-home-script-sh）"><a href="#1-2-source（source-home-script-sh）" class="headerlink" title="1.2. source（source /home/script.sh）"></a>1.2. source（source /home/script.sh）</h3><p>使用<code>source</code>或者“<code>.</code>”来调用外部脚本，<strong>不会产生新的进程</strong>，继承当前shell环境变量，而且被调用的脚本运行结束后，<strong>它拥有的环境变量和声明变量会被当前shell保留</strong>，类似将调用脚本的内容复制过来直接执行。<strong>执行完毕后原主shell继续运行。</strong></p>
<h3 id="1-3-fork（-home-script-sh）"><a href="#1-3-fork（-home-script-sh）" class="headerlink" title="1.3. fork（/home/script.sh）"></a>1.3. fork（/home/script.sh）</h3><p>直接运行脚本，会<strong>以当前shell为父进程，产生新的进程</strong>，并且<strong>继承主脚本的环境变量和声明变量</strong>。执行完毕后，<strong>主脚本不会保留其环境变量和声明变量</strong>。</p>
<p>总结：这样来看<code>fork</code>最灵活，<code>source</code>次之，<code>exec</code>最诡异。</p>
<h3 id="1-4-example"><a href="#1-4-example" class="headerlink" title="1.4. example"></a>1.4. example</h3><h5 id="主脚本"><a href="#主脚本" class="headerlink" title="主脚本"></a>主脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">a=main</span><br><span class="line"></span><br><span class="line">echo "a is $a"</span><br><span class="line">echo "PID for parent before 2.sh:$$"</span><br><span class="line">case $1 in</span><br><span class="line">  exec)</span><br><span class="line">    echo "using exec"</span><br><span class="line">    exec ./2.sh ;;</span><br><span class="line">  source)</span><br><span class="line">    echo "using sourcing"</span><br><span class="line">    source ./2.sh ;;</span><br><span class="line">  *)</span><br><span class="line">    echo "using fork"</span><br><span class="line">    ./2.sh ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">echo "PID FOR parent after 2.sh :$$"</span><br><span class="line"></span><br><span class="line">echo "now main.sh a is $a"</span><br><span class="line">echo "$b"</span><br></pre></td></tr></table></figure>

<h5 id="调用脚本：2-sh"><a href="#调用脚本：2-sh" class="headerlink" title="调用脚本：2.sh"></a>调用脚本：2.sh</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo "PID FOR 2.SH:$$"</span><br><span class="line"></span><br><span class="line">echo  "2.sh get a from main.sh is $a"</span><br><span class="line"></span><br><span class="line">a=2.sh</span><br><span class="line">export a</span><br><span class="line">b=3.sh</span><br><span class="line"></span><br><span class="line">echo "now 2.sh a is $a"</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./main.sh <span class="built_in">exec</span></span></span><br><span class="line">a is main</span><br><span class="line">PID for parent before 2.sh:19026</span><br><span class="line">using exec</span><br><span class="line">PID FOR 2.SH:19026</span><br><span class="line">2.sh get a from main.sh is main</span><br><span class="line">now a is 2.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./main.sh <span class="built_in">source</span></span></span><br><span class="line">a is main</span><br><span class="line">PID for parent before 2.sh:19027</span><br><span class="line">using sourcing</span><br><span class="line">PID FOR 2.SH:19027</span><br><span class="line">2.sh get a from main.sh is main</span><br><span class="line">now a is 2.sh</span><br><span class="line">PID FOR parent after 2.sh :19027</span><br><span class="line">now main.sh a is 2.sh</span><br><span class="line">3.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./main.sh fork</span></span><br><span class="line">a is main</span><br><span class="line">PID for parent before 2.sh:19028</span><br><span class="line">using fork</span><br><span class="line">PID FOR 2.SH:19029</span><br><span class="line">2.sh get a from main.sh is main</span><br><span class="line">now a is 2.sh</span><br><span class="line">PID FOR parent after 2.sh :19028</span><br><span class="line">now main.sh a is main</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://qujunorz.blog.51cto.com/6378776/1541676" target="_blank" rel="noopener">http://qujunorz.blog.51cto.com/6378776/1541676</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/protocol/TOTP/protocol-TOTP-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/protocol/TOTP/protocol-TOTP-overview/" itemprop="url">【一次性密码】TOTP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-08T20:45:00+08:00">
                2015-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/protocol/" itemprop="url" rel="index">
                    <span itemprop="name">protocol</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/protocol/TOTP/" itemprop="url" rel="index">
                    <span itemprop="name">TOTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-OTP"><a href="#1-OTP" class="headerlink" title="1. OTP"></a>1. OTP</h2><p><code>OTP(One-Time Password)</code>译为一次性密码，也称动态口令。是使用密码技术实现的在客户端和服务器之间通过共享秘密的一种认证技术，是一种强认证技术，是增强目前静态口令认证的一种非常方便技术手段，是一种重要的双因素认证技术。</p>
<h3 id="1-1-OTP的认证原理"><a href="#1-1-OTP的认证原理" class="headerlink" title="1.1 OTP的认证原理"></a>1.1 OTP的认证原理</h3><p>动态口令的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用的同一个种子密钥对某一个事件计数、或时间值、或者是异步挑战数进行密码算法计算，使用的算法有<code>对称算法</code>、<code>HASH</code>、<code>HMAC</code>，之后比较计算值是否一致进行认证。可以做到一次一个动态口令，使用后作废，口令长度通常为6-8个数字，使用方便，与通常的静态口令认证方式类似.</p>
<h3 id="1-3-OTP的实现方式"><a href="#1-3-OTP的实现方式" class="headerlink" title="1.3 OTP的实现方式"></a>1.3 OTP的实现方式</h3><ol>
<li>时间同步(<code>TOTP</code>)</li>
<li>事件同步(<code>HOTP</code>)</li>
<li>挑战/应答(<code>OCRA</code>)</li>
</ol>
<h2 id="2-HOTP"><a href="#2-HOTP" class="headerlink" title="2. HOTP"></a>2. HOTP</h2><p><code>HOTP(HMAC-base On-Time Password)</code>译为基于HMAC的一次性密码，也称事件同步的动态密码。</p>
<h3 id="2-1-HOTP的工作原理"><a href="#2-1-HOTP的工作原理" class="headerlink" title="2.1 HOTP的工作原理"></a>2.1 HOTP的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTOP(K,C) &#x3D; Truncate(HMAC-SHA-1(K,C))</span><br></pre></td></tr></table></figure>


<p>客户端和服务器事先协商好一个<code>密钥K</code>，用于一次性密码的生成过程。此外，客户端和服务器各有一个<code>计数器C</code>，并且事先将计数值同步。而<code>Truncate</code>是为了获得一个符合<code>HTOP</code>要求的值。</p>
<h2 id="3-TOTP"><a href="#3-TOTP" class="headerlink" title="3 TOTP"></a>3 TOTP</h2><p><code>TOTP(Time-base One-Time Password)</code>译为基于时间的一次性密码，也称时间同步的动态密码.</p>
<h3 id="3-1-TOTP的工作原理"><a href="#3-1-TOTP的工作原理" class="headerlink" title="3.1 TOTP的工作原理"></a>3.1 TOTP的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOTP &#x3D; Truncate(HMAC-SHA-1(K,T))</span><br></pre></td></tr></table></figure>

<p><code>TOTP</code>是<code>HOTP</code>的一个变种，将<code>HOTP</code>中的<code>计数器C</code>替换为依托时间的<code>参数T</code>，T是由当前时间(<code>CurrentUnixTime</code>、初始时间(T0)、步长(X)决定的。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T &#x3D; (Current Unix time - T0) &#x2F; X</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CurrentUnixTime</code>：当前的Unix时间。</li>
<li><code>T0</code>： 开始计步初始化时间，默认为0</li>
<li><code>X</code> : 步长，默认情况下为30s</li>
</ul>
<h3 id="3-2-TOTP的要求"><a href="#3-2-TOTP的要求" class="headerlink" title="3.2 TOTP的要求"></a>3.2 TOTP的要求</h3><ol>
<li>客户端和服务器必须能够彼此知道或者推算出对方的Unix Time</li>
<li>客户端和服务器端必须共享一个密钥</li>
<li>算法必须使用HOTP作为其关键实现环节</li>
<li>客户端和服务器端必须使用相同的步长X</li>
<li>每一个客户端必须拥有不同的密钥</li>
<li>密钥的生成必须足够随机</li>
<li>密钥必须储存在防篡改的设备上，而且不能在不安全的情况下被访问或使用。</li>
<li>对该算法中T的实现必须大于<code>int32</code>，因为它在2038年将超出上限。</li>
<li>T0和X的协商必须在之前的步骤中就已经做好了。</li>
</ol>
<h3 id="3-3-安全性考虑"><a href="#3-3-安全性考虑" class="headerlink" title="3.3 安全性考虑"></a>3.3 安全性考虑</h3><h4 id="3-3-1-安全性分析"><a href="#3-3-1-安全性分析" class="headerlink" title="3.3.1 安全性分析"></a>3.3.1 安全性分析</h4><p>该算法的安全性和健壮性完全依赖于其关键实现环节<code>HOTP</code>。</p>
<p>安全性分析的结果是：在所有的测试中，该算法的结果均匀的、独立的分布。这个分析显示，最好的攻击和破解<code>TOTP(HOTP)</code>的方法是暴力破解。而在算法要求环节，要求key必须有足够的随机性。</p>
<h4 id="3-3-2-时延兼容"><a href="#3-3-2-时延兼容" class="headerlink" title="3.3.2 时延兼容"></a>3.3.2 时延兼容</h4><p>在同一个步长内，动态密码生成的结果是一样的。当一个验证系统获得这个动态密码的时候，它并不知道动态密码的生产者是在哪个步长内产生的密码。由于网络的原因，客户端生成密码的时间和服务器接受密码的时间可能差距会很大，很有可能使得这2个时间不在同一个步长内。当一个动态密码产生在一个步长的结尾，服务器收到的密码很有可能在下一个步长的开始。</p>
<p>验证系统应该设置一个策略允许动态密码的传输时延，不应该只验证当前步长的动态密码，还应该验证之前几个步长的动态密码。但越大的传输时延窗口设置，就会带来越大的风险被攻击，我们推荐最多设置一个时延窗口来兼容传输延时。</p>
<h4 id="3-3-3-步长设置"><a href="#3-3-3-步长设置" class="headerlink" title="3.3.3 步长设置"></a>3.3.3 步长设置</h4><p>步长大小的设置，直接影响安全性和可用性:</p>
<ol>
<li>一个越大的步长，就会导致一个越大的窗口被攻击。当一个动态密码被生成而且在其有效期内暴露在第三方环境下，那么第三方系统就可以在该动态密码无效前使用这个密码。</li>
<li>我们推荐默认的步长时间是<code>30s</code>，这个默认值是在权衡了安全性和可用性的基础上提出的。</li>
<li>下一个动态密码肯定会在下一个步长生成，用户必须等待当前步长的结束。这个等待时间的理想值会随着步长的设置而增大。一个太长的窗口设置不使用网络用户登录这种场景，用户可能等不了一个步长的时间，就放弃登录。</li>
</ol>
<blockquote>
<p>参考资料：<br><a href="http://blog.csdn.net/janronehoo/article/details/7590976" target="_blank" rel="noopener">http://blog.csdn.net/janronehoo/article/details/7590976</a><br><a href="http://www.dannysite.com/blog/165/" target="_blank" rel="noopener">http://www.dannysite.com/blog/165/</a><br><a href="https://tools.ietf.org/html/rfc6238" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6238</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/shell/shell-wait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shell/shell-wait/" itemprop="url">【shell】我的wait为什么不能用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-18T20:01:48+08:00">
                2015-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>希望实现这样的一个功能：主脚本会运行几个后台进程，并希望这几个后台进程运行完之后，主进程才会退出。</p>
<p>RT,设想一个文件a，希望a的每一行都表示一个后台进程，有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat a</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>脚本<code>test_wait_1</code>这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> filename:test_wait_1</span></span><br><span class="line"></span><br><span class="line">cat a | while read line</span><br><span class="line">do</span><br><span class="line">    echo $line &amp;</span><br><span class="line">done</span><br><span class="line">wait</span><br><span class="line">echo "wait done"</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#result</span><br><span class="line">$ bash test_wait_1</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">wait done</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>显然，不尽如人意。</p>
<h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>脚本<code>test_wait_2</code>,做了一下修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> filename:test_wait_2</span></span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    echo $line &amp;</span><br><span class="line">done &lt; "a"</span><br><span class="line">wait</span><br><span class="line">echo "wait done"</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bash test_wait_2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">wait done</span><br></pre></td></tr></table></figure>

<p>结果符合预期！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>维基百科中有这样一段话：</p>
<blockquote>
<p>其中n是当前正在执行的后台进程的pid，或工作的工作ID。如果没有给定n，命令会等待shell调用的所有工作终止。</p>
</blockquote>
<blockquote>
<p>wait一般返回最后一个工作的退出状态。如果n所指的工作不存在，或没有工作要等待，它会返回127。</p>
</blockquote>
<blockquote>
<p>因为wait需要知道当前shell执行环境的工作表，它通常为shell内建命令。</p>
</blockquote>
<p>这样看来仿佛<code>test_wait_1</code>中的用法也没有什么问题，但实际上shell的管道<code>|</code>实际上是产生了一级子shell，也就是在<code>test_wait_1</code>中的后台进程<code>echo $line &amp;</code>是主进程子shell的后台进程。而<code>wait</code>只会等待当前进程的后台进程执行完毕，所以<code>test_wait_1</code>在遇到wait语句直接退出了。</p>
<p>而<code>test_wait_2</code>中，通过<code>&lt; &quot;a&quot;</code>将a文件的内容标准输入到<code>while</code>中，并未通过管道输入到<code>while</code>中，所以后台进程属于主进程。wait会等待所有的后台进程完成以后退出，</p>
<p>这也就是<code>test_wait_1</code>和<code>test_wait_2</code>这2个脚本运行的不同之处。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/Wait_(%E5%91%BD%E4%BB%A4)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Wait_(%E5%91%BD%E4%BB%A4)</a></p>
</li>
<li><p><a href="http://blog.csdn.net/shuanghujushi/article/details/38186303" target="_blank" rel="noopener">http://blog.csdn.net/shuanghujushi/article/details/38186303</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/shell/shell-find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shell/shell-find/" itemprop="url">【shell】再看一眼find--find使用中遇到的问题分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-15T20:01:48+08:00">
                2015-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-简单find命令"><a href="#1-简单find命令" class="headerlink" title="1 简单find命令"></a>1 简单find命令</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码1</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">|-- 2.log</span><br><span class="line">`-- backup</span><br><span class="line">    `-- 1.log</span><br><span class="line"></span><br><span class="line">3 directories, 0 files</span><br></pre></td></tr></table></figure>

<h3 id="1-2-简单的find命令"><a href="#1-2-简单的find命令" class="headerlink" title="1.2 简单的find命令"></a>1.2 简单的find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码2</span><br><span class="line">$ find -path ./backup</span><br><span class="line">./backup</span><br></pre></td></tr></table></figure>

<h3 id="1-3-错误的通配符使用"><a href="#1-3-错误的通配符使用" class="headerlink" title="1.3 错误的通配符使用"></a>1.3 错误的通配符使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码3</span><br><span class="line">$ mkdir backup123</span><br><span class="line">$ find -path ./backup*</span><br><span class="line">find: paths must precede expression</span><br><span class="line">Usage: find [path...] [expression]</span><br></pre></td></tr></table></figure>

<p><code>find</code>命令报错：路径必须先表达。问题分析（引自：<a href="http://www.cnblogs.com/baibaluo/archive/2012/08/16/2642403.html" target="_blank" rel="noopener">http://www.cnblogs.com/baibaluo/archive/2012/08/16/2642403.html</a>）:</p>
<p>当目录下存在多个<code>backup*</code>，shell命令变成<code>find -path backup backup123</code>.此时，<code>-name</code>后面有2个匹配字符，shell报错。</p>
<p><strong>解决办法</strong>：-path(-name)匹配的字符串已经要用单引号，或者双引号引住。</p>
<h3 id="1-4-正确的通配符写法"><a href="#1-4-正确的通配符写法" class="headerlink" title="1.4 正确的通配符写法"></a>1.4 正确的通配符写法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码4</span><br><span class="line">$ find -path <span class="string">'./backup*'</span></span><br><span class="line">./backup</span><br><span class="line">./backup/1.log</span><br><span class="line">./backup123</span><br></pre></td></tr></table></figure>

<p>此时，命令运行正确！</p>
<h2 id="2-find多条件"><a href="#2-find多条件" class="headerlink" title="2 find多条件"></a>2 find多条件</h2><p><code>expr1 expr2 -o expr3</code> 等同于 <code>expr1 -a expr2 -o expr3</code>.与其他语言中的<strong>与或非</strong>类似。并且是<strong>短路求值</strong></p>
<h3 id="2-1-find多条件尝试-与"><a href="#2-1-find多条件尝试-与" class="headerlink" title="2.1 find多条件尝试:与"></a>2.1 find多条件尝试:与</h3><pre><code>代码5
$ find -path ./backup -name &apos;*.log&apos;
$</code></pre><p>没有任何返回结果。该语句的含义是：路径是path，并且名字是以.log结尾的文件。显然，并不存在。</p>
<p>本语句实际上是想查找，backup下所有的以.log结尾的文件。应是：</p>
<ol>
<li><code>find -path &#39;./backup*&#39; -name &#39;*.log&#39;</code></li>
</ol>
<h3 id="2-2-find多条件尝试-或"><a href="#2-2-find多条件尝试-或" class="headerlink" title="2.2 find多条件尝试:或"></a>2.2 find多条件尝试:或</h3><pre><code>代码6
$ find -path &apos;./backup*&apos; -o -name &apos;*.log&apos;
./backup
./backup/1.log
./2.log
./backup123</code></pre><p>到这个地方，<code>-a</code> 和 <code>-o</code>的体会已经一目了然了吧。这条命令展示了在backup*下的所有文件和以.log结尾的所有文件。</p>
<h2 id="3-prune的体会"><a href="#3-prune的体会" class="headerlink" title="3 -prune的体会"></a>3 <code>-prune</code>的体会</h2><p>贴上这样的几条<code>shell</code>命令，请先自行体会：</p>
<pre><code>代码7
$ find -path &apos;./backup*&apos;
./backup
./backup/1.log
./backup123
$ find -path &apos;./backup*&apos; -prune
./backup
./backup123</code></pre><h3 id="3-1-prune的基本使用"><a href="#3-1-prune的基本使用" class="headerlink" title="3.1 prune的基本使用"></a>3.1 <code>prune</code>的基本使用</h3><p><code>-prune</code>在man中是这么说的</p>
<blockquote>
<p>If -depth is not given, true; do not descend the current directory.<br>If -depth is given, false; no effect.</p>
</blockquote>
<p>如果<code>find</code>语句中存在-depth选项，那么<code>-prune</code>将会被忽略。否则，<code>-prune</code>将声明不展开当前路径。</p>
<p>这样在上述的1、2条命令中，由于<code>-prune</code>选项的存在，致使backup路径没有展开。所以1.log没有在打印列表中。</p>
<p>我们再次做这样的尝试：</p>
<pre><code>代码8
$ touch backup123/3.log
$ find -path &apos;./backup*&apos; -prune
./backup
./backup123
$ find -path &apos;./backup*&apos;
./backup
./backup/1.log
./backup123
./backup123/3.log</code></pre><p>打印的结果和预期是一样的。</p>
<p>按照上述<strong>2 find多条件</strong>中说道的那样，<code>find -path &#39;./backup*&#39;</code>获得所有backup前缀的文件，然后将结果和<code>-prune</code>相<code>与</code>：其实就是判断前者的结果中是否包含<strong>指定路径</strong>的子文件(夹)。</p>
<h3 id="3-2-prune做排除路径用"><a href="#3-2-prune做排除路径用" class="headerlink" title="3.2 prune做排除路径用"></a>3.2 <code>prune</code>做排除路径用</h3><p>而一般情况下<code>prune</code>是这样使用的</p>
<pre><code>代码9
$ find -path &apos;./backup*&apos; -prune -o -name &apos;*.log&apos; -print
./2.log</code></pre><p>指代的意思是当前路径除去<code>backup*</code>文件夹外的所有<code>*.log</code>文件。</p>
<h4 id="3-2-1-一个问题"><a href="#3-2-1-一个问题" class="headerlink" title="3.2.1 一个问题"></a>3.2.1 一个问题</h4><p>这样是如愿以偿了，但是我们执行一下这样的一条命令：</p>
<pre><code>代码10
$ find -path &apos;./backup*&apos; -o -name &apos;*.log&apos; -print
./2.log</code></pre><p>返回的结果一模一样。</p>
<h4 id="3-2-2-进一步剖析"><a href="#3-2-2-进一步剖析" class="headerlink" title="3.2.2 进一步剖析"></a>3.2.2 进一步剖析</h4><p>这个问题我们暂且搁置不论，继续来看这样的2个命令：</p>
<pre><code>代码11
$ find -path &apos;./backup*&apos; -prune -o -name &apos;*.log&apos;
./backup
./2.log
./backup123
$ find -path &apos;./backup*&apos;  -o -name &apos;*.log&apos;
./backup
./backup/1.log
./2.log
./backup123</code></pre><p>2个结果集中只是缺少了<code>./backup/1.log</code>，<code>-prune</code>做到的只是一个收缩路径的功能。</p>
<p>再继续对比这2个命令和上面两个命令，缺少的是一个<code>-print</code>.其实在man里面有这样的一句话<strong>“If no expression is given, the expression ‘-print’ is used.”</strong></p>
<p>也就是说<code>-print</code>是个默认值，那么上面2组命令实际上可以这样看待：</p>
<table>
<thead>
<tr>
<th align="center">输入命令</th>
<th align="center">实际命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>find -path &#39;./backup*&#39; -o -name &#39;*.log&#39;</code></td>
<td align="center"><code>find \( -path &#39;./backup*&#39; -o -name &#39;*.log&#39; \) -print</code></td>
</tr>
<tr>
<td align="center"><code>find -path &#39;./backup*&#39; -o -name &#39;*.log&#39; -print</code></td>
<td align="center"><code>find \( -path &#39;./backup*&#39; \) -o \( -name &#39;*.log&#39; -print \)</code></td>
</tr>
</tbody></table>
<p><strong>代码9</strong> 和 <strong>代码10</strong>中的片段可以理解为打印<code>-path &#39;./backup*&#39;</code>为false 、 <code>-name &#39;*.log&#39;</code> 为true的find结果。</p>
<p>而<strong>代码11</strong>中的片段则是将<code>-path &#39;./backup*&#39; -o -name &#39;*.log&#39;</code>过滤后所有为true的结果都打印。</p>
<h4 id="3-2-3-总结"><a href="#3-2-3-总结" class="headerlink" title="3.2.3 总结"></a>3.2.3 总结</h4><p>那么这样看来，其实排除路径其实是将<code>-print</code>放置到了-o后面作为输出。而<code>-path &#39;./backup*&#39;</code>执行过，并且返回true，单并未被打印。</p>
<p>那么是不是说，其实，其实，其实<code>-prune</code>并没有什么用？</p>
<h2 id="4-总结：多一点角度看find"><a href="#4-总结：多一点角度看find" class="headerlink" title="4 总结：多一点角度看find"></a>4 总结：多一点角度看find</h2><p>其实可以认为</p>
<ol>
<li>find无可避免的对指定路径进行了全文搜索，默认情况下是深度优先搜索(只有在指定-depth的时候使用广度优先搜索)。</li>
<li>find进行全文搜索以后，将结果扔到后面的过滤条件中，按照<strong>与或非</strong>的规则，逐条过滤。</li>
<li>最终返回值为true的item被打印了出来</li>
</ol>
<p>试想这样一个场景，在一个java项目中，由于项目庞大，总文件数上万。想要找到最深2级目录下所有的java文件。</p>
<pre><code>find . -name &quot;*.java&quot; -maxdepth 2
find . -maxdepth 2 -name &quot;*.java&quot;</code></pre><p>这样的2条命令，显然第二条的执行效率会快！！！<code>-maxdepth 2</code> 极大程度的进行了一次结果过滤。</p>
<p>那么在写find命令的时候，应该把能最大程度减小结果集的结果放到前面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/ReadingNote/WebsiteArchitecture/ReadingNote-WebsiteArchitecture-CoreElement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ReadingNote/WebsiteArchitecture/ReadingNote-WebsiteArchitecture-CoreElement/" itemprop="url">大型网站技术架构 - 大型网站核心架构要素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-07-25T20:23:43+08:00">
                2014-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ReadingNote/" itemprop="url" rel="index">
                    <span itemprop="name">ReadingNote</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ReadingNote/WebsiteArchitecture/" itemprop="url" rel="index">
                    <span itemprop="name">WebsiteArchitecture</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-性能"><a href="#1-性能" class="headerlink" title="1.性能"></a>1.性能</h2><ul>
<li><strong>浏览器端</strong>：浏览器缓存、页面压缩、合理布局、减少cookie传输、CDN</li>
<li><strong>应用服务器端</strong>：本地缓存、分布式缓存、异步。</li>
<li><strong>代码</strong>：多线程、改善内存管理。</li>
<li><strong>数据库</strong>：索引、缓存、sql优化</li>
</ul>
<p><strong>衡量网站性能</strong>有一系列的指标：响应时间、TPS、系统性能计数器。</p>
<h2 id="2-可用性"><a href="#2-可用性" class="headerlink" title="2.可用性"></a>2.可用性</h2><p>网站可用性主要手段是冗余。</p>
<p>对于应用服务器而言，多台应用服务器通过负载均衡组成一个集群，任何服务器宕机只需要把请求切换到其他服务器即可。但是有一个前提条件：应用服务器上不能保存请求的会话信息。</p>
<p>对于存储服务器，当有服务器宕机时需要将数据访问转移到可用的服务器上，并进行数据回复，以保证继续有服务器宕机的时候数据依然可用。</p>
<p>衡量一个系统是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机，系统整体是否依然可用。</p>
<h2 id="3-伸缩性"><a href="#3-伸缩性" class="headerlink" title="3.伸缩性"></a>3.伸缩性</h2><p>伸缩性是指通过不断向及群众加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p>
<p>衡量架构伸缩性的主要指标就是是否可以用多台服务器构建进群，是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来的服务器无差别的服务。集群中可容纳的总的服务器的数量是否有限制。</p>
<p>应用服务器：负载均衡</p>
<p>缓存服务器：改进缓存路由算法</p>
<p>数据库服务器：数据复制，主从热备，路由分区</p>
<p>NoSQL:天然支持</p>
<h2 id="4-扩展性"><a href="#4-扩展性" class="headerlink" title="4.扩展性"></a>4.扩展性</h2><p>不同于其他架构要素主要关注非功能性需求，网站的扩展性架构直接关注网站的功能性需求。</p>
<p>衡量一个网站架构</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/ReadingNote/WebsiteArchitecture/ReadingNote-WebsiteArchitecture-Scalability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ReadingNote/WebsiteArchitecture/ReadingNote-WebsiteArchitecture-Scalability/" itemprop="url">大型网站技术架构 - 网站的伸缩性架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-07-25T20:23:43+08:00">
                2014-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ReadingNote/" itemprop="url" rel="index">
                    <span itemprop="name">ReadingNote</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ReadingNote/WebsiteArchitecture/" itemprop="url" rel="index">
                    <span itemprop="name">WebsiteArchitecture</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-网站架构的伸缩性设计"><a href="#1-网站架构的伸缩性设计" class="headerlink" title="1.网站架构的伸缩性设计"></a>1.网站架构的伸缩性设计</h2><p>一般说来，网站的伸缩性设计可分成2类：一类是根据功能进行物理分离实现伸缩（横向，纵向）；一类是单一功能通过集群实现伸缩。</p>
<p>具体说来集群伸缩性又可分为应用服务器集群伸缩性和数据服务器集群伸缩性。这两种集群由于对数据状态管理的不同，技术实现也有很大的区别。而数据服务器集群也可分为缓存数据服务器集群和存储数据服务器集群。</p>
<h2 id="2-应用服务器集群的伸缩性设计"><a href="#2-应用服务器集群的伸缩性设计" class="headerlink" title="2.应用服务器集群的伸缩性设计"></a>2.应用服务器集群的伸缩性设计</h2><p>如果HTTP请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现及群众新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。这个HTTP请求分发装置被称作负载均衡服务器。</p>
<ol>
<li><strong>HTTP**</strong>重定向**<ol>
<li>叙述：一台普通的应用服务器，返回302重定向</li>
<li>缺点：浏览器需要2次请求服务器才能完成一次访问。重定向服务器自身处理能力是瓶颈。</li>
</ol>
</li>
<li><strong>DNS**</strong>域名解析**<ol>
<li>叙述：在DNS服务器中配置多个IP地址</li>
<li>缺点：目前的DNS时多级解析，每一级DNS都可能`缓存A记录，因此下线某台服务器后，即使修改了DNS的A记录，也不能及时生效。</li>
</ol>
</li>
<li><strong>反向代理（Nginx**</strong>）**<ol>
<li>叙述：将请求根据负载均衡算法转发到不同的Web服务器上，Web服务器的响应也需要通过反向代理服务器返回给用户。</li>
<li>缺点：反向代理时所有请求和相应的中转站，其性能很有可能成为瓶颈。</li>
</ol>
</li>
<li><strong>IP**</strong>负载均衡**<ol>
<li>叙述：内核进程更改目的IP地址，不需要经过用户进程（NAT转换）。相比于反向代理有更好的性能。</li>
<li>缺点：所有请求相应都需要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。对于提供下载服务或者视频服务的网站，难以满足需求。</li>
</ol>
</li>
<li><strong>数据链路层反向代理</strong><ol>
<li>叙述：在数据链路层直接修改mac地址进行负载均衡，不修改src，dest而进行数据分发。避免负载均衡服务器网卡带宽成为瓶颈。这种负载均衡方式有称作DR。</li>
<li>被称作三角传输模式，时目前大型网站使用最广的一种负载均衡手段。</li>
</ol>
</li>
</ol>
<h2 id="3-分布式缓存集群的伸缩性设计"><a href="#3-分布式缓存集群的伸缩性设计" class="headerlink" title="3.分布式缓存集群的伸缩性设计"></a>3.分布式缓存集群的伸缩性设计</h2><p>和所有服务器都部署相同应用的应用服务器集群不同，分布式缓存服务器集群中不同服务器中缓存的数据各不相同，缓存访问请求不可以在缓存服务器集群中的任意一台处理，必须先找到缓存有需要数据的服务器才能访问。</p>
<p>设计原则：必须让新上线的缓存服务器对整个分布式缓存集群影响最小，也就是说新加入缓存服务器后应使整个缓存服务器集群中已经缓存的数据尽可能的被访问到。</p>
<p><strong>一致性哈希！！！</strong></p>
<h2 id="4-数据存储服务器集群的伸缩性设计"><a href="#4-数据存储服务器集群的伸缩性设计" class="headerlink" title="4.数据存储服务器集群的伸缩性设计"></a>4.数据存储服务器集群的伸缩性设计</h2><p>缓存的目的时加速数据读取的速度并减轻数据存储服务器的负载压力，因此，部分缓存丢失不影响业务的正常处理。而数据存储服务器必须保证数据的可靠存储，任何情况下，都必须保证数据的可用性和正确性。</p>
<h3 id="4-1关系数据库集群的伸缩性设计"><a href="#4-1关系数据库集群的伸缩性设计" class="headerlink" title="4.1关系数据库集群的伸缩性设计"></a>4.1关系数据库集群的伸缩性设计</h3><p>主从复制，读写分离，业务分库。Cobar</p>
<h3 id="4-2NoSQL数据库的伸缩性设计"><a href="#4-2NoSQL数据库的伸缩性设计" class="headerlink" title="4.2NoSQL数据库的伸缩性设计"></a>4.2NoSQL数据库的伸缩性设计</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangxin201492</p>
              <p class="site-description motion-element" itemprop="description">my blogs</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wangxin201492" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wangxin201492@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangxin201492</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
