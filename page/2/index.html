<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="wangxin201492">
<meta property="og:url" content="https://wangxin201492.github.io/page/2/index.html">
<meta property="og:site_name" content="wangxin201492">
<meta property="og:description" content="my blogs">
<meta property="article:author" content="wangxin201492">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangxin201492.github.io/page/2/"/>





  <title>wangxin201492</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b4b40ab284f92e7b4921a8198acda5b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wangxin201492</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/command/serverStatus/MongoDB-serverStatus-output/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/command/serverStatus/MongoDB-serverStatus-output/" itemprop="url">MongoDB serverStatus 输出指标说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-03T10:43:34+08:00">
                2020-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/serverStatus/" itemprop="url" rel="index">
                    <span itemprop="name">serverStatus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>MongoDB 4.2 serverStatus指标释义，本文只包含server层指标</p>
</blockquote>
<h3 id="实例信息-Instance-Information"><a href="#实例信息-Instance-Information" class="headerlink" title="实例信息 - Instance Information"></a>实例信息 - Instance Information</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"host" : &lt;string&gt;,</span><br><span class="line">"advisoryHostFQDNs" : &lt;array&gt;,</span><br><span class="line">"version" : &lt;string&gt;,</span><br><span class="line">"process" : &lt;"mongod"|"mongos"&gt;,</span><br><span class="line">"pid" : &lt;num&gt;,</span><br><span class="line">"uptime" : &lt;num&gt;,</span><br><span class="line">"uptimeMillis" : &lt;num&gt;,</span><br><span class="line">"uptimeEstimate" : &lt;num&gt;,</span><br><span class="line">"localTime" : ISODate(""),</span><br></pre></td></tr></table></figure>

<ul>
<li>host : </li>
<li>advisoryHostFQDNs : </li>
<li>version : </li>
<li>process : </li>
<li>pid : </li>
<li><strong>uptime :</strong> </li>
<li>uptimeMillis : </li>
<li>uptimeEstimate : </li>
<li>localTime : </li>
</ul>
<h3 id="assert"><a href="#assert" class="headerlink" title="* assert"></a>* assert</h3><p>自MongoDB启动以来的断言数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"asserts" : &#123;</span><br><span class="line">   "regular" : &lt;num&gt;,</span><br><span class="line">   "warning" : &lt;num&gt;,</span><br><span class="line">   "msg" : &lt;num&gt;,</span><br><span class="line">   "user" : &lt;num&gt;,</span><br><span class="line">   "rollovers" : &lt;num&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>regular : MongoDB启动以来发生的常规断言数</li>
<li>warning : 4.0版本以后该值恒为0<ul>
<li>4.0之前的版本会返回MongoDB启动以来发生warning的次数</li>
</ul>
</li>
<li>msg : MongoDB启动以来引发的消息断言数</li>
<li>user : MongoDB启动以来引发的用户断言数。这些断言可能是用户行为生成的， 比如磁盘空间不足、duplicate key等，可以通过修复应用程序或者部署问题来解决这些问题</li>
<li>rollovers : MongoDB启动以来，断言的翻转次数。assert超过2^30，则会置零，rollovers+1</li>
</ul>
<h3 id="connections"><a href="#connections" class="headerlink" title="* connections"></a>* connections</h3><p>当前连接数的信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"connections" : &#123;</span><br><span class="line">   "current" : &lt;num&gt;,</span><br><span class="line">   "available" : &lt;num&gt;,</span><br><span class="line">   "totalCreated" : &lt;num&gt;,</span><br><span class="line">   "active" : &lt;num&gt;,</span><br><span class="line">   "exhaustIsMaster" : &lt;num&gt;,</span><br><span class="line">   "awaitingTopologyChanges" : &lt;num&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>current : 当前连接数，包含从其他rs节点或者mongos节点发起的链接</strong></li>
<li><strong>available : 当前未使用的连接数</strong></li>
<li><strong>totalCreated : MongoDB启动以来，创建的链接总数</strong></li>
<li><strong>active : [4.0.7] 当前活跃的连接数。活跃链接：链接中有操作正在执行(in progress)</strong></li>
<li>exhaustIsMaster : [4.4] // TODO 客户端的最后一条请求是包含 <code>exhaustAllowed</code> 的 <code>isMaster</code> 请求数</li>
<li>awaitingTopologyChanges : [4.4] // TODO 当前在 <code>isMaster</code> 请求中等待拓扑变更的请求数</li>
</ul>
<h3 id="defaultRWConcern-4-4-TODO"><a href="#defaultRWConcern-4-4-TODO" class="headerlink" title="defaultRWConcern [4.4] // TODO"></a>defaultRWConcern [4.4] // TODO</h3><p>The <code>defaultRWConcern</code> section provides information on the local copy of the global default read or write concern settings. The data may be stale or out of date. See <a href="https://docs.mongodb.com/master/reference/command/getDefaultRWConcern/#dbcmd.getDefaultRWConcern" target="_blank" rel="noopener"><code>getDefaultRWConcern</code></a> for more information.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"defaultRWConcern" : &#123;</span><br><span class="line">  "defaultReadConcern" : &#123;</span><br><span class="line">    "level" : &lt;string&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  "defaultWriteConcern" : &#123;</span><br><span class="line">    "w" : &lt;string&gt; | &lt;int&gt;,</span><br><span class="line">    "wtimeout" : &lt;int&gt;,</span><br><span class="line">    "j" : &lt;bool&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  "updateOpTime" : Timestamp,</span><br><span class="line">  "updateWallClockTime" : Date,</span><br><span class="line">  "localUpdateWallClockTime" : Date</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="electionMetrics-4-2-1-amp-4-0-13"><a href="#electionMetrics-4-2-1-amp-4-0-13" class="headerlink" title="* electionMetrics [4.2.1 &amp; 4.0.13]"></a>* electionMetrics [4.2.1 &amp; 4.0.13]</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">"electionMetrics" : &#123;</span><br><span class="line">   "stepUpCmd" : &#123;</span><br><span class="line">      "called" : &lt;NumberLong&gt;,</span><br><span class="line">      "successful" : &lt;NumberLong&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   "priorityTakeover" : &#123;</span><br><span class="line">      "called" : &lt;NumberLong&gt;,</span><br><span class="line">      "successful" : &lt;NumberLong&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   "catchUpTakeover" : &#123;</span><br><span class="line">      "called" : &lt;NumberLong&gt;,</span><br><span class="line">      "successful" : &lt;NumberLong&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   "electionTimeout" : &#123;</span><br><span class="line">      "called" : &lt;NumberLong&gt;,</span><br><span class="line">      "successful" : &lt;NumberLong&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   "freezeTimeout" : &#123;</span><br><span class="line">      "called" : &lt;NumberLong&gt;,</span><br><span class="line">      "successful" : &lt;NumberLong&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   "numStepDownsCausedByHigherTerm" : &lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUps" : &lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUpsSucceeded" : &lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUpsAlreadyCaughtUp" : &lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUpsSkipped" : &lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUpsTimedOut" : &lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUpsFailedWithError" :&lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUpsFailedWithNewTerm" : &lt;NumberLong&gt;,</span><br><span class="line">   "numCatchUpsFailedWithReplSetAbortPrimaryCatchUpCmd" : &lt;NumberLong&gt;,</span><br><span class="line">   "averageCatchUpOps" : &lt;double&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stepUpCmd : primary 卸任(<code>stepDown</code>)时，mongod发起选举交接的次数</li>
<li>priorityTakeover : mongod实例的 <code>priority</code> 大于 primary 时，发起选举的次数</li>
<li>catchUpTakeover : mongod实例比 primary 更新时，发起选举的次数 // <a href="https://docs.mongodb.com/master/reference/replica-configuration/#rsconf.settings.catchUpTakeoverDelayMillis" target="_blank" rel="noopener"><code>settings.catchUpTakeoverDelayMillis</code></a></li>
<li>electionTimeout : mongod实例在指定时间内无法连接 primary 时，发起选举的次数 // <a href="https://docs.mongodb.com/master/reference/replica-configuration/#rsconf.settings.electionTimeoutMillis" target="_blank" rel="noopener"><code>settings.electionTimeoutMillis</code></a></li>
<li>freezeTimeout : 冻结时间过后，mongod发起的选举次数 // <a href="https://docs.mongodb.com/master/reference/command/replSetFreeze/#dbcmd.replSetFreeze" target="_blank" rel="noopener"><code>freeze period</code></a> </li>
<li>numStepDownsCausedByHigherTerm : 发现有其他节点任期更高，mongod发生step down的次数</li>
<li>numCatchUps : 作为新当选的primary，mongod必须追赶最高的oplog的次数</li>
<li>numCatchUpsSucceeded : 作为新当选的primary，mongod追赶最高oplog成功的次数</li>
<li>numCatchUpsAlreadyCaughtUp : 作为新当选的primary，选举时已经完成追赶而结束追赶的次数</li>
<li>numCatchUpsSkipped : 作为新当选的primary，跳过追赶过程的次数</li>
<li>numCatchUpsTimedOut : 作为新当选的primary，由于时间限制而结束追赶的次数 // <a href="https://docs.mongodb.com/master/reference/replica-configuration/#rsconf.settings.catchUpTimeoutMillis" target="_blank" rel="noopener"><code>settings.catchUpTimeoutMillis</code></a></li>
<li>numCatchUpsFailedWithError : 作为新当选的primary，由于错误而导致追赶失败的次数</li>
<li>numCatchUpsFailedWithNewTerm : 作为新当选的primary，由于其他节点有更高任期而导致追赶失败的次数</li>
<li>numCatchUpsFailedWithReplSetAbortPrimaryCatchUpCmd : 作为新当选的primary，收到 <a href="https://docs.mongodb.com/master/reference/command/replSetAbortPrimaryCatchUp/#dbcmd.replSetAbortPrimaryCatchUp" target="_blank" rel="noopener"><code>replSetAbortPrimaryCatchUp</code></a> 而结束追赶的次数</li>
<li>averageCatchUpOps : 新当选的primary追赶过程中，平均apply的operation次数</li>
</ul>
<h3 id="extra-info"><a href="#extra-info" class="headerlink" title="extra_info"></a>extra_info</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"extra_info" : &#123;</span><br><span class="line">   "note" : "fields vary by platform.",</span><br><span class="line">   "heap_usage_bytes" : &lt;num&gt;,</span><br><span class="line">   "page_faults" : &lt;num&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>note : 恒为”fields vary by platform.”</li>
<li>heap_usage_bytes : 占用堆内存的大小</li>
<li><strong>page_faults : 发生major page_faults的次数</strong></li>
<li><strong>user_time_us :用户态CPU使用</strong> </li>
<li><strong>system_time_us :系统CPU使用</strong> </li>
<li>maximum_resident_set_kb : </li>
<li>input_blocks : </li>
<li>output_blocks : </li>
<li><strong>page_reclaims : 发生minor page_faults的次数</strong></li>
<li><strong>voluntary_context_switches :发生自愿context switch的次数</strong> </li>
<li><strong>involuntary_context_switches :发生非自愿context switch的次数</strong> </li>
</ul>
<h3 id="flowControl-4-2"><a href="#flowControl-4-2" class="headerlink" title="flowControl [4.2]"></a>flowControl [4.2]</h3><p>流控相关指标</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"flowControl" : &#123;</span><br><span class="line">   "enabled" : &lt;boolean&gt;,</span><br><span class="line">   "targetRateLimit" : &lt;int&gt;,</span><br><span class="line">   "timeAcquiringMicros" : &lt;NumberLong&gt;,</span><br><span class="line">   "locksPerKiloOp" : &lt;double&gt;,  // Available in 4.4+. In 4.2, returned locksPerOp instead.</span><br><span class="line">   "sustainerRate" : &lt;int&gt;,</span><br><span class="line">   "isLagged" : &lt;boolean&gt;,</span><br><span class="line">   "isLaggedCount" : &lt;int&gt;,</span><br><span class="line">   "isLaggedTimeMicros" : &lt;NumberLong&gt;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>enabled : 是否开启流控 // <a href="https://docs.mongodb.com/master/reference/parameters/#param.enableFlowControl" target="_blank" rel="noopener"><code>enableFlowControl</code></a></strong></li>
<li><strong>targetRateLimit : primary节点返回的是每秒最大可以获取ticket的数量。secondary节点返回一个占位符</strong></li>
<li><strong>timeAcquiringMicros : primary节点返回write操作的总等待时间。secondary节点返回一个占位符</strong></li>
<li><strong>locksPerKiloOp : [4.4] primary节点每1000操作获取锁的近似值。secondary节点返回一个占位符</strong><ul>
<li><strong>4.2 版本返回locksPerOp字段，为每个操作获取锁次数，4.4取代了该字段</strong></li>
</ul>
</li>
<li><strong>sustainerRate : primary节点上，返回secondary每秒apply的操作数。secondary节点返回一个占位符</strong></li>
<li><strong>isLagged : 是否发生流控。当majority committed lag超过指定时间时发生。secondary节点返回一个占位符 // <a href="https://docs.mongodb.com/master/reference/parameters/#param.flowControlTargetLagSeconds" target="_blank" rel="noopener"><code>flowControlTargetLagSeconds</code></a></strong></li>
<li><strong>isLaggedCount : primary节点返回mongod启动以来发生流控的次数。secondary节点返回一个占位符</strong></li>
<li><strong>isLaggedTimeMicros : primary节点上返回mongod启动以来发生流控的时间。secondary返回一个占位符</strong></li>
</ul>
<h3 id="freeMonitoring-TODO"><a href="#freeMonitoring-TODO" class="headerlink" title="freeMonitoring // TODO"></a>freeMonitoring // TODO</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"freeMonitoring" : &#123;</span><br><span class="line">   "state" : &lt;string&gt;,</span><br><span class="line">   "retryIntervalSecs" : &lt;NumberLong&gt;,</span><br><span class="line">   "lastRunTime" : &lt;string&gt;,</span><br><span class="line">   "registerErrors" : &lt;NumberLong&gt;,</span><br><span class="line">   "metricsErrors" : &lt;NumberLong&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="globalLock"><a href="#globalLock" class="headerlink" title="globalLock"></a>globalLock</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"globalLock" : &#123;</span><br><span class="line">   "totalTime" : &lt;num&gt;,</span><br><span class="line">   "currentQueue" : &#123;</span><br><span class="line">      "total" : &lt;num&gt;,</span><br><span class="line">      "readers" : &lt;num&gt;,</span><br><span class="line">      "writers" : &lt;num&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   "activeClients" : &#123;</span><br><span class="line">      "total" : &lt;num&gt;,</span><br><span class="line">      "readers" : &lt;num&gt;,</span><br><span class="line">      "writers" : &lt;num&gt;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>totalTime : 自mongod启动并创建 <code>globalLock</code> 的微秒数。大致和服务器uptime相同</li>
<li><strong>currentQueue.total : 等待锁队列的长度 = <code>currentQueue.readers</code> + <code>currentQueue.writers</code></strong></li>
<li><strong>currentQueue.readers : 等待读锁队列的长度</strong></li>
<li><strong>currentQueue.writers : 等待写锁队列的长度</strong></li>
<li><strong>activeClients.total : 客户连接和内部threads，执行读或者写的总数。可能比 <code>currentQueue.readers</code> + <code>currentQueue.writers</code> 高，因为还包含了内部threads</strong></li>
<li><strong>activeClients.readers : 客户连接执行读操作的数量</strong></li>
<li><strong>activeClients.writers : 客户连接执行写操作的数量</strong></li>
</ul>
<h3 id="hedgingMetrics-4-4-TODO"><a href="#hedgingMetrics-4-4-TODO" class="headerlink" title="hedgingMetrics [4.4] // TODO"></a>hedgingMetrics [4.4] // TODO</h3><p><em>New in version 4.4:</em> For <a href="https://docs.mongodb.com/master/reference/program/mongos/#bin.mongos" target="_blank" rel="noopener"><code>mongos</code></a> instances only.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"hedgingMetrics" : &#123;</span><br><span class="line">   "numTotalOperations" : &lt;num&gt;,</span><br><span class="line">   "numTotalHedgedOperations" : &lt;num&gt;,</span><br><span class="line">   "numAdvantageouslyHedgedOperations" : &lt;num&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="latchAnalysis-4-4-TODO"><a href="#latchAnalysis-4-4-TODO" class="headerlink" title="latchAnalysis [4.4] // TODO"></a>latchAnalysis [4.4] // TODO</h3><p><em>New in version 4.4.</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"latchAnalysis" : &#123;</span><br><span class="line">   &lt;latch name&gt; : &#123;</span><br><span class="line">      "created" : &lt;num&gt;,</span><br><span class="line">      "destroyed" : &lt;num&gt;,</span><br><span class="line">      "acquired" : &lt;num&gt;,</span><br><span class="line">      "released" : &lt;num&gt;,</span><br><span class="line">      "contended" : &lt;num&gt;,</span><br><span class="line">      "hierarchicalAcquisitionLevelViolations" : &#123;</span><br><span class="line">            "onAcquire" : &lt;num&gt;,</span><br><span class="line">            "onRelease" : &lt;num&gt;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>



<h3 id="logicalSessionRecordCache-3-6"><a href="#logicalSessionRecordCache-3-6" class="headerlink" title="logicalSessionRecordCache [3.6]"></a>logicalSessionRecordCache [3.6]</h3><p>Server session 的一些缓存指标</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"logicalSessionRecordCache" : &#123;</span><br><span class="line">   "activeSessionsCount" : &lt;num&gt;,</span><br><span class="line">   "sessionsCollectionJobCount" : &lt;num&gt;,</span><br><span class="line">   "lastSessionsCollectionJobDurationMillis" : &lt;num&gt;,</span><br><span class="line">   "lastSessionsCollectionJobTimestamp" : &lt;Date&gt;,</span><br><span class="line">   "lastSessionsCollectionJobEntriesRefreshed" : &lt;num&gt;,</span><br><span class="line">   "lastSessionsCollectionJobEntriesEnded" : &lt;num&gt;,</span><br><span class="line">   "lastSessionsCollectionJobCursorsClosed" : &lt;num&gt;,</span><br><span class="line">   "transactionReaperJobCount" : &lt;num&gt;,</span><br><span class="line">   "lastTransactionReaperJobDurationMillis" : &lt;num&gt;,</span><br><span class="line">   "lastTransactionReaperJobTimestamp" : &lt;Date&gt;,</span><br><span class="line">   "lastTransactionReaperJobEntriesCleanedUp" : &lt;num&gt;,</span><br><span class="line">   "sessionCatalogSize" : &lt;num&gt;   // Starting in MongoDB 4.2</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>activeSessionsCount : 上次刷新以来，缓存在内存中的本地活跃session数量</strong></li>
<li><strong>sessionsCollectionJobCount : session refresh执行次数</strong></li>
<li><strong>lastSessionsCollectionJobDurationMillis : 上次session refresh执行耗时</strong></li>
<li>lastSessionsCollectionJobTimestamp : 上次session refresh发生的时间点</li>
<li><strong>lastSessionsCollectionJobEntriesRefreshed : 上次session refresh期间，刷新的session数量</strong></li>
<li><strong>lastSessionsCollectionJobEntriesEnded : 上次session refresh期间，结束的session数量</strong></li>
<li><strong>lastSessionsCollectionJobCursorsClosed : 上次session refresh期间，关闭的cursor数量</strong></li>
<li><strong>transactionReaperJobCount : transaction reaper执行次数</strong></li>
<li><strong>lastTransactionReaperJobDurationMillis : 上次transaction reaper执行耗时</strong></li>
<li>lastTransactionReaperJobTimestamp : 上次transaction reaper发生的时间点</li>
<li><strong>lastTransactionReaperJobEntriesCleanedUp : 上次transaction reaper清理的entry数量</strong></li>
<li><strong>sessionCatalogSize : [4.2] 内存中缓存的session数量</strong></li>
</ul>
<h3 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">"locks" : &#123;</span><br><span class="line">   &lt;type&gt; : &#123;</span><br><span class="line">         "acquireCount" : &#123;</span><br><span class="line">            &lt;mode&gt; : NumberLong(&lt;num&gt;),</span><br><span class="line">            ...</span><br><span class="line">         &#125;,</span><br><span class="line">         "acquireWaitCount" : &#123;</span><br><span class="line">            &lt;mode&gt; : NumberLong(&lt;num&gt;),</span><br><span class="line">            ...</span><br><span class="line">         &#125;,</span><br><span class="line">         "timeAcquiringMicros" : &#123;</span><br><span class="line">            &lt;mode&gt; : NumberLong(&lt;num&gt;),</span><br><span class="line">            ...</span><br><span class="line">         &#125;,</span><br><span class="line">         "deadlockCount" : &#123;</span><br><span class="line">            &lt;mode&gt; : NumberLong(&lt;num&gt;),</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><type> :</strong> <ul>
<li><strong>ParallelBatchWriterMode : [4.2]</strong></li>
<li><strong>ReplicationStateTransition : [4.2]</strong></li>
<li><strong>Global</strong></li>
<li><strong>Database</strong></li>
<li><strong>Collection</strong></li>
<li><strong>Mutex</strong></li>
<li><strong>Metadata</strong></li>
<li><strong>oplog</strong></li>
</ul>
</li>
<li><strong><type>.acquireCount : 获取锁的次数</strong></li>
<li><strong><type>.acquireWaitCount : 由于锁冲突而等待的次数</strong></li>
<li><strong><type>.timeAcquiringMicros : 锁等待的累积时间</strong></li>
<li><strong><type>.deadlockCount : 死锁发生的次数</strong></li>
<li><strong><modes> :</strong> <ul>
<li><strong>R : Shared (S) lock.</strong></li>
<li><strong>W : Exclusive (X) lock.</strong></li>
<li><strong>r : Intent Shared (IS) lock.</strong></li>
<li><strong>w : Intent Exclusive (IX) lock.</strong></li>
</ul>
</li>
</ul>
<h3 id="mirroredReads-4-4-TODO"><a href="#mirroredReads-4-4-TODO" class="headerlink" title="mirroredReads [4.4] // TODO"></a>mirroredReads [4.4] // TODO</h3><p><em>Available on mongod only.</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"mirroredReads" : &#123;</span><br><span class="line">      "seen" : &lt;num&gt;,</span><br><span class="line">      "sent" : &lt;num&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"network" : &#123;</span><br><span class="line">   "bytesIn" : &lt;num&gt;,</span><br><span class="line">   "bytesOut" : &lt;num&gt;,</span><br><span class="line">   "physicalBytesIn" : &lt;num&gt;,</span><br><span class="line">	 "physicalBytesOut" : &lt;num&gt;,</span><br><span class="line">   "numSlowDNSOperations" : &lt;num&gt;,</span><br><span class="line">   "numSlowSSLOperations" : &lt;num&gt;,</span><br><span class="line">   "numRequests" : &lt;num&gt;,</span><br><span class="line">   "serviceExecutorTaskStats" : &#123;&#125;,</span><br><span class="line">   "tcpFastOpen" : &#123;</span><br><span class="line">     "kernelSetting" : NumberLong("&lt;num&gt;"),</span><br><span class="line">     "serverSupported" : &lt;bool&gt;,</span><br><span class="line">     "clientSupported" : &lt;bool&gt;,</span><br><span class="line">     "accepted" : "NumberLong(&lt;num&gt;)"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>bytesIn : 网络入流量的字节数</strong></li>
<li><strong>bytesOut : 网络出流量字节数</strong></li>
<li><strong>physicalBytesIn : 物理网络入流量</strong></li>
<li><strong>physicalBytesOut : 物理网络出流量</strong></li>
<li>numSlowDNSOperations : [4.4] DNS解析超过1s的次数</li>
<li>numSlowSSLOperations : [4.4] SSL handshake超过1s的次数</li>
<li><strong>numRequests : 接收到的请求次数</strong></li>
<li>serviceExecutorTaskStats : 打印serviceExecutor信息，默认是 Synchronous，则信息为 <code>{ &quot;executor&quot; : &quot;passthrough&quot;, &quot;threadsRunning&quot; : 2 }</code></li>
<li>tcpFastOpen :  [4.4]<ul>
<li>kernelSetting :  [4.4] = /proc/sys/net/ipv4/tcp_fastopen</li>
<li>serverSupported :  [4.4] 服务器操作系统inbound是否支持tcpFastOpen</li>
<li>clientSupported :  [4.4] 服务器操作系统outbound是否支持tcpFastOpen</li>
<li>accepted :  [4.4] mongod实例启动以来 accepted 的tcpFastOpen次数</li>
</ul>
</li>
</ul>
<h3 id="opLatencies-mongod"><a href="#opLatencies-mongod" class="headerlink" title="opLatencies [mongod]"></a>opLatencies [mongod]</h3><p>请求耗时信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">"opLatencies" : &#123;</span><br><span class="line">   "reads" : &#123;</span><br><span class="line">			"latency" : NumberLong(0),</span><br><span class="line">			"ops" : NumberLong(0)</span><br><span class="line">		&#125;,</span><br><span class="line">   "writes" : &#123;</span><br><span class="line">			"latency" : NumberLong(0),</span><br><span class="line">			"ops" : NumberLong(0)</span><br><span class="line">		&#125;,</span><br><span class="line">   "commands" : &#123;</span><br><span class="line">			"latency" : NumberLong(0),</span><br><span class="line">			"ops" : NumberLong(0)</span><br><span class="line">		&#125;,</span><br><span class="line">   "transactions" : &#123;</span><br><span class="line">			"latency" : NumberLong(0),</span><br><span class="line">			"ops" : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>输出类似 <code>db.collection.aggregate( [ { $collStats: { latencyStats: { histograms: true } } } ] )</code></p>
<p><strong>记录读、写、cmd、事务操作的次数和latency</strong></p>
<ul>
<li><strong>latency : 操作总耗时</strong></li>
<li><strong>ops : 操作总执行次数</strong></li>
<li>histogram : 记录latency的分布信息 // serverStatus中不输出</li>
</ul>
<h3 id="opReadConcernCounters-4-0-6-mongod"><a href="#opReadConcernCounters-4-0-6-mongod" class="headerlink" title="opReadConcernCounters [4.0.6] [mongod]"></a>opReadConcernCounters [4.0.6] [mongod]</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"opReadConcernCounters" : &#123;</span><br><span class="line">   "available" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "linearizable" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "local" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "majority" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "snapshot" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "none" :  NumberLong(&lt;num&gt;) // use default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mongod启动以来，query操作中指定的read concern的次数</p>
<p><strong>available / linearizable / local / majority / snapshot / none</strong></p>
<h3 id="opWriteConcernCounters-4-0-6-mongod"><a href="#opWriteConcernCounters-4-0-6-mongod" class="headerlink" title="opWriteConcernCounters [4.0.6] [mongod]"></a>opWriteConcernCounters [4.0.6] [mongod]</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">"opWriteConcernCounters" : &#123;</span><br><span class="line">   "insert" : &#123;</span><br><span class="line">      "wmajority" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "wnum" : &#123;</span><br><span class="line">         "&lt;num&gt;" :  NumberLong(&lt;num&gt;),</span><br><span class="line">         ...</span><br><span class="line">      &#125;,</span><br><span class="line">      "wtag" : &#123;</span><br><span class="line">         "&lt;tag1&gt;" :  NumberLong(&lt;num&gt;),</span><br><span class="line">         ...</span><br><span class="line">      &#125;,</span><br><span class="line">      "none" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;,</span><br><span class="line">   "update" : &#123;</span><br><span class="line">      "wmajority" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "wnum" : &#123;</span><br><span class="line">         "&lt;num&gt;" :  NumberLong(&lt;num&gt;),</span><br><span class="line">      &#125;,</span><br><span class="line">      "wtag" : &#123;</span><br><span class="line">         "&lt;tag1&gt;" :  NumberLong(&lt;num&gt;),</span><br><span class="line">         ...</span><br><span class="line">      &#125;,</span><br><span class="line">      "none" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;,</span><br><span class="line">   "delete" : &#123;</span><br><span class="line">      "wmajority" :  NumberLong(&lt;num&gt;)</span><br><span class="line">      "wnum" : &#123;</span><br><span class="line">         "&lt;num&gt;" :  NumberLong(&lt;num&gt;),</span><br><span class="line">         ...</span><br><span class="line">      &#125;,</span><br><span class="line">      "wtag" : &#123;</span><br><span class="line">         "&lt;tag1&gt;" :  NumberLong(&lt;num&gt;),</span><br><span class="line">         ...</span><br><span class="line">      &#125;,</span><br><span class="line">      "none" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mongod启动以来，write操作中指定的write concern的数量。<code>j</code> 和 <code>wtimeout</code> 参数不会影响计数，即使超时也会进行计数。只有在<a href="https://docs.mongodb.com/master/reference/parameters/#param.reportOpWriteConcernCountersInServerStatus" target="_blank" rel="noopener"><code>reportOpWriteConcernCountersInServerStatus</code></a>设置为true的时候才会打印，默认为false。</p>
<ul>
<li><strong>wmajority : 指定 <code>w: majority</code> 的次数</strong></li>
<li><strong>wnum : 指定 <code>w: &lt;num&gt;</code> 的次数</strong></li>
<li><strong>wtag : 指定 <code>w: &lt;tag&gt;</code> 的次数</strong></li>
<li><strong>none : 未指定 <code>w</code> 的次数，这些操作使用默认 <code>w: 1</code></strong></li>
</ul>
<h3 id="opcounters"><a href="#opcounters" class="headerlink" title="opcounters"></a>opcounters</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"opcounters" : &#123;</span><br><span class="line">   "insert" : NumberLong(&lt;num&gt;),  // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "query" : NumberLong(&lt;num&gt;),   // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "update" : NumberLong(&lt;num&gt;),  // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "delete" : NumberLong(&lt;num&gt;),  // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "getmore" : NumberLong(&lt;num&gt;), // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "command" : NumberLong(&lt;num&gt;), // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>记录启动以来各个命令的执行次数</p>
<p><strong>insert / query / update / delete / getmore / command</strong></p>
<p>4.2版本开始，这些指标的类型修改为NumberLong，之前版本为NumberInt。</p>
<h3 id="opcountersRepl"><a href="#opcountersRepl" class="headerlink" title="opcountersRepl"></a>opcountersRepl</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"opcountersRepl" : &#123;</span><br><span class="line">   "insert" : NumberLong(&lt;num&gt;),  // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "query" : NumberLong(&lt;num&gt;),   // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "update" : NumberLong(&lt;num&gt;),  // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "delete" : NumberLong(&lt;num&gt;),  // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "getmore" : NumberLong(&lt;num&gt;), // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">   "command" : NumberLong(&lt;num&gt;), // Starting in MongoDB 4.2, type is NumberLong</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>记录启动以来replication操作的次数</p>
<p><strong>insert / query / update / delete / getmore / command</strong></p>
<p>4.2版本开始，这些指标的类型修改为NumberLong，之前版本为NumberInt。只有当前实例为<code>replica set</code>的成员的时候才会打印。这些值和 <code>opcounter</code> 中的值可能不同，因为mongod可能序列化了这些操作</p>
<h3 id="oplogTruncation-4-2-1"><a href="#oplogTruncation-4-2-1" class="headerlink" title="oplogTruncation [4.2.1]"></a>oplogTruncation [4.2.1]</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"oplogTruncation" : &#123;</span><br><span class="line">   "totalTimeProcessingMicros" : &lt;NumberLong&gt;,</span><br><span class="line">   "processingMethod" : &lt;string&gt;,</span><br><span class="line">   "oplogMinRetentionHours" : &lt;double&gt;</span><br><span class="line">   "totalTimeTruncatingMicros" : &lt;NumberLong&gt;,</span><br><span class="line">   "truncateCount" : &lt;NumberLong&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="repl"><a href="#repl" class="headerlink" title="repl"></a>repl</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">"repl" : &#123;</span><br><span class="line">   "hosts" : [</span><br><span class="line">         &lt;string&gt;,</span><br><span class="line">         &lt;string&gt;,</span><br><span class="line">         &lt;string&gt;</span><br><span class="line">   ],</span><br><span class="line">   "setName" : &lt;string&gt;,</span><br><span class="line">   "setVersion" : &lt;num&gt;,</span><br><span class="line">   "ismaster" : &lt;boolean&gt;,</span><br><span class="line">   "secondary" : &lt;boolean&gt;,</span><br><span class="line">   "primary" : &lt;hostname&gt;,</span><br><span class="line">   "me" : &lt;hostname&gt;,</span><br><span class="line">   "electionId" : ObjectId(""),</span><br><span class="line">   "rbid" : &lt;num&gt;,</span><br><span class="line">   "replicationProgress" : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"rid"</span> : &lt;ObjectId&gt;,</span><br><span class="line">            "optime" : &#123; ts: &lt;timestamp&gt;, term: &lt;num&gt; &#125;,</span><br><span class="line">            "host" : &lt;hostname&gt;,</span><br><span class="line">            "memberId" : &lt;num&gt;</span><br><span class="line">         &#125;,</span><br><span class="line">        ...</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>hosts : 当前 <code>replica set</code> 成员的 <code>host:port</code> 的数组</li>
<li>setName :  当前 <code>replica set</code> 的name</li>
<li>setVersion :  // TODO</li>
<li>ismaster : 当前是否为 primary 节点</li>
<li>secondary : 当前是否为 secondary 节点</li>
<li>primary : primary节点的 <code>host:port</code> 信息</li>
<li>me : 当前节点的 <code>host:port</code> 信息</li>
<li>electionId :  // TODO </li>
<li>rbid : rollback标识符，表示当前节点是否发生了rollback</li>
<li>lastWrite : <ul>
<li><strong>opTime :</strong> </li>
<li>lastWriteDate : </li>
<li><strong>majorityOpTime :</strong> </li>
<li>majorityWriteDate : </li>
</ul>
</li>
<li>replicationProgress : 一个数组，每个成员是一个向当前节点汇报复制状态的节点。如果要包含这部分信息，需要在 <code>serverStatus</code> 中增加 <code>repl</code> 的option<ul>
<li>rid : <code>replica set</code>成员使用的ID，仅内部使用</li>
<li><strong>optime : 该成员汇报的最新apply的oplog的时间</strong></li>
<li>host : 该成员的 <code>host:port</code> 信息</li>
<li>memberId : 该成员的整数标识符</li>
</ul>
</li>
</ul>
<h3 id="security"><a href="#security" class="headerlink" title="security"></a>security</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">"security" : &#123;</span><br><span class="line">   "authentication" : &#123;</span><br><span class="line">      "mechanisms" : &#123;</span><br><span class="line">         "MONGODB-X509" : &#123;</span><br><span class="line">            "speculativeAuthenticate" : &#123;</span><br><span class="line">               "received" : &lt;num&gt;,</span><br><span class="line">               "successful" : &lt;num&gt;</span><br><span class="line">            &#125;,</span><br><span class="line">            "authenticate" : &#123;</span><br><span class="line">               "received" : &lt;num&gt;,</span><br><span class="line">               "successful" : &lt;num&gt;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         "SCRAM-SHA-1" : &#123;</span><br><span class="line">            "speculativeAuthenticate" : &#123;</span><br><span class="line">               "received" : &lt;num&gt;,</span><br><span class="line">               "successful" : &lt;num&gt;</span><br><span class="line">            &#125;,</span><br><span class="line">            "authenticate" : &#123;</span><br><span class="line">               "received" : &lt;num&gt;,</span><br><span class="line">               "successful" : &lt;num&gt;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         "SCRAM-SHA-256" : &#123;</span><br><span class="line">            "speculativeAuthenticate" : &#123;</span><br><span class="line">               "received" : &lt;num&gt;,</span><br><span class="line">               "successful" : &lt;num&gt;</span><br><span class="line">            &#125;,</span><br><span class="line">            "authenticate" : &#123;</span><br><span class="line">               "received" : &lt;num&gt;,</span><br><span class="line">               "successful" : &lt;num&gt;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     "SSLServerSubjectName": &lt;string&gt;,</span><br><span class="line">     "SSLServerHasCertificateAuthority": &lt;boolean&gt;,</span><br><span class="line">     "SSLServerCertificateExpirationDate": &lt;date&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>// TODO 4.4 new metrics</li>
<li>SSLServerSubjectName : SSL证书的subject name</li>
<li>SSLServerHasCertificateAuthority : 与相关机构关联时为true，自签名的为false</li>
<li>SSLServerCertificateExpirationDate : SSL证书的过期时间</li>
</ul>
<h3 id="sharding"><a href="#sharding" class="headerlink" title="sharding"></a>sharding</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"configsvrConnectionString"</span> : <span class="string">"csRS/cfg1.example.net:27019,cfg2.example.net:27019,cfg2.example.net:27019"</span>,</span><br><span class="line">   <span class="attr">"lastSeenConfigServerOpTime"</span> : &#123;</span><br><span class="line">      "ts" : Timestamp(1517462189, 1),</span><br><span class="line">      "t" : NumberLong(1)</span><br><span class="line">   &#125;,</span><br><span class="line">   "maxChunkSizeInBytes" : NumberLong(67108864)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>configsvrConnectionString : config server的连接串</li>
<li>lastSeenConfigServerOpTime : mongos 或者 shard获取的最新 CSRS 的 optime</li>
<li>maxChunkSizeInBytes : [3.6] 配置的最大chunk size。非实时</li>
</ul>
<p>3.2版本，mongos返回sharding信息。3.6版本，shard返回sharding信息</p>
<h3 id="shardingStatistics-4-0"><a href="#shardingStatistics-4-0" class="headerlink" title="shardingStatistics [4.0]"></a>shardingStatistics [4.0]</h3><h4 id="run-on-shard"><a href="#run-on-shard" class="headerlink" title="run on shard"></a>run on shard</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">"shardingStatistics" : &#123;</span><br><span class="line">   "countStaleConfigErrors" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "countDonorMoveChunkStarted" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "totalDonorChunkCloneTimeMillis" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "totalCriticalSectionCommitTimeMillis" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "totalCriticalSectionTimeMillis" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "countDocsClonedOnRecipient" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "countDocsClonedOnDonor" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "countRecipientMoveChunkStarted" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "countDocsDeletedOnDonor" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "countDonorMoveChunkLockTimeout" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "unfinishedMigrationFromPreviousPrimary" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "catalogCache" : &#123;</span><br><span class="line">      "numDatabaseEntries" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "numCollectionEntries" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countStaleConfigErrors" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "totalRefreshWaitTimeMicros" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "numActiveIncrementalRefreshes" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countIncrementalRefreshesStarted" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "numActiveFullRefreshes" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countFullRefreshesStarted" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countFailedRefreshes" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;,</span><br><span class="line">   "rangeDeleterTasks" : &lt;num&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="run-on-mongos"><a href="#run-on-mongos" class="headerlink" title="run on mongos"></a>run on mongos</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">"shardingStatistics" : &#123;</span><br><span class="line">   "catalogCache" : &#123;</span><br><span class="line">      "numDatabaseEntries" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "numCollectionEntries" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countStaleConfigErrors" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "totalRefreshWaitTimeMicros" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "numActiveIncrementalRefreshes" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countIncrementalRefreshesStarted" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "numActiveFullRefreshes" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countFullRefreshesStarted" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "countFailedRefreshes" : NumberLong(&lt;num&gt;),</span><br><span class="line">      "operationsBlockedByRefresh" : &#123;</span><br><span class="line">        "countAllOperations" : NumberLong(&lt;num&gt;),</span><br><span class="line">        "countInserts" : NumberLong(&lt;num&gt;),</span><br><span class="line">        "countQueries" : NumberLong(&lt;num&gt;),</span><br><span class="line">        "countUpdates" : NumberLong(&lt;num&gt;),</span><br><span class="line">        "countDeletes" : NumberLong(&lt;num&gt;),</span><br><span class="line">        "countCommands" : NumberLong(&lt;num&gt;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>countStaleConfigErrors : [mongod] 触发 stale config的次数</strong></li>
<li><strong>countDonorMoveChunkStarted : [mongod] 从当前实例发起 <code>moveChunk</code> 的次数</strong></li>
<li><strong>totalDonorChunkCloneTimeMillis : [mongod] 从当前实例进行 <code>moveChunk</code> 过程中，clone阶段总耗时</strong></li>
<li><strong>totalCriticalSectionCommitTimeMillis : [mongod] 从当前实例进行 <code>moveChunk</code> 过程中，更新元数据的总耗时</strong></li>
<li><strong>totalCriticalSectionTimeMillis : [mongod] 从当前实例进行 <code>moveChunk</code> 过程中，追赶和更新元数据的总耗时</strong><ul>
<li><strong>追赶阶段耗时 = <code>totalCriticalSectionTimeMillis</code> - <code>totalCriticalSectionCommitTimeMillis</code></strong></li>
</ul>
</li>
<li><strong>countDocsClonedOnRecipient : [mongod4.2] 作为 <code>moveChunk</code> 接收方，clone的document总数</strong></li>
<li><strong>countDocsClonedOnDonor : [mongod4.2] 作为 <code>moveChunk</code> 发送方，clone的document总数</strong></li>
<li><strong>countRecipientMoveChunkStarted : [mongod4.2] 作为 <code>moveChunk</code> 接收方，开始接收的次数</strong></li>
<li><strong>countDocsDeletedOnDonor : [mongod4.2] 作为 <code>moveChunk</code> 发送方，已经删除的document总数</strong></li>
<li><strong>countDonorMoveChunkLockTimeout : [mongod4.2] 作为 <code>moveChunk</code> 发送方，因获取锁超时而中断的次数</strong></li>
<li><strong>unfinishedMigrationFromPreviousPrimary : [mongod4.4] 因为选主导致migration未完成的次数，只有选主完成才会更新</strong></li>
<li><strong>rangeDeleterTasks : [mongod4.4] migration之后准备range delete的任务总数</strong></li>
<li><strong>catalogCache :</strong> <ul>
<li>numDatabaseEntries : catalog cache中 database entry的数量</li>
<li>numCollectionEntries : catalog cache中 collection entry的数量</li>
<li><strong>countStaleConfigErrors : 触发 stale config的次数</strong></li>
<li><strong>totalRefreshWaitTimeMicros : 刷新metadata的等待总耗时</strong></li>
<li><strong>numActiveIncrementalRefreshes : 目前等待增量catalog cache刷新完成的数量</strong></li>
<li><strong>countIncrementalRefreshesStarted : 增量catalog cache开始刷新的次数</strong></li>
<li><strong>numActiveFullRefreshes : 目前等待全量catalog cache刷新完成的数量</strong></li>
<li><strong>countFullRefreshesStarted : 全量catalog cache开始刷新的次数</strong></li>
<li><strong>countFailedRefreshes : 增量或全量catalog cache刷新失败的次数</strong></li>
<li><strong>operationsBlockedByRefresh : [mongos 4.2.7] catalog cache刷新导致阻塞的operation总数</strong></li>
</ul>
</li>
</ul>
<h3 id="shardedIndexConsistency-4-2-6-amp-4-4-config"><a href="#shardedIndexConsistency-4-2-6-amp-4-4-config" class="headerlink" title="shardedIndexConsistency [4.2.6 &amp; 4.4] [config]"></a>shardedIndexConsistency [4.2.6 &amp; 4.4] [config]</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"shardedIndexConsistency" : &#123;</span><br><span class="line">   "numShardedCollectionsWithInconsistentIndexes" : &lt;NumberLong&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>numShardedCollectionsWithInconsistentIndexes : 分片中索引不一致的分片集合数</strong><ul>
<li><a href="https://docs.mongodb.com/master/reference/parameters/#param.enableShardedIndexConsistencyCheck" target="_blank" rel="noopener"><code>enableShardedIndexConsistencyCheck</code></a></li>
<li><a href="https://docs.mongodb.com/master/reference/parameters/#param.shardedIndexConsistencyCheckIntervalMS" target="_blank" rel="noopener"><code>shardedIndexConsistencyCheckIntervalMS</code></a></li>
</ul>
</li>
</ul>
<h3 id="storageEngine"><a href="#storageEngine" class="headerlink" title="storageEngine"></a>storageEngine</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"storageEngine" : &#123;</span><br><span class="line">   "name" : &lt;string&gt;,</span><br><span class="line">   "supportsCommittedReads" : &lt;boolean&gt;,</span><br><span class="line">   "oldestRequiredTimestampForCrashRecovery" : Timestamp(0, 0),</span><br><span class="line">   "supportsPendingDrops" : true,</span><br><span class="line">   "dropPendingIdents" : NumberLong(0),</span><br><span class="line">   "supportsSnapshotReadConcern" : true,</span><br><span class="line">   "readOnly" : false,</span><br><span class="line">   "persistent" : &lt;boolean&gt;</span><br><span class="line">   "backupCursorOpen" : false</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>name : 当前存储引擎的名称</li>
<li>supportsCommittedReads : [3.2] 当前存储引擎是否支持 <code>majority read concern</code></li>
<li>persistent : [3.2.6] 是否支持持久化到磁盘</li>
</ul>
<h3 id="transactions"><a href="#transactions" class="headerlink" title="transactions"></a>transactions</h3><h4 id="run-on-mongod-3-6-3"><a href="#run-on-mongod-3-6-3" class="headerlink" title="run on mongod [3.6.3]"></a>run on mongod [3.6.3]</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"transactions" : &#123;</span><br><span class="line">   "retriedCommandsCount" : &lt;NumberLong&gt;,</span><br><span class="line">   "retriedStatementsCount" : &lt;NumberLong&gt;,</span><br><span class="line">   "transactionsCollectionWriteCount" : &lt;NumberLong&gt;,</span><br><span class="line">   "currentActive" : &lt;NumberLong&gt;,</span><br><span class="line">   "currentInactive" : &lt;NumberLong&gt;,</span><br><span class="line">   "currentOpen" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalAborted" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalCommitted" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalStarted" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalPrepared" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalPreparedThenCommitted" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalPreparedThenAborted" :  &lt;NumberLong&gt;,</span><br><span class="line">   "currentPrepared" :  &lt;NumberLong&gt;,</span><br><span class="line">   "lastCommittedTransaction" : &lt;document&gt; // Starting in 4.2.2 (and 4.0.9)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="run-on-mongos-4-2"><a href="#run-on-mongos-4-2" class="headerlink" title="run on mongos [4.2]"></a>run on mongos [4.2]</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   "currentOpen" : &lt;NumberLong&gt;,     // Starting in 4.2.1</span><br><span class="line">   "currentActive" : &lt;NumberLong&gt;,   // Starting in 4.2.1</span><br><span class="line">   "currentInactive" : &lt;NumberLong&gt;, // Starting in 4.2.1</span><br><span class="line">   "totalStarted" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalCommitted" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalAborted" : &lt;NumberLong&gt;,</span><br><span class="line">   "abortCause" : &#123;</span><br><span class="line">      &lt;String1&gt; : &lt;NumberLong&gt;,</span><br><span class="line">      &lt;String2&gt;" : &lt;NumberLong&gt;,</span><br><span class="line">      ...</span><br><span class="line">   &#125;,</span><br><span class="line">   "totalContactedParticipants" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalParticipantsAtCommit" : &lt;NumberLong&gt;,</span><br><span class="line">   "totalRequestsTargeted" : &lt;NumberLong&gt;,</span><br><span class="line">   "commitTypes" : &#123;</span><br><span class="line">      "noShards" : &#123;</span><br><span class="line">         "initiated" : &lt;NumberLong&gt;,</span><br><span class="line">         "successful" : &lt;NumberLong&gt;,</span><br><span class="line">         "successfulDurationMicros" : &lt;NumberLong&gt;,</span><br><span class="line">      &#125;,</span><br><span class="line">      "singleShard" : &#123;</span><br><span class="line">         "initiated" : &lt;NumberLong&gt;,</span><br><span class="line">         "successful" : &lt;NumberLong&gt;,</span><br><span class="line">         "successfulDurationMicros" : &lt;NumberLong&gt;,</span><br><span class="line">      &#125;,</span><br><span class="line">      "singleWriteShard" : &#123;</span><br><span class="line">         "initiated" : &lt;NumberLong&gt;,</span><br><span class="line">         "successful" : &lt;NumberLong&gt;,</span><br><span class="line">         "successfulDurationMicros" : &lt;NumberLong&gt;,</span><br><span class="line">      &#125;,</span><br><span class="line">      "readOnly" : &#123;</span><br><span class="line">         "initiated" : &lt;NumberLong&gt;,</span><br><span class="line">         "successful" : &lt;NumberLong&gt;,</span><br><span class="line">         "successfulDurationMicros" : &lt;NumberLong&gt;,</span><br><span class="line">      &#125;,</span><br><span class="line">      "twoPhaseCommit" : &#123;</span><br><span class="line">         "initiated" : &lt;NumberLong&gt;,</span><br><span class="line">         "successful" : &lt;NumberLong&gt;,</span><br><span class="line">         "successfulDurationMicros" :&lt;NumberLong&gt;,</span><br><span class="line">      &#125;,</span><br><span class="line">      "recoverWithToken" : &#123;</span><br><span class="line">         "initiated" : &lt;NumberLong&gt;,</span><br><span class="line">         "successful" : &lt;NumberLong&gt;,</span><br><span class="line">         "successfulDurationMicros" : &lt;NumberLong&gt;,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>retriedCommandsCount : [mongod3.6.3] 在可重入写操作提交后，总的重试次数</strong></li>
<li><strong>retriedStatementsCount : [mongod3.6.3] retriedCommandsCount中涉及的statment总数</strong></li>
<li><strong>transactionsCollectionWriteCount : [mongod3.6.3] 当可重入写操作提交后，触发写入config.transaction次数</strong></li>
<li><strong>currentActive : [mongod4.0.2 &amp; mongos4.2.1] 当前活跃的transaction数</strong></li>
<li><strong>currentInactive : [mongod4.0.2 &amp; mongos4.2.1] 当前不活跃的事务数</strong></li>
<li><strong>currentOpen : [mongod4.0.2 &amp; mongos4.2.1] 当前open的事务数</strong></li>
<li><strong>currentPrepared : [mongod4.2] 当前prepare的事务数</strong></li>
<li><strong>totalPrepared : [mongod4.2] 启动以来prepare的事务数</strong></li>
<li><strong>totalPreparedThenCommitted : [mongod4.2] 启动以来prepare然后commit的事务数</strong></li>
<li><strong>totalPreparedThenAborted : [mongod4.2] 启动以来prepare然后abort的事务数</strong></li>
<li><strong>totalStarted : [mongod4.0.2 &amp; mongos4.2] 启动以来总的start的事务数</strong></li>
<li><strong>totalCommitted : [mongod4.0.2 &amp; mongos4.2] 启动以来总的commit事务数</strong></li>
<li><strong>totalAborted : [mongod4.0.2 &amp; mongos4.2] 启动以来总的abort事务数</strong></li>
<li><strong>abortCause : [mongos4.2] abort的原因及数量。abort / DuplicateKey / StaleConfig / SnapshotTooOld 等</strong></li>
<li>lastCommittedTransaction : [mongod4.2.2 &amp; 4.0.9] primary节点汇报上次commit事务的信息，secondary节点汇报曾经是primary时上次提交的信息<ul>
<li>operationCount : 事务中的写操作数</li>
<li>oplogOperationBytes : 事务相应oplog大小</li>
<li>writeConcern : 事务的write concern</li>
</ul>
</li>
<li><strong>totalContactedParticipants ：[mongos4.2] 启动以来因事务联系的shard总数</strong></li>
<li><strong>totalParticipantsAtCommit ： [mongos4.2] 启动以来事务提交涉及的shard总数</strong></li>
<li><strong>totalRequestsTargeted ： [mongos4.2] 启动以来mongos发起的事务请求总数</strong></li>
<li><strong>commitTypes ： [mongos4.2] 提交类型</strong><ul>
<li><strong><type></strong><ul>
<li><strong>noShards : commit不需要联系任何shard</strong></li>
<li><strong>singleShard : commit只影响单个shard</strong></li>
<li><strong>singleWriteShard : commit影响多个shard，但是写操作只影响一个shard</strong></li>
<li><strong>readOnly : 只读事务</strong></li>
<li><strong>twoPhaseCommit : commit包含多个shard的写入操作</strong></li>
<li><strong>recoverWithToken : 在另一个实例或者当前实例重启后恢复的提交的事务数</strong></li>
</ul>
</li>
<li><strong><metric></strong><ul>
<li><strong>initiated : 发起该类commit的总数</strong></li>
<li><strong>successful : 该类commit成功的总数</strong></li>
<li><strong>successfulDurationMicros : 该类commit成功提交的总耗时</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="transportSecurity-4-0-2-amp-3-6-7-amp-3-4-17"><a href="#transportSecurity-4-0-2-amp-3-6-7-amp-3-4-17" class="headerlink" title="transportSecurity [4.0.2 &amp; 3.6.7+ &amp; 3.4.17+]"></a>transportSecurity [4.0.2 &amp; 3.6.7+ &amp; 3.4.17+]</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"transportSecurity" : &#123;</span><br><span class="line">   "1.0" : &lt;NumberLong&gt;,</span><br><span class="line">   "1.1" : &lt;NumberLong&gt;,</span><br><span class="line">   "1.2" : &lt;NumberLong&gt;,</span><br><span class="line">   "1.3" : &lt;NumberLong&gt;,</span><br><span class="line">   "unknown" :&lt;NumberLong&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>mongod启动以来，使用对应TLS版本的连接数</p>
<h3 id="writeBacksQueued-TODO"><a href="#writeBacksQueued-TODO" class="headerlink" title="writeBacksQueued // TODO"></a>writeBacksQueued // TODO</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"writeBacksQueued" : &lt;boolean&gt;,</span><br></pre></td></tr></table></figure>



<h3 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"mem" : &#123;</span><br><span class="line">   "bits" : &lt;int&gt;,</span><br><span class="line">   "resident" : &lt;int&gt;,</span><br><span class="line">   "virtual" : &lt;int&gt;,</span><br><span class="line">   "supported" : &lt;boolean&gt;,</span><br><span class="line">   "mapped" : &lt;int&gt;,</span><br><span class="line">   "mappedWithJournal" : &lt;int&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>bits : <code>64</code> or <code>32</code> , 标识实例是被64位还是32位编译的</li>
<li><strong>resident : resident memory, MB</strong></li>
<li><strong>virtual : virtual memory, MB</strong></li>
<li>supported : 标识是否支持扩展内存信息</li>
<li>mapped : supported = false时的补充说明信息</li>
<li>mappedWithJournal : </li>
</ul>
<h3 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">"metrics" : &#123;</span><br><span class="line">   "aggStageCounters" : &#123;</span><br><span class="line">         "&lt;aggregation stage&gt;" : &lt;num&gt;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   "commands": &#123;</span><br><span class="line">         "&lt;command&gt;": &#123;</span><br><span class="line">            "failed": &lt;num&gt;,</span><br><span class="line">            "total": &lt;num&gt;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   "cursor" : &#123;</span><br><span class="line">         "timedOut" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "open" : &#123;</span><br><span class="line">            "noTimeout" : NumberLong(&lt;num&gt;),</span><br><span class="line">            "pinned" : NumberLong(&lt;num&gt;),</span><br><span class="line">            "multiTarget" : NumberLong(&lt;num&gt;),</span><br><span class="line">            "singleTarget" : NumberLong(&lt;num&gt;),</span><br><span class="line">            "total" : NumberLong(&lt;num&gt;),</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   "document" : &#123;</span><br><span class="line">         "deleted" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "inserted" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "returned" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "updated" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;,</span><br><span class="line">   "getLastError" : &#123;</span><br><span class="line">         "wtime" : &#123;</span><br><span class="line">            "num" : &lt;num&gt;,</span><br><span class="line">            "totalMillis" : &lt;num&gt;</span><br><span class="line">         &#125;,</span><br><span class="line">         "wtimeouts" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "default" : &#123;</span><br><span class="line">             "unsatisfiable" : &lt;num&gt;</span><br><span class="line">             "wtimeouts" : &lt;num&gt;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   "operation" : &#123;</span><br><span class="line">         "scanAndOrder" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "writeConflicts" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;,</span><br><span class="line">   "queryExecutor": &#123;</span><br><span class="line">         "scanned" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "scannedObjects" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;,</span><br><span class="line">   "record" : &#123;</span><br><span class="line">         "moves" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;,</span><br><span class="line">   "repl" : &#123;</span><br><span class="line">      "executor" : &#123;</span><br><span class="line">         "pool" : &#123;</span><br><span class="line">            "inProgressCount" : &lt;num&gt;</span><br><span class="line">         &#125;,</span><br><span class="line">         "queues" : &#123;</span><br><span class="line">            "networkInProgress" : &lt;num&gt;,</span><br><span class="line">            "sleepers" : &lt;num&gt;</span><br><span class="line">         &#125;,</span><br><span class="line">         "unsignaledEvents" : &lt;num&gt;,</span><br><span class="line">         "shuttingDown" : &lt;boolean&gt;,</span><br><span class="line">         "networkInterface" : &lt;string&gt;</span><br><span class="line">      &#125;,</span><br><span class="line">      "apply" : &#123;</span><br><span class="line">         "attemptsToBecomeSecondary" : &lt;NumberLong&gt;,</span><br><span class="line">         "batches" : &#123;</span><br><span class="line">            "num" : &lt;num&gt;,</span><br><span class="line">            "totalMillis" : &lt;num&gt;</span><br><span class="line">         &#125;,</span><br><span class="line">         "ops" : &lt;NumberLong&gt;</span><br><span class="line">      &#125;,</span><br><span class="line">      "buffer" : &#123;</span><br><span class="line">         "count" : &lt;NumberLong&gt;,</span><br><span class="line">         "maxSizeBytes" : &lt;NumberLong&gt;,</span><br><span class="line">         "sizeBytes" : &lt;NumberLong&gt;</span><br><span class="line">      &#125;,</span><br><span class="line">      "initialSync" : &#123;</span><br><span class="line">         "completed" : &lt;NumberLong&gt;,</span><br><span class="line">         "failedAttempts" : &lt;NumberLong&gt;,</span><br><span class="line">         "failures" : &lt;NumberLong&gt;,</span><br><span class="line">      &#125;,</span><br><span class="line">      "network" : &#123;</span><br><span class="line">         "bytes" : &lt;NumberLong&gt;,</span><br><span class="line">         "getmores" : &#123;</span><br><span class="line">            "num" : &lt;num&gt;,</span><br><span class="line">            "totalMillis" : &lt;num&gt;</span><br><span class="line">         &#125;,</span><br><span class="line">         "notMasterLegacyUnacknowledgedWrites" : &lt;NumberLong&gt;,</span><br><span class="line">         "notMasterUnacknowledgedWrites" : &lt;NumberLong&gt;,</span><br><span class="line">         "ops" : &lt;NumberLong&gt;,</span><br><span class="line">         "readersCreated" : &lt;NumberLong&gt;,</span><br><span class="line">         "replSetUpdatePosition" : &#123;</span><br><span class="line">             "num" : &lt;NumberLong&gt;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "stepDown" : &#123;</span><br><span class="line">         "userOperationsKilled" : &lt;NumberLong&gt;,</span><br><span class="line">         "userOperationsRunning" : &lt;NumberLong&gt;</span><br><span class="line">      &#125;,</span><br><span class="line">      "syncSource" : &#123;</span><br><span class="line">         "numSelections" : &lt;NumberLong&gt;,</span><br><span class="line">         "numTimesChoseSame" : &lt;NumberLong&gt;,</span><br><span class="line">         "numTimesChoseDifferent" : &lt;NumberLong&gt;,</span><br><span class="line">         "numTimesCouldNotFind" : &lt;NumberLong&gt;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   "storage" : &#123;</span><br><span class="line">         "freelist" : &#123;</span><br><span class="line">            "search" : &#123;</span><br><span class="line">               "bucketExhausted" : &lt;num&gt;,</span><br><span class="line">               "requests" : &lt;num&gt;,</span><br><span class="line">               "scanned" : &lt;num&gt;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   "ttl" : &#123;</span><br><span class="line">         "deletedDocuments" : NumberLong(&lt;num&gt;),</span><br><span class="line">         "passes" : NumberLong(&lt;num&gt;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>aggStageCounters : [4.4 &amp; 4.2.6 &amp; 4.0.19] 使用 <code>aggregation pipeline stage</code> 各个stage的执行次数</li>
<li><strong>commands :</strong></li>
<li><strong><command>.failed : 启动以来<command> fail次数</strong><ul>
<li><strong><command>.total : 启动以来<command> 执行次数</strong></li>
</ul>
</li>
<li>cursor : <ul>
<li><strong>timedOut : cursor因timeout关闭的数量</strong><ul>
<li><strong>open.noTimeout : open cursor中设置了 <code>noTimeOut</code>的数量</strong></li>
<li><strong>open.pinned : open cursor中 pinned的数量</strong></li>
<li><strong>open.multiTarget : [mongos] 仅指向到一个shard的cursor数量</strong></li>
<li><strong>open.singleTarget : [mongos] 指向到多余1个shard的cursor数量</strong></li>
<li><strong>open.total : 维护的open cursor总数</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>document : 文档访问或者修改的数量。[deleted / inserted / returned / updated]</strong></li>
<li>getLastError : <ul>
<li>wtime.num : <code>getLastError</code>操作 w &gt; 1 的次数</li>
<li>wtime.totalMillis : <code>getLastError</code>操作 w &gt; 1 的时间</li>
<li>wtimeouts : <code>getLastError</code> 触发 <code>wtimeout</code>的次数</li>
<li>default : <ul>
<li>unsatisfiable : 返回unsatisfiable的次数</li>
<li>wtimeouts : 返回wtimeouts的次数</li>
</ul>
</li>
</ul>
</li>
<li>operation : <ul>
<li><strong>scanAndOrder : 无法使用index进行sort的请求数</strong></li>
<li><strong>writeConflicts : 发生write conflict的次数</strong><ul>
<li>queryExecutor ：</li>
<li><strong>scanned : 查询和查询计划中评估扫描索引项的数量， = <code>explain().totalKeysExamined</code></strong></li>
<li><strong>scannedObjects : 查询和查询计划中评估扫描document的数量， = <code>explain().totalDocsExamined</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>query</li>
</ul>
<ul>
<li><ul>
<li><strong>planCacheTotalSizeEstimateBytes : plan cache占用内存量</strong></li>
</ul>
</li>
<li><ul>
<li><strong>updateOneOpStyleBroadcastWithExactIDCount : update请求的{multi:false} ， 但是需要broadcast去获取匹配的_id信息</strong></li>
</ul>
</li>
<li><p>repl : </p>
<ul>
<li>executor : ReplicationCoordinator使用的TaskExecutor的信息<ul>
<li>pool.inProgressCount : 执行队列长度</li>
<li>queues.networkInProgress : 等待网络线程返回结果队列长度</li>
<li>queues.sleepers : sleep队列长度</li>
<li>unsignaledEvents : 阻塞时间列表</li>
<li>shuttingDown : 是否shutdown</li>
<li>networkInterface : 简单说明 // DEPRECATED: getDiagnosticString is deprecated in NetworkInterfaceTL</li>
</ul>
</li>
<li>apply : 记录从replication中apply的oplog信息<ul>
<li><strong>batchSize : [4.0.6 &amp; 3.6.11] 启动以来apply的oplog总数，一批apply以后会增加批的总操作数</strong></li>
<li>attemptsToBecomeSecondary : </li>
<li><strong>batches.num : 接收的batch数</strong></li>
<li><strong>batches.totalMillis : apply oplog花费的总时间</strong></li>
<li><strong>ops : 启动以来apply的oplog总数，每次apply都会增加</strong></li>
</ul>
</li>
<li>buffer : <ul>
<li><strong>count : oplog buffer中operation的数量</strong></li>
<li>maxSizeBytes : oplog buffer的最大值</li>
<li>sizeBytes : 当前oplog buffer的大小</li>
</ul>
</li>
<li>initialSync : <ul>
<li><strong>completed : initialSync成功的次数</strong></li>
<li><strong>failedAttempts : initialSync 失败重试的次数</strong></li>
<li><strong>failures : initialSync 最终失败的次数</strong></li>
</ul>
</li>
<li>network : <ul>
<li><strong>bytes : 从复制源读取到的数据总数</strong></li>
<li><strong>getmores.num : 从复制源请求其他操作集合的getMore总数</strong></li>
<li><strong>getmores.totalMillis : getMore总耗时</strong></li>
<li>getmores.numEmptyBatches : [4.4] getMore从复制源获取到空oplog的总数</li>
<li>notMasterLegacyUnacknowledgedWrites : [4.2] 由于当前节点未进入primary状态，导致未确认的legacy写操作失败数</li>
<li>notMasterUnacknowledgedWrites : [4.2] 由于当前节点未进入primary状态，导致未确认的写操作失败数</li>
<li><strong>ops : 从复制源读取到的总ops数</strong></li>
<li>readersCreated : 创建oplog查询进程总数。当链接发生错误时会进行创建，修改数据源也会进行创建</li>
<li>replSetUpdatePosition.num : [4.4] 发送给复制源 <code>replSetUpdatePosition</code> 数量</li>
</ul>
</li>
<li>stepDown : [4.2] <ul>
<li><strong>userOperationsKilled : [4.2] stepDown时kill的用户操作数</strong></li>
<li><strong>userOperationsRunning : [4.2] stepDown时仍然保留的用户操作数</strong></li>
</ul>
</li>
<li>syncSource : [4.4]<ul>
<li><strong>numSelections : [4.4] 节点重新从可用复制源选择复制源的总数</strong></li>
<li><strong>numTimesChoseSame : [4.4] 重新评估复制源时仍然选择相同复制源的次数</strong></li>
<li><strong>numTimesChoseDifferent : [4.4]  重新评估复制源时仍然选择不同复制源的次数</strong></li>
<li><strong>numTimesCouldNotFind : [4.4] 尝试选择同步源却无法找到的次数</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>storage : </p>
<ul>
<li>freelist.search.bucketExhausted : 从freelist中查找未找到适合大小的空间次数</li>
<li>freelist.search.requests : 搜索可用空间次数</li>
<li>freelist.search.scanned : 搜索到可用空间次数</li>
</ul>
<ul>
<li><p>ttl : </p>
<ul>
<li><strong>deletedDocuments : ttl索引删除的文档数</strong></li>
<li><strong>passes : 后台ttl线程进行删除的次数</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="watchdog-3-6-TODO"><a href="#watchdog-3-6-TODO" class="headerlink" title="watchdog [3.6] // TODO"></a>watchdog [3.6] // TODO</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"watchdog" : &#123;</span><br><span class="line">   "checkGeneration" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "monitorGeneration" : NumberLong(&lt;num&gt;),</span><br><span class="line">   "monitorPeriod" : &lt;num&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a>tcmalloc</h3><p>记录tcmalloc占用的内存指标，方便内存分析。</p>
<ul>
<li><p><strong>pageheap_free_bytes : heap中空闲的内存</strong></p>
</li>
<li><p><strong>total_free_bytes = = <code>central_cache_free_bytes + transfer_cache_free_bytes + thread_cache_free_bytes</code> , 不包括pageheap_free_bytes</strong></p>
</li>
<li><p><strong>central_cache_free_bytes</strong></p>
</li>
<li><p><strong>transfer_cache_free_bytes</strong></p>
</li>
<li><p><strong>thread_cache_free_bytes</strong></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/MongoDB-Timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/MongoDB-Timer/" itemprop="url">MongoDB 源码中定时器机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T09:42:24+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MongoDB 提供了2种定时执行机制</p>
<ul>
<li><code>TaskExecutor::scheduleWorkAt(Date_t when, CallbackFn&amp;&amp; work)</code></li>
<li><code>PeriodicRunner::PeriodicJob</code></li>
</ul>
<h2 id="TaskExecutor-scheduleWorkAt"><a href="#TaskExecutor-scheduleWorkAt" class="headerlink" title="TaskExecutor::scheduleWorkAt"></a>TaskExecutor::scheduleWorkAt</h2><p><code>TaskExecutor::scheduleWorkAt</code> 提供了一个在指定时间 <code>when</code> 执行的方式，具体在 <code>ThreadPoolTaskExecutor</code> 中实现。</p>
<p><code>ThreadPoolTaskExecutor</code>实现 <code>scheduleWorkAt</code> 方法和 <code>scheduleWork</code> 逻辑基本一致：将 <code>CallbackFn</code> 添加到一个 <code>WorkQueue</code> 中，并获得一个 <code>CallbackHandle</code>，随后将 <code>WorkQueue</code> 插入到 <code>_poolInProgressQueue</code> 中等待被处理。区别在于：</p>
<ul>
<li><code>scheduleWork</code> 将 <code>CallbackFn</code> 添加到一个 temp 的 WorkQueue，而 <code>scheduleWorkAt</code> 添加到 <code>_sleepersQueue</code></li>
<li><code>scheduleWork</code> 中直接将 <code>WorkQueue</code> 中数据插入到 <code>_poolInProgressQueue</code> 中，而 <code>scheduleWorkAt</code> 则是通过 <code>_net::setAlarm</code> 注册一个时间 when 后回调插入的(<code>_net</code> 为一个 <code>NetworkInterfaceTL</code> 成员)。</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusWith&lt;TaskExecutor::CallbackHandle&gt; <span class="title">ThreadPoolTaskExecutor::scheduleWorkAt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Date_t when, CallbackFn&amp;&amp; work)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> wq = makeSingletonWorkQueue(<span class="built_in">std</span>::<span class="built_in">move</span>(work), <span class="literal">nullptr</span>, when);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> cbHandle = enqueueCallbackState_inlock(&amp;_sleepersQueue, &amp;wq);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> status = _net-&gt;setAlarm(cbHandle.getValue(), </span><br><span class="line">                                 when, </span><br><span class="line">                                 [<span class="keyword">this</span>, cbHandle = cbHandle.getValue()](Status status) &#123;</span><br><span class="line">            ...</span><br><span class="line">            scheduleIntoPool_inlock(&amp;_sleepersQueue, cbState-&gt;iter, <span class="built_in">std</span>::<span class="built_in">move</span>(lk));</span><br><span class="line">        &#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cbHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> <strong>Note:</strong>   <code>scheduleWorkAt</code> 和 <code>scheduleWork</code> 都会返回一个 <code>TaskExecutor::CallbackHandle</code> 对象  <code>cbHandle</code>，这个 <code>cbHandle</code> <em>不是一个回调函数*，应该是表示回调状态 的一个对象， <code>CallbackHandle</code> 持有一个 <code>CallbackState</code> , 而 <code>CallbackState</code> 的类注释为 *”Class representing a  scheduled callback and providing methods for interacting with it.”</em></p>
<p>具体的回调函数即上文提到的 <code>CallbackFn</code> 被添加到 <code>WorkQueue</code>  中，而后被添加到*   <code>_poolInProgressQueue</code> 等待被消费</p>
</blockquote>
<p><code>NetworkInterfaceTL::setAlarm</code> 接收 3 个入参：<code>cbHandle</code>, <code>when</code>, <code>action</code>，<code>cbHandle</code> 主要做一些 状态管理 、 合理性校验等逻辑。action即为当面提到的将 <code>WorkQueue</code> 添加到 <code>_poolInProgressQueue</code> 的回调。</p>
<p><code>NetworkInterfaceTL::setAlarm</code> 中 构造了一个 <code>PromiseFuture</code> 对象 <strong>pf ( future为 action）</strong>，并将时间点 when，回调状态 <code>cbHandle</code>，新建一个 <code>ASIOReactorTimer timer</code>，以及 pf.promise 封装成一个 <code>AlarmState</code> 。然后调用 <code>timer-&gt;waitUntil( when )</code> 等待到达指定时间（witerUntil 实际上也是返回一个 Future），指定时间到达时调用 <code>_answerAlarm</code> 标记 满足 promise（及触发上文 action ）</p>
<p> 关于指定时间执行的行为则在 <code>NetworkInterfaceTL::setAlarm</code> 中实现。</p>
<p><code>ASIOReactorTimer</code> 中会持有一个 <code>_timer (asio::system_timer)</code> ，<code>waitUntil()</code> 中会依次调用 <code>_timer-&gt;expires_at()</code>, <code>_timer-&gt;async_wait()</code>进行计时等待</p>
<p><strong>总结一下</strong>：<code>TaskExecutor::scheduleWorkAt</code> 实际上是基于 <code>asio::system_timer</code> 库实现的指定时间执行逻辑。</p>
<ul>
<li>指定时间到达后，会标记 满足 promise ，调用 <code>_answerAlarm</code> </li>
<li><code>_answerAlarm</code> 中进行一系列判断后 也会标记 满足 promise ， 调用 action</li>
<li>action 中 会将 <code>_sleepersQueue</code> 中的数据插入到 <code>_poolInProgressQueue</code> 排队等待执行</li>
</ul>
<p>由于 整个逻辑中回调函数比较多，所以堆栈会比较冗长，这里是以 为例的堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#0  mongo::ReplicaSetMonitor::_doScheduledRefresh (this&#x3D;0x7f0362e0fb00, currentHandle&#x3D;...) at src&#x2F;mongo&#x2F;client&#x2F;replica_set_monitor.cpp:249</span><br><span class="line">#5  0x00007f035e3fdd28 in mongo::executor::ThreadPoolTaskExecutor::runCallback (this&#x3D;0x7f0362e19140, cbStateArg&#x3D;...) at src&#x2F;mongo&#x2F;executor&#x2F;thread_pool_task_executor.cpp:659</span><br><span class="line">#7  0x00007f035e3ff7ad in mongo::executor::ThreadPoolTaskExecutor::scheduleIntoPool_inlock(mongo::executor::ThreadPoolTaskExecutor::WorkQueue*, const iterator&amp;, const iterator&amp;, std::unique_lock&lt;std::mutex&gt;)</span><br><span class="line">#16 0x00007f035e3fee44 in mongo::executor::ThreadPoolTaskExecutor::scheduleWorkAt(mongo::Date_t, mongo::executor::TaskExecutor::CallbackFn&amp;&amp;)</span><br><span class="line">#30 0x00007f035e43d6f2 in mongo::executor::NetworkInterfaceTL::_answerAlarm(mongo::Status, std::shared_ptr&lt;mongo::executor::NetworkInterfaceTL::AlarmState&gt;)</span><br></pre></td></tr></table></figure>



<h2 id="PeriodicRunner-PeriodicJob"><a href="#PeriodicRunner-PeriodicJob" class="headerlink" title="PeriodicRunner::PeriodicJob"></a>PeriodicRunner::PeriodicJob</h2><p> Periodic* 类涉及3个接口：</p>
<ul>
<li><code>PeriodicJob</code> 描述一个周期性 job，接收3个参数：<strong>job名称 name, Job执行逻辑 callable, 执行间隔 period</strong></li>
<li><code>ControllableJob : PeriodicJob</code> 实际执行逻辑，<em>start / pause / resume / stop</em> .      <ul>
<li><code>PeriodicJobImpl</code> 继承实现了该类。</li>
</ul>
</li>
<li><code>PeriodicJobAnchor</code> : 包装一个 <code>ControllableJob</code> ，用于控制 <code>ControllableJob</code> 的执行。<em>start / pause /     resume / stop</em> .</li>
<li><code>PeriodicRunner</code> ： 提供一个<code>makeJob</code> – 初始化 <code>PeriodicJob</code> / <code>PeriodicJobImpl</code> / <code>PeriodicJobAnchor</code>.<ul>
<li><code>PeriodicRunnerImpl</code> 继承实现了该类</li>
</ul>
</li>
</ul>
<p>上面这几个接口主要提供 job 的描述，job 运行的管理，但是也有2个比较奇怪的地方：</p>
<ul>
<li><code>PeriodicJobImpl</code> 看名称疑似 <code>PeriodicJob</code> 的具体实现，然而却是 <code>ControllableJob</code> 的实现</li>
<li><code>PeriodicJobAnchor</code> 和 <code>ControllableJob</code> 都提供了 job 的 <em>start / pause / resume / stop</em> 行为。<code>PeriodicJobAnchor</code> 中包装一个 <code>ControllableJob</code> 对象 _handle，所有的 job 行为也都直接调用了 _handle 对应的函数</li>
</ul>
<p>每个 job 有独立的线程处理，线程的名称即为 job 的名称。job 的运行管理在 <code>PeriodicJobImpl::_run</code> 中实现，负责管理的 <em>pause / resume / stop</em> 等行为会修改 job 的执行状态，<code>_run</code> 在执行前根据被标记的执行状态作出具体的处理。</p>
<p>正常情况下( RUNNING状态 )，_run 会调用 <code>clockSource-&gt;waitForConditionUntil</code>  ( _clockSource 为 <code>servicecontext -&gt;getPreciseClockSource()</code> )，这中间由于 <code>tracksSystemClock = true / waitable = null</code>，所以时间等待最终的实现是 <code>stdx::condition_variable.wait_util(lock, deadline);</code></p>
<blockquote>
<p><strong>Note:</strong>   PeriodicRunner::PeriodicJob 虽然进行初始化的时候传入的是一个 interval ，但是实际最终执行还是基于上次  job 开始执行的时间 + interval 获得一个 deadline 来定义下一次任务的触发时</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/MongoDB-ReplicaSetMonitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/MongoDB-ReplicaSetMonitor/" itemprop="url">MongoDB ReplicaSetMonitor对shard探测机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-27T12:59:24+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>sharding实例对后端 shard 会进行状态探测，以发现 shard 是否有节点更新（ 选主、节点加入、节点异常）。提供探测能力的核心类为 <code>ReplicaSetMonitor</code> 及相关类。</p>
<p>对于状态探测的基本逻辑应该也比较好构思：<strong>定期状态探测、探测结果存储、探测结果查询</strong>。MongoDB中也按照这个逻辑来完成的： </p>
<ul>
<li><p><code>ReplicaSetMonitor</code> 提供状态查询的接口，以及定期探测触发能力。状态信息存储在 <code>_state</code> (<code>SetState</code>类型成员变量) 中</p>
</li>
<li><p><code>SetState</code> 存储 ReplicaSet shard 的状态信息。包装 Node 记录各个 Node 的信息，持有一个 <code>ScanState</code> 记录该 ReplicaSet 当前正在 scan 的信息</p>
</li>
<li><p>Refresher 进行实际的状态探测，提供一个 static 方法 <code>ensureScanInProgress</code> 来初始化一个 Refresher 进行探测。</p>
<ul>
<li><code>Refresher</code> 与 <code>SetState</code> 是一一绑定的，只有 <code>SetState</code> 在被探测状态，才会有对应的 <code>Refresher</code> 产生</li>
</ul>
</li>
<li><p><code>ScanState</code> 记录 <code>Refresher</code> 探测过程中的状态信息。<code>ScanState</code> 会被 <code>SetState::currentScan</code> 及 <code>Refresher::_scan</code> 持有，一般情况下这2个 scan 是相同的，但是可能存在并发的场景导致指向的不是同一个 scan， 这时候以 <code>SetState::currentScan</code> 为准。</p>
</li>
</ul>
<p>ReplicaSetMonitor / SetState / Refresher / ScanState 具体关系参考下图：</p>
<p><img src="https://wangxin201492.github.io/techImages/MongoDB-ReplicaSetMonitor.png" alt="MongoDB-ReplicaSetMonitor.png"></p>
<h2 id="探测目标-shard-要求"><a href="#探测目标-shard-要求" class="headerlink" title="探测目标 shard 要求"></a>探测目标 shard 要求</h2><p><strong>只有以 ReplicaSet 方式启动的 shard(包含 config )，才会持有一个 <code>ReplicaSetMonitor</code> 类的成员。</strong>即只有 ReplicaSet shard 才会被探测，以 Standalong 方式启动的 shard 不会进行探测</p>
<h2 id="探测触发"><a href="#探测触发" class="headerlink" title="探测触发"></a>探测触发</h2><p>ReplicaSetMonitor 中会<strong>定期进行 shard 状态探测</strong>，如果当前维系的状态<strong>不能满足其他代码的 ReadPreference 要求，也会下发探测</strong></p>
<h3 id="定期探测"><a href="#定期探测" class="headerlink" title="定期探测"></a>定期探测</h3><p><code>ReplicaSetMonitor</code> 初始化时会调用<code>_scheduleRefresh</code>，而后通过 <code>_scheduleRefresh</code> 和 <code>_doScheduledRefresh</code> 两个函数相互调用及 <code>TaskExecutor::scheduleWorkAt</code> 完成:</p>
<ul>
<li><code>_scheduleRefresh</code>中通过使用 <code>TaskExecutor::scheduleWorkAt</code> 注册定时任务，定时任务负责调用 <code>_doScheduledRefresh</code></li>
<li><code>_doScheduledRefresh</code> 负责调用 <code>Refresher::ensureScanInProgress</code> 进行 <code>Refresher</code> 新建与 探测下发。同时根据当前 <code>SetState</code> 的状态来决定下次刷新的周期，然后调用 <code>_scheduleRefresh</code> 注册新的定时任务</li>
</ul>
<p>默认情况下，定时任务每隔 <strong>kDefaultRefreshPeriod (30s)</strong> 执行一次。但是如果 SetState 的 waiters 结构中非空，则会将周期调整为 <strong>kExpeditedRefreshPeriod (500ms)</strong> 。SetState 的 waiters 结构中 数据添加在下文按需探测时，数据清理在探测执行完成时。</p>
<h3 id="按需探测"><a href="#按需探测" class="headerlink" title="按需探测"></a>按需探测</h3><p>代码中需要按照某种 ReadPreference 获得 shard 的部分节点地址时，会调用 ReplicaSetMonitor 提供 <code>getHostsOrRefresh</code> 函数。如果当前持有的 shard 信息不能满足 ReadPreference 时，会构造一个 promise-future，返回 future ，然后将 promise 添加到 SetState 的 waiter 中，并立即下发刷新。</p>
<ul>
<li>如果刷新结果能满足 ReadPreference ，则返回对应的host</li>
<li>如果不能满足，则会按照上文描述，下次 <code>_doScheduledRefresh</code> 被调用时，将刷新周期改为 <strong>500ms</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ReplicaSetMonitor::_doScheduledRefresh(<span class="keyword">const</span> CallbackHandle&amp; currentHandle) &#123;</span><br><span class="line">    ....</span><br><span class="line">    Refresher::ensureScanInProgress(_state, lk);</span><br><span class="line"></span><br><span class="line">    Milliseconds period = _state-&gt;refreshPeriod;</span><br><span class="line">    <span class="keyword">if</span> (_state-&gt;isExpedited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_state-&gt;waiters.empty()) &#123;</span><br><span class="line">            <span class="comment">// No current waiters so we can stop the expedited scanning.</span></span><br><span class="line">            _state-&gt;isExpedited = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            period = <span class="built_in">std</span>::<span class="built_in">min</span>(period, kExpeditedRefreshPeriod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _scheduleRefresh(_state-&gt;now() + period, lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="探测方式"><a href="#探测方式" class="headerlink" title="探测方式"></a>探测方式</h2><p>探测的核心 就是发送 <strong>isMaster()</strong> 命令并处理返回结果。</p>
<p>探测的中间状态记录在上文描述的 <strong>ScanState</strong> 中，主要持有几个 成员 来实现：</p>
<ul>
<li><strong>hostsToScan</strong> : 待执行队列</li>
<li><strong>possibleNodes</strong> :     非primary节点返回的node集合</li>
<li><strong>waitingFor</strong> : 已经发送命令，等待返回的集合</li>
<li><strong>triedHosts</strong> : 已经下发isMaster命令的集合</li>
</ul>
<p>探测过程有一个简单的状态机：<strong>CONTACT_HOST</strong>、<strong>WAIT</strong>、<strong>DONE</strong>，基于上面描述的 ScanState 持有的几个成员来判断：</p>
<ul>
<li><strong>CONTACT_HOST</strong> : 链接当前实例。如果 <strong>hostsToScan</strong> 中有 host，则会返回该 host 并标记状态为 <strong>CONTACT_HOST</strong></li>
<li><strong>WAIT</strong> : 等待 response 。如果 <strong>hostsToScan</strong> 为空，而 <strong>waitingFor</strong> 不为空则标记为 WAIT 状态</li>
<li><strong>DONE</strong> : Refresh 完成。如果 <code>_scan != _set-&gt;currentScan</code> 或者 <strong>hostsToScan</strong> &amp; <strong>waitingFor</strong> 均为空，则为 <strong>DONE</strong> 状态</li>
</ul>
<p>状态流转都在<code>getNextStep</code>中实现，用于<code>scheduleNetworkRequests</code>调度流转。</p>
<p><code>IsMasterReply</code> : 记录isMaster必要的返回信息</p>
<h3 id="请求下发"><a href="#请求下发" class="headerlink" title="请求下发"></a>请求下发</h3><p><code>scheduleNetworkRequests</code> 通过 <code>getNextStep</code> 依次从 <strong>hostsToScan</strong> 拿到一个host信息，并将 host 信息插入到 <strong>waitingFor</strong> 及 <strong>triedHosts</strong> 这 2 个 set 中。然后针对这个 host 调用 <code>scheduleIsMaster</code> </p>
<p><code>scheduleIsMaster</code> 构建一个 isMaster 的request ，提交给 executor ，并注册回调：</p>
<ul>
<li>如果当前 Refresher 的 <code>_scan</code> 和 <code>_set-&gt;currentScan</code> 不同，则忽略返回结果</li>
<li>如果返回结果是 ok，则调用 <code>receivedIsMaster</code>；否则调用 <code>failedHost</code></li>
</ul>
<h3 id="response处理"><a href="#response处理" class="headerlink" title="response处理"></a>response处理</h3><p><code>receivedIsMaster</code> : 将 host 从 waitingFor 中清理掉，然后构建一个 <code>IsMasterReply</code></p>
<ul>
<li>如果 <code>IsMasterReply</code> 的结果不是 ok ， 则会标记当前 host 为 fail</li>
<li>如果 reply 中 setName 和 _set 中的 name 不匹配，则会标记当前 host 为 fail</li>
<li>如果 reply 声明自己是 primary 节点， 则会调用 <code>receivedIsMasterFromMaster</code></li>
<li>找到 primary 节点以后的 reply 处理： 将 reply 更新到对应的 <code>_set</code> 的 node 上，并在 notify 中判断是否有已经满足 <code>_set-&gt;waiter</code> 的 promise，有则返回</li>
<li>未找到 primary 节点前的 reply 处理： 将 reply 的 member 全部加到 <strong>possibleNodes</strong> 中，如果在 reply 中声明了 primary 节点的地址且该 primary </li>
<li>在 <strong>triedHosts</strong> 中，则将该节点重新添加会 <strong>hostsToScan</strong>。然后将该 reply 记录到 <strong>unconfirmedReplies</strong> 中</li>
</ul>
<p><code>receivedIsMasterFromMaster</code> 处理逻辑比较多，简单整理了下：</p>
<ul>
<li>有效性判断：判断 <code>configVersion</code> / <code>electionId</code> 的有效性</li>
<li>状态存储：将 reply 的结果更新到 <code>SetState</code> 中。更新nodes / seedNodes / seedConnStr / workingConnstr</li>
<li>清理<code>ScanState</code> 中记录的信息：<strong>triedHost</strong> / <strong>waiitingFor</strong> / <strong>unconfirmedReplies</strong></li>
<li>如果 primary 有变化，则会通知所有的 listener 状态变更。</li>
</ul>
<p><code>failedHost</code> : 将 host从 <strong>waitingFor</strong> 中移除，并将node标记为 fail</p>
<p>无论<code>receivedIsMaster</code> 还是 <code>failedHost</code> 执行完成后，都会调用 <code>scheduleNetworkRequests</code> 重新调度（可能有新加入 <strong>hostsToScan</strong> 的节点）</p>
<h2 id="周边类"><a href="#周边类" class="headerlink" title="周边类"></a>周边类</h2><p><code>ReplicaSetMonitorManager</code> 是负责 <code>ReplicaSetMonitor</code> 的管理类，维护一个 map 结构 （记录 setName 和 <code>ReplicaSetMonitor</code>），一个<code>TaskExecutor</code> 用于所有 <code>ReplicaSetMonitor</code> 命令执行，以及一个<code>ReplicaSetChangeNotifier</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/command/serverStatus/MongoDB-request-counter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/command/serverStatus/MongoDB-request-counter/" itemprop="url">MongoDB 请求计数逻辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-22T17:25:43+08:00">
                2020-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/serverStatus/" itemprop="url" rel="index">
                    <span itemprop="name">serverStatus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>mongos上一个find请求堆栈主要路径是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#0 mongo::(anonymous namespace)::ClusterFindCmd::Invocation::run  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;cluster_find_cmd.cpp:205</span><br><span class="line"></span><br><span class="line">#1 0x00007f3701fae26a in mongo::(anonymous namespace)::execCommandClient  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:303</span><br><span class="line"></span><br><span class="line">#2 0x00007f3701faff38 in mongo::(anonymous namespace)::runCommand  at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:489</span><br><span class="line"></span><br><span class="line">#3 0x00007f3701fb1f76 in mongo::Strategy::clientCommand at src&#x2F;mongo&#x2F;s&#x2F;commands&#x2F;strategy.cpp:800</span><br><span class="line"></span><br><span class="line">#4 0x00007f3701e243cc in mongo::ServiceEntryPointMongos::handleRequest  at src&#x2F;mongo&#x2F;s&#x2F;service_entry_point_mongos.cpp:95</span><br><span class="line"></span><br><span class="line">#5 0x00007f3701e7d5e2 in mongo::ServiceStateMachine::_processMessage  at src&#x2F;mongo&#x2F;transport&#x2F;service_state_machine.cpp:452</span><br></pre></td></tr></table></figure>



<p><code>db.serverStatus()</code> 输出结果中有3个地方对请求进行了计数，这里简单整理下</p>
<ol>
<li><code>db.serverStatus().network.numRequests</code>(简称<strong>requests计数</strong>） – 对应在堆栈中#5（即 <code>ServiceStateMachine::_processMessage()</code>）进行计数。表示<strong>接收的网络包数量</strong></li>
<li><code>db.serverStatus().metrics.commands.*.total &amp; failed</code>（简称<strong>metrics计数</strong>） – 对应在堆栈中#1（即 <code>execCommandClient()</code> ）进行计数。表示<strong>不同命令执行的次数</strong></li>
<li><code>db.serverStatus().opcounters</code>（简称<strong>opcounters计数</strong>） – 对应在堆栈中#0（即 <code>Invocation::run()</code>）即进行计数。表示<strong>requests计数</strong></li>
</ol>
<p><strong>requests计数</strong>和<strong>metrics计数</strong>的逻辑是固定的，而对于opcounters计数会根据请求的不同有一定gap。</p>
<h2 id="opcounters-计数分析"><a href="#opcounters-计数分析" class="headerlink" title="opcounters 计数分析"></a>opcounters 计数分析</h2><p><code>db.serverStatus().opcounters</code> 包含如下结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"insert"</span> : NumberLong(<span class="number">6</span>),</span><br><span class="line">        <span class="attr">"query"</span> : NumberLong(<span class="number">1</span>),</span><br><span class="line">        <span class="attr">"update"</span> : NumberLong(<span class="number">2</span>),</span><br><span class="line">        <span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">        <span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">        <span class="attr">"command"</span> : NumberLong(<span class="number">75</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>ServiceEntryPointMongos::handleRequest()</code>中对计数场景进行了区分：</p>
<h3 id="计数场景1：-opcode-OP-MSG-或者-opcode-OP-QUERY-且-namespace的collection部分-“-cmd”"><a href="#计数场景1：-opcode-OP-MSG-或者-opcode-OP-QUERY-且-namespace的collection部分-“-cmd”" class="headerlink" title="计数场景1：(opcode == OP_MSG) 或者 (opcode == OP_QUERY 且 namespace的collection部分 == “$cmd”)"></a>计数场景1：(<code>opcode == OP_MSG</code>) 或者 (<code>opcode == OP_QUERY</code> 且 namespace的collection部分 == “$cmd”)</h3><p>按照上面举例的find堆栈 <code>clientCommand()</code> –&gt; <code>runCommand()</code> –&gt; <code>execCommandClient()</code> –&gt; <code>Invocation::run()</code> 依次调用。这里所有的command都会继承 Command 类，该类提供一个 <code>shouldAffectCommandCounter()</code> 返回True。</p>
<ul>
<li>insert / update / delete / query / getmore 请求重写了 <code>shouldAffectCommandCounter()</code> 返回 false ，在 <code>Invocation::run()</code> 中完成计数</li>
<li>其余请求均作为 command，在 <code>execCommandClient()</code> 中完成计数</li>
</ul>
<h3 id="计数场景2：opcode-OP-QUERY-且-namespace的collection部分-“-cmd”"><a href="#计数场景2：opcode-OP-QUERY-且-namespace的collection部分-“-cmd”" class="headerlink" title="计数场景2：opcode == OP_QUERY 且 namespace的collection部分 != “$cmd”"></a>计数场景2：<code>opcode == OP_QUERY</code> 且 namespace的collection部分 != “$cmd”</h3><p>直接调用 <code>Strategy::queryOp()</code>， 并在其中完成计数</p>
<h3 id="计数场景3：opcode-OP-GET-MORE"><a href="#计数场景3：opcode-OP-GET-MORE" class="headerlink" title="计数场景3：opcode == OP_GET_MORE"></a>计数场景3：<code>opcode == OP_GET_MORE</code></h3><p>直接调用 <code>Strategy::getMore()</code>，并在其中完成计数</p>
<h3 id="计数场景4：opcode-OP-KILL-CURSORS"><a href="#计数场景4：opcode-OP-KILL-CURSORS" class="headerlink" title="计数场景4：opcode == OP_KILL_CURSORS"></a>计数场景4：<code>opcode == OP_KILL_CURSORS</code></h3><p>直接调用 <code>Strategy::killCursors()</code>，并在其中调用 <code>OpCounters::gotOp()</code></p>
<p>gotOp 对 OP_KILL_CURSORS / OP_REPLY 不进行计数，即这两种场景不会记录在 opcounters 中</p>
<h3 id="计数场景5：opcode-OP-INSERT-OP-UPDATE-OP-DELETE"><a href="#计数场景5：opcode-OP-INSERT-OP-UPDATE-OP-DELETE" class="headerlink" title="计数场景5：opcode == OP_INSERT / OP_UPDATE / OP_DELETE"></a>计数场景5：<code>opcode == OP_INSERT / OP_UPDATE / OP_DELETE</code></h3><p>按照场景1堆栈 <code>Strategy::writeOp()</code> –&gt; <code>runCommand()</code> –&gt; <code>execCommandClient()</code> –&gt; <code>Invocation::run()</code> 依次调用，同场景1</p>
<h3 id="对insert-update-delete-请求的计数说明"><a href="#对insert-update-delete-请求的计数说明" class="headerlink" title="对insert / update / delete 请求的计数说明"></a>对<code>insert / update / delete</code> 请求的计数说明</h3><p>对于insert / update / delete 请求，会在 <code>Invocation::run()</code> 中完成计数，但是对这3个请求的处理不是简单的+1完成的。增加的数量为 <code>batchedRequest.sizeWriteOps()</code>。由于3.6版本中新增了 OP_MSG 的协议类型，支持这3种请求携带多条数据：即 OP_MSG 协议中 <strong>kind=Document Sequence 的 sections 字段</strong>。这3种请求的具体实现，都重写了 Command 类提供的 parse 函数，基于原有的 request 构建了一个额外的 <code>BatchedCommandRequest</code> ，调用的是 <code>BatchedCommandRequest::parseInsert()</code> 函数。</p>
<p>实际执行验证来看：</p>
<p>通过insert插入一个BSONArray，opcounters.insert 会增加 array 的 size。和上面的分析是对齐的</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"insert"</span> : NumberLong(<span class="number">2</span>),</span><br><span class="line">	<span class="attr">"query"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"update"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"command"</span> : NumberLong(<span class="number">58</span>)</span><br><span class="line">&#125;</span><br><span class="line">mongos&gt; db.collection.insert([&#123;name: "B"&#125;,&#123;name: "C"&#125;])</span><br><span class="line">BulkWriteResult(&#123;</span><br><span class="line">	"writeErrors" : [ ],</span><br><span class="line">	"writeConcernErrors" : [ ],</span><br><span class="line">	"nInserted" : 2,</span><br><span class="line">	"nUpserted" : 0,</span><br><span class="line">	"nMatched" : 0,</span><br><span class="line">	"nModified" : 0,</span><br><span class="line">	"nRemoved" : 0,</span><br><span class="line">	"upserted" : [ ]</span><br><span class="line">&#125;)</span><br><span class="line">mongos&gt; db.serverStatus().opcounters</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"insert"</span> : NumberLong(<span class="number">4</span>),</span><br><span class="line">	<span class="attr">"query"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"update"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"delete"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"getmore"</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">	<span class="attr">"command"</span> : NumberLong(<span class="number">62</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而 <code>db.colleciton.update()</code> / <code>db.colleciton.delete()</code> 并不像 <code>insert()</code> 一样支持多条记录的修改。这几个函数都是被 mongo shell 封装过的，具体通过 insert / update / delete 进行多条document修改可以参考<a href="https://docs.mongodb.com/manual/reference/command/nav-crud/" target="_blank" rel="noopener">官网文档</a>中提供的命令，分别对应有 inserts / updates / deletes 字段支持多条document修改</p>
<p><strong>Notice:</strong> 按照上面的分析，对于opcode == OP_QUERY / OP_GET_MORE / OP_KILL_CURSORS 的场景，对metrics计数应该是有缺失的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/command/serverStatus/MongoDB-serverStatus-implement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/command/serverStatus/MongoDB-serverStatus-implement/" itemprop="url">MongoDB serverStatus实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-21T13:15:09+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/command/serverStatus/" itemprop="url" rel="index">
                    <span itemprop="name">serverStatus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>[TOC]</p>
<p> <code>CmdServerStatus</code> 的 run() 函数是 <code>serverStatus</code> 命令的具体实现</p>
<ul>
<li>首先将一些全局信息添加到result中</li>
<li>遍历<code>_sections</code>，调用<code>appendSection</code>，将所有注册的<code>Section</code>结果添加到result中</li>
<li>调用<code>MetricTree::theMetricTree-&gt;appendTo()</code>，将所有<code>Metric</code>指标添加到result中</li>
<li>其他一些信息的补充</li>
</ul>
<p>同时 <code>CmdServerStatus</code> 还维护了一个 <code>_sections</code> （map结构）存储section名称和具体 <code>ServerStatusSection</code> 的对应关系。提供 <code>addSection</code> 函数将制定section添加到 <code>_sections</code> 中</p>
<h2 id="Section指标"><a href="#Section指标" class="headerlink" title="Section指标"></a>Section指标</h2><p><code>ServerStatusSection</code> 是所有 <code>section</code> 指标的基类，构造方法调用 <code>CmdServerStatusInstantiator::getInstance()-&gt;addSection()</code> 将自身注册到 <code>CmdServerStatus</code> 中。并声明 virtual 函数 <code>includeByDefault</code> , <code>addRequiredPrivileges</code> , <code>generateSection</code> , <code>appendSection</code> 由子类定义实现，子类主要需要按需求定义<code>includeByDefault</code> , <code>generateSection</code> 的具体实现。</p>
<ul>
<li><code>includeByDefault</code> 用于说明是否默认被包含</li>
<li><code>generateSection</code>&amp;<code>appendSection</code>   一般实现其中一个即可，父类方法中<code>appendSection</code> 调用了 <code>generateSection</code> ，所以一般只需要实现 <code>generateSection</code> 即可。</li>
</ul>
<p><code>CmdServerStatusInstantiator</code> 是包装 <code>CmdServerStatus</code> 用于获取 <code>CmdServerStatus</code> 单例对象的一个struct，提供 <code>getInstance()</code> 完成单例对象获取。所以上面讲到的 <code>ServerStatusSection</code> 构造时调用 <code>CmdServerStatusInstantiator::getInstance()-&gt;addSection()</code> ，最终完成了自身到 <code>CmdServerStatus</code> 的 _sections 注册。</p>
<p>serverStatus命令运行时将遍历自身的 _sections ，依次根据 <code>includeByDefault</code> 配置，调用其 appendSection 完成 response BSON 的构建。</p>
<blockquote>
<p>其他 Command 都是在类声明的时候同时定义了一个对象，完成到 CommandMap 的注册。而 <code>CmdServerStatus</code> 由于需要 <code>CmdServerStatusInstantiator</code> 构建单例对象，所以是在 <code>CmdServerStatusInstantiator</code> 声明时定义了一个对象，完成 <code>CmdServerStatus</code> 到 CommandMap 的注册行为。</p>
</blockquote>
<h2 id="Metric指标"><a href="#Metric指标" class="headerlink" title="Metric指标"></a>Metric指标</h2><p><code>MetricTree</code>维护了一个树状结构(下文简称Tree) 用于存储所有的 metric指标 及其 path 对应关系，同时提供一个静态变量 <code>theMetricTree</code> 对外提供服务。同时提供 <code>add</code> 和 <code>appendTo</code> 函数分别用于将 Tree 添加到 <code>theMetricTree</code> 以及将 Tree 的数据以BSON的形式输出。</p>
<ul>
<li><p><code>add</code> 函数用于将 <code>ServerStatusMetric</code> 添加到 <code>Tree</code> : <code>Tree</code> 维护 <code>metrics path</code> 和 <code>ServerStatusMetric</code> 的对应关系，内部是由 2 个 map 构成的，如果当前 <code>metrics path</code> 是叶子节点（即 path 中不存在”.”），那么存储到``path –&gt; ServerStatusMetric<code>的 map 中，反之取出 path 的第一级路径，存储到 第一级路径 --&gt;</code>MetricTree` （不存在则新加一个） ，然后递归调用完成添加</p>
</li>
<li><ul>
<li>如果 path 是以 “.” 为开头，则添加到 Tree 的顶级路径，否则会在提供的 path 前添加 “metrics.” 前缀（即添加到metrics的子节点上）</li>
</ul>
</li>
<li><p><code>appendTo</code> 函数用于将 <code>Tree</code> 的数据以BSON的形式输出 ： 对于非叶子节点，会递归调用 <code>appendTo</code> 函数。对于叶子节点则会调用 <code>ServerStatusMetric</code> 的 <code>appendAtLeaf</code> 函数。最终根据所有 <code>ServerStatusMetric</code> 的 path 产生对应的的BSON</p>
</li>
</ul>
<p><code>ServerStatusMetric</code> 是所有 metric指标 的基类，主要提供构造方法调用 <code>MetricTree::theMetricTree-&gt;add(this)</code> 将自身注册到 <code>MetricTree</code> 中。并声明一个 <code>virtual appendAtLeaf</code> 函数由子类定义实现。该类有4个子类：</p>
<ul>
<li><p>模板类 <code>ServerStatusMetricField</code> 是一个被广泛应用的子类。增加一个T，用于实现大多数需求：都是 k-v 的结构， <code>appendAtLeaf</code>将 <strong>k &amp; v</strong> 直接append到bson中</p>
</li>
<li><ul>
<li>举例场景：所有command的一个成员变量，用于做类似命令与请求次数的绑定，便于serverStatus拿到结果</li>
</ul>
</li>
<li><p><code>MemBase (= .mem.bits )</code> ，获取MongoDB使用的内存信息</p>
</li>
<li><p><code>ClusterCursorStats (= cursor )</code>，cursor 信息</p>
</li>
<li><p><code>ReplExecutorSSM (= repl.executor )</code>，// TODO</p>
</li>
</ul>
<p>serverStatus命令运行时，将调用 <code>theMetricTree</code> 的 <code>appendTo</code> 函数，完成 response BSON 的构建</p>
<h2 id="Section指标-amp-Metric指标-实现对比"><a href="#Section指标-amp-Metric指标-实现对比" class="headerlink" title="Section指标 &amp; Metric指标 实现对比"></a>Section指标 &amp; Metric指标 实现对比</h2><p>ServerStatusMetric 和 ServerStatusSection 下文统称为Impl</p>
<table>
<thead>
<tr>
<th></th>
<th>Section指标</th>
<th>Metric指标</th>
</tr>
</thead>
<tbody><tr>
<td>都有一个单例的对象管理</td>
<td>CmdServerStatusInstantiator::getInstance()</td>
<td>MetricTree::theMetricTree</td>
</tr>
<tr>
<td>都是 name – Impl  的对应关系</td>
<td>CmdServerStatus  中_sections是一个map结构  name – ServerStatusSection</td>
<td>ServerStatusMetric中基于2个map结构实现了一个树状结构  叶子节点也都是  name – ServerStatusMetric</td>
</tr>
<tr>
<td>Impl都提供一个函数将结果  append 到 response 中</td>
<td>generateSection&amp;appendSection</td>
<td>appendTo</td>
</tr>
</tbody></table>
<p>区别应该有2点：</p>
<ol>
<li><code>ServerStatusSection</code>的append函数 <code>generateSection</code>&amp;<code>appendSection</code> 包含了 opCtx 和 configElement 。定义分别是<ul>
<li>`virtual BSONObj generateSection(OperationContext* opCtx, const BSONElement&amp;      configElement) const;``</li>
<li>``virtual void appendSection(OperationContext* opCtx, const BSONElement&amp;      configElement, BSONObjBuilder* result) const;`</li>
</ul>
</li>
<li><code>ServerStatusSection</code>提供了 <code>includeByDefault</code> 和 <code>addRequiredPrivileges</code> 对输出结构的控制力更强一些</li>
</ol>
<p>看起来是对于serverStatus默认添加且是计数行为的使用 <code>ServerStatusMetric</code> 比较方便简单一些。其他情况尤其对于 opCtx 有依赖或者需要控制对serverStatus输出的还是使用 <code>ServerStatusSection</code> 操控力更强一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/MongoDB/sharding/DiskLock/MongoDB-sharding-DiskLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB/sharding/DiskLock/MongoDB-sharding-DiskLock/" itemprop="url">MongoDB sharding中分布式锁机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-24T19:11:00+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/" itemprop="url" rel="index">
                    <span itemprop="name">MongoDB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/" itemprop="url" rel="index">
                    <span itemprop="name">sharding</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB/sharding/DiskLock/" itemprop="url" rel="index">
                    <span itemprop="name">DiskLock</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>sharding实例在 createCollection/dropCollection 等场景下，为了规避并发问题引入了分布式锁机制。分布式锁的信息记录在 <a href="https://docs.mongodb.com/manual/reference/config-database/index.html#config.locks" target="_blank" rel="noopener"><code>config.locks</code></a>  集合中，结合 <a href="https://docs.mongodb.com/manual/reference/config-database/index.html#config.lockpings" target="_blank" rel="noopener"><code>config.lockpings</code></a> 中的信息来完成相关逻辑实现。</p>
<h2 id="分布式锁原理"><a href="#分布式锁原理" class="headerlink" title="分布式锁原理"></a>分布式锁原理</h2><h3 id="1-config-lockpings-和-config-locks-集合中存储的内容"><a href="#1-config-lockpings-和-config-locks-集合中存储的内容" class="headerlink" title="1. config.lockpings 和 config.locks 集合中存储的内容"></a>1. <code>config.lockpings</code> 和 <code>config.locks</code> 集合中存储的内容</h3><h4 id="config-lockpings"><a href="#config-lockpings" class="headerlink" title="config.lockpings"></a>config.lockpings</h4><p><a href="https://docs.mongodb.com/manual/reference/config-database/index.html#config.lockpings" target="_blank" rel="noopener"><code>config.lockpings</code></a> 集合跟踪记录分片集群中所有活跃的组件。</p>
<p>如果一个 mongos 运行在 example.com:30000 ，那么 <code>config.lockpings</code> 关于这个mongos的记录是这个样子的</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	<span class="attr">"_id"</span> : <span class="string">"example.com:30000:1350047994:16807"</span>, <span class="comment">// 记录组件的标识， mongos 和 shard 节点均需要定期和 config 节点保持心跳</span></span><br><span class="line">	<span class="attr">"ping"</span> : ISODate(<span class="string">"2020-07-12T18:32:54.892Z"</span>) <span class="comment">// 组件定期与 `lockpings` 集合保持心跳，即更新 `ping` 字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>_id</code> 字段内部称为 <code>processID</code> 。<code>processID</code> 对于 config 节点固定为”ConfigServer”；对于 mongos / shard 节点，则是以”:”分隔的四段信息分别为：hostname / port / timestamp / 随机int64值。该4项信息在进程启动时即已决定，进程存活期间不会被修改。</p>
</blockquote>
<h4 id="config-locks"><a href="#config-locks" class="headerlink" title="config.locks"></a>config.locks</h4><p><a href="https://docs.mongodb.com/manual/reference/config-database/index.html#config.locks" target="_blank" rel="noopener"><code>config.locks</code></a> 集合存储了分布式锁信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_id"</span> : <span class="string">"test.myShardedCollection"</span>, <span class="comment">// 锁的名称，下文简称 lockName。对 database 或者 namespace 的部分场景操作需要获取分布式锁，所以一般 database 或者 namespace</span></span><br><span class="line">   <span class="attr">"state"</span> : <span class="number">2</span>, <span class="comment">// 锁的状态。0 表示 UNLOCKED，2 表示 LOCKED，1 表示 LOCK_PREP（仅对老版本3个config节点，目前代码中已无相关逻辑）</span></span><br><span class="line">   <span class="attr">"process"</span> : <span class="string">"ConfigServer"</span>, <span class="comment">// 即 processID。与上文讲到的 config.lockpings 集合中 _id 字段的取值是一样的</span></span><br><span class="line">   <span class="attr">"ts"</span> : ObjectId(<span class="string">"5be0b9ede46e4f441a60d891"</span>), <span class="comment">// 锁ID，下文简称 lockID。每次尝试获取分布式锁时的 锁ID 都是独有的。</span></span><br><span class="line">   <span class="attr">"when"</span> : ISODate(<span class="string">"2020-07-12T21:52:00.846Z"</span>), <span class="comment">// 获取锁的时间</span></span><br><span class="line">   <span class="attr">"who"</span> : <span class="string">"ConfigServer:Balancer"</span>, <span class="comment">// 获取锁的角色。  以":"分隔，第一段与 process字段 相同， 第二段 进程获取锁的线程名称。 ConfigServer:Balancer 表示 config进程的Balancer线程</span></span><br><span class="line">   <span class="attr">"why"</span> : <span class="string">"Migrating chunk(s) in collection test.myShardedCollection"</span> <span class="comment">// 获取锁的原因</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>_id</code> 下文简称 <code>lockName</code>, <code>process</code> 下文简称 <code>processID</code>，<code>ts</code> 下文简称 <code>lockID</code></p>
</blockquote>
<h3 id="2-与-config-lockpings-和-config-locks-的基本交互"><a href="#2-与-config-lockpings-和-config-locks-的基本交互" class="headerlink" title="2. 与 config.lockpings 和 config.locks 的基本交互"></a>2. 与 <code>config.lockpings</code> 和 <code>config.locks</code> 的基本交互</h3><blockquote>
<p> 与上述2个集合的基础交互（<code>DistLockCatalog</code> 提供了与上述2个集合的基础交互动作，而 <code>DistLockCatalogImpl</code> 则是接口的具体实现）</p>
</blockquote>
<p><strong>与 <code>config.lockpings</code> 的交互有 3 种场景：</strong></p>
<ul>
<li><code>replSetDistLockPinger</code> 线程每隔 30s 通过一个 <code>upsert: true</code> 的 <code>findAndModify</code> 请求更新ping字段</li>
<li>系统 shutdown 时，会构造一个 <code>update: {}</code> 的 <code>findAndModify</code> 请求清理掉对应的document</li>
<li>此外在尝试获取分布式锁时，会获取对应组件上次心跳的时间，基于此判断组件是否已经丢失心跳，进而判断是否需要抢占锁</li>
</ul>
<p>与 <code>config.locks</code> 交互便是我们关心的分布式锁交互过程：</p>
<ul>
<li>组件获取到分布式锁有2种方式：<ul>
<li><code>grabLock</code> : <strong>没有期望的 <code>lockName</code> 记录</strong>或者<strong>有期望的 <code>lockName</code> 记录且 <code>state = 0(UNLOCKED)</code></strong> ，通过更新 <code>state = 2(LOCKED)</code>, 同时更新<code>processID</code>/<code>lockID</code>/<code>who</code>/<code>when</code>/<code>why</code>字段的方式获取锁</li>
<li><code>overtakeLock</code> : 对于*<em>期望 <code>lockName</code>记录，其 <code>state = 0(UNLOCKED)</code> 或者 <code>lockID = oldTS</code> *</em>，通过更新 <code>state = 2(LOCKED)</code>、更新 <code>lockID = newTS</code>、更新<code>processID</code>/<code>who</code>/<code>when</code>/<code>why</code>字段的方式抢占锁</li>
</ul>
</li>
</ul>
<h3 id="3-分布式锁获取逻辑"><a href="#3-分布式锁获取逻辑" class="headerlink" title="3. 分布式锁获取逻辑"></a>3. 分布式锁获取逻辑</h3><blockquote>
<p>主要是通过 <code>ReplSetDistLockManager::lockWithSessionID()</code> 来完成的</p>
</blockquote>
<ol>
<li>在预期情况下，应不存在对应的锁或者锁的状态应该是 <code>UNLOCKED</code>。所以首先通过 <code>grabLock</code> 的方式来获取锁</li>
<li>如通过 <code>grabLock</code> 获取失败，则说明可能存在锁竞争的情况。则通过锁的名称来获取目前 <code>config.locks</code> 集合中记录的对应锁的信息</li>
<li>基于锁的信息来判断：如果 <strong>当前记录的分布式锁已经超时</strong> 或者 <strong>其对应的 processID 为当前请求的processID</strong>， 则通过 <code>overtakeLock</code> 的方式抢占锁<ol>
<li>当前记录的分布式锁已经超时：<code>ReplSetDistLockManager</code> 内部维护一个 <code>_pingHistory</code> 用于协助判断 <code>config.locks</code> 中记录的锁是否超时。<code>_pingHistory</code> 中记录了 <code>processID</code>/<code>pingValue</code>/<code>config节点的serverTime</code>/<code>lockID</code>/<code>config节点的electionId</code>。<ol>
<li>无法在 <code>config.lockpings</code> 集合中找到对应组件的心跳记录，则认为<strong>锁未超时</strong></li>
<li>如果 <code>_pingHistory</code> 中不存在对应 <code>lockName</code> 的记录，则认为<strong>锁未超时</strong>，并将相关结果记录到 <code>_pingHistor</code>中</li>
<li>如果与 <code>_pingHistory</code> 中记录相比，<strong>锁的持有者心跳正常(<code>pingValue</code>字段持续更新)</strong> 或者 <strong>锁的<code>lockID</code>发生变化</strong> 或者 <strong>config发生主节点变更(<code>electionId</code>发生变化)</strong> 则认为<strong>锁未超时</strong>，同时将相关结果记录到 <code>_pingHistory</code> 便于下次对比</li>
<li>最后，如果上述情况都没有发生，而 <code>_pingHistory</code> 中记录的 <code>config节点的serverTime</code> 时间与当前时间超过 15min，则认为<strong>锁已经超时</strong></li>
</ol>
</li>
<li>锁的信息中对应的 <code>ts</code> 为当前请求的<code>ts</code></li>
</ol>
</li>
<li>如上述操作均失败，则等待后重新执行上述操作。直到超出指定的等待时间（<code>waitFor</code>）则返回<code>LockBusy</code></li>
</ol>
<p>借助简要代码看下：</p>
<blockquote>
<p>入参中：<code>name</code> 为锁的名称（即 <code>_id</code> 字段），<code>lockSessionID</code> 为获取锁唯一的锁ID（即 <code>ts</code> 字段），<code>waitFor</code> 为预期等待锁的时间。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusWith&lt;DistLockHandle&gt; <span class="title">ReplSetDistLockManager::lockWithSessionID</span><span class="params">(OperationContext* opCtx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                     StringData name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                     StringData whyMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                     <span class="keyword">const</span> OID&amp; lockSessionID,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                     Milliseconds waitFor)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distributed lock acquisition works by tring to update the state of the lock to 'taken'. If</span></span><br><span class="line">    <span class="comment">// the lock is currently taken, we will back off and try the acquisition again, repeating this</span></span><br><span class="line">    <span class="comment">// until the lockTryInterval has been reached. If a network error occurs at each lock</span></span><br><span class="line">    <span class="comment">// acquisition attempt, the lock acquisition will be retried immediately.</span></span><br><span class="line">    <span class="keyword">while</span> (waitFor &lt;= Milliseconds::zero() || Milliseconds(timer.<span class="built_in">millis</span>()) &lt; waitFor) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> lockResult = _catalog-&gt;grabLock(</span><br><span class="line">            opCtx, name, lockSessionID, who, _processID, Date_t::now(), whyMessage.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> status = lockResult.getStatus();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status.isOK()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> lockSessionID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get info from current lock and check if we can overtake it.</span></span><br><span class="line">        <span class="keyword">auto</span> getLockStatusResult = _catalog-&gt;getLockByName(opCtx, name);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; getLockStatus = getLockStatusResult.getStatus();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: Only attempt to overtake locks that actually exists. If lock was not</span></span><br><span class="line">        <span class="comment">// found, use the normal grab lock path to acquire it.</span></span><br><span class="line">        <span class="keyword">if</span> (getLockStatusResult.isOK()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> currentLock = getLockStatusResult.getValue();</span><br><span class="line">            <span class="keyword">auto</span> isLockExpiredResult = isLockExpired(opCtx, currentLock, lockExpiration);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isLockExpiredResult.getValue() || (lockSessionID == currentLock.getLockID())) &#123;</span><br><span class="line">                <span class="keyword">auto</span> overtakeResult = _catalog-&gt;overtakeLock(xxx);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitFor == Milliseconds::zero()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Milliseconds timeRemaining = <span class="built_in">std</span>::<span class="built_in">max</span>(Milliseconds::zero(), waitFor - Milliseconds(timer.<span class="built_in">millis</span>()));</span><br><span class="line">        sleepFor(<span class="built_in">std</span>::<span class="built_in">min</span>(kLockRetryInterval, timeRemaining));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;ErrorCodes::LockBusy, str::stream() &lt;&lt; <span class="string">"timed out waiting for "</span> &lt;&lt; name&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-加锁的场景"><a href="#4-加锁的场景" class="headerlink" title="4. 加锁的场景"></a>4. 加锁的场景</h3><ul>
<li><p>collectin操作：<code>createCollection</code> / <code>dropCollection</code> / <code>shardCollection</code> 会同时对 collection 的 <strong>namespace</strong> 和 <strong>database</strong> 加锁</p>
</li>
<li><p>database操作：<code>movePrimary</code> / <code>enableSharding</code> / <code>createDatabase</code> / <code>dropDatabase</code> 时会对 <strong>database</strong> 加锁，<code>dropDatabase</code> 还会依次对 db 下所有的 <strong>collection</strong> 加锁(<code>dropCollection</code>)</p>
</li>
<li><p>chunk操作：Migrating chunk(s) in collection / merging chunks / splitting chunk</p>
</li>
<li><p>map-reduce操作：mr-post-process</p>
</li>
</ul>
<h3 id="5-解锁场景"><a href="#5-解锁场景" class="headerlink" title="5. 解锁场景"></a>5. 解锁场景</h3><ul>
<li>一般情况在需要获取分布式锁的场景下，获取分布式锁成功会获得到一个 <code>DistLockManager::ScopedDistLock</code> 的对象，并在锁使用完成后触发该对象的析构函数，释放锁（修改state=UNLOCKED）。</li>
<li>另外如果 <code>grabLock</code> 时，如果获取失败返回异常是由于 config节点 状态异常导致，那么也会进行 <code>unlock</code> 方便下次可以直接 <code>grabLock</code> 完成加锁。</li>
<li>MigrationManager 一些场景触发 // TODO</li>
<li>如果<strong>在上述任何场景触发的unlock失败</strong> 或者 <strong>一些操作导致锁的状态未知</strong> 后，都会加入到 <code>_unlockList</code> 队列，在 <code>replSetDistLockPinger</code> 定期执行时也会重新进行 unlock 操作</li>
</ul>
<hr>
<h2 id="分布式锁代码解析"><a href="#分布式锁代码解析" class="headerlink" title="分布式锁代码解析"></a>分布式锁代码解析</h2><h3 id="1-核心类说明"><a href="#1-核心类说明" class="headerlink" title="1. 核心类说明"></a>1. 核心类说明</h3><h4 id="DistLockCatalogImpl-DistLockCatalog-对分布式锁的一些具体操作"><a href="#DistLockCatalogImpl-DistLockCatalog-对分布式锁的一些具体操作" class="headerlink" title="DistLockCatalogImpl : DistLockCatalog : 对分布式锁的一些具体操作"></a><code>DistLockCatalogImpl : DistLockCatalog</code> : 对分布式锁的一些具体操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Interface for the distributed lock operations.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class DistLockCatalog &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对config.lockpings的基础操作：ping/getPing/stopPing</li>
<li>获取分布式锁or config的信息：getServerInfo/getLockByTS/getLockByname</li>
<li>对锁的操作(config.locks)：grabLock/overtakeLock/unlock/unlockAll</li>
</ol>
<p>其中<code>grabLock</code> 和 <code>overtakeLock</code> 是两个核心的获取锁的方法：</p>
<ol>
<li><code>grabLock</code> : 将<code>lockID</code>的锁更新为指定的<code>lockSessionID</code></li>
<li><code>overtakeLock</code> : 强制将锁的持有者从<code>currentHolderTS</code>更改为<code>lockSessionID</code></li>
</ol>
<h4 id="ReplSetDistLockManager-DistLockManager-分布式锁的一些接口，主要封装DistLockCatalogImpl而实现"><a href="#ReplSetDistLockManager-DistLockManager-分布式锁的一些接口，主要封装DistLockCatalogImpl而实现" class="headerlink" title="ReplSetDistLockManager : DistLockManager : 分布式锁的一些接口，主要封装DistLockCatalogImpl而实现"></a><code>ReplSetDistLockManager : DistLockManager</code> : 分布式锁的一些接口，主要封装DistLockCatalogImpl而实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Interface for handling distributed locks.</span><br><span class="line"> *</span><br><span class="line"> * Usage:</span><br><span class="line"> *</span><br><span class="line"> * auto scopedDistLock &#x3D; mgr-&gt;lock(...);</span><br><span class="line"> *</span><br><span class="line"> * if (!scopedDistLock.isOK()) &#123;</span><br><span class="line"> *   &#x2F;&#x2F; Did not get lock. scopedLockStatus destructor will not call unlock.</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * &#x2F;&#x2F; To check if lock is still owned:</span><br><span class="line"> * auto status &#x3D; scopedDistLock.getValue().checkStatus();</span><br><span class="line"> *</span><br><span class="line"> * if (!status.isOK()) &#123;</span><br><span class="line"> *   &#x2F;&#x2F; Someone took over the lock! Unlock will still be called at destructor, but will</span><br><span class="line"> *   &#x2F;&#x2F; practically be a no-op since it doesn&#39;t own the lock anymore.</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class DistLockManager &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>持有一个线程<code>replSetDistLockPinger</code>，用户定时与config.lockpings心跳，并对需要unlock的锁进行unlock</li>
<li>提供对锁处理的一些方法：<ol>
<li>加锁：lock/lockWithSessionID/tryLockWithLocalWriteConcern<ol>
<li>lock通过调用lockWithSessionID来实现</li>
</ol>
</li>
<li>解锁：unlock/unlockAll</li>
</ol>
</li>
<li>持有一个内部类ScopedDistLock : 一个RAII风格的类，持有锁的基础信息</li>
</ol>
<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><p><img src="https://wangxin201492.github.io/techImages/MongoDB-sharding-DiskLockManager.png" alt="MongoDB-sharding-DiskLockManager"></p>
<p>mongos初始化时会生成一个与host、port、时间戳、随机值有关的一个<code>distLockProcessId</code>作为<code>ReplSetDistLockManager</code>的唯一标识，并在makeCatalogClient中完成对DistLockCatalogImpl、ReplSetDistLockManager、ShardingCatalogClientImpl的初始化</p>
<ul>
<li>DistLockCatalogImpl : 是<code>DistLockCatalog</code>的具体实现。默认初始化方法存储了<code>config.locks</code>，<code>config.lockpings</code>表名</li>
<li>ReplSetDistLockManager : 是<code>DistLockManager</code>的具体实现。初始化方法存储了上面提到的<code>distLockProcessId</code>, <code>DistLockCatalog</code>并完成了<code>pingInterval</code>, <code>lockExpiration</code>的初始化，其中<code>pingInterval</code>默认为30s，<code>lockExpiration</code>默认为15min</li>
<li>ShardingCatalogClientImpl : 是<code>ShardingCatalogClient</code>的具体实现。初始化方法存储了上面提到的<code>DistLockManager</code>。<em>(该类只提供了一个获取DistLockManager的方式及start、shutdown的方法，与DistLockManager无其他关系)</em></li>
</ul>
<p>然后将ShardingCatalogClientImpl作为一个数据成员存储在全局的Grid中</p>
<h3 id="3-replSetDistLockPinger线程"><a href="#3-replSetDistLockPinger线程" class="headerlink" title="3. replSetDistLockPinger线程"></a>3. replSetDistLockPinger线程</h3><h4 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h4><p>grid初始化完成后，紧接着会调用<code>grid-&gt;catalogClient()-&gt;startup();</code>，该语句实际上最终调用到<code>ReplSetDistLockManager::startUp()</code>，启动一个replSetDistLockPinger线程，线程的具体执行在<code>ReplSetDistLockManager::doTask()</code>中</p>
<h4 id="线程逻辑-doTask"><a href="#线程逻辑-doTask" class="headerlink" title="线程逻辑 : doTask"></a>线程逻辑 : doTask</h4><ol>
<li>config.lockpings交互：调用DistLockCatalog::ping()，构造一个findAndModify请求根据processID更新ping字段(upsert=true)。并更新本地的elapsedSincelastPing，如果与上次ping时间超过_pingInterval*10 则打印warning日志</li>
<li>unlock：遍历本地的 <code>_unlockList</code> ，对需要unlock的锁调用DistLockCatalog::unlock()。如果返回失败则打印warning日志并重新加入_unlockList中</li>
<li>sleep _pingInterval 即15s</li>
</ol>
<h3 id="4-触发分布式锁的场景"><a href="#4-触发分布式锁的场景" class="headerlink" title="4. 触发分布式锁的场景"></a>4. 触发分布式锁的场景</h3><ul>
<li>chunk操作：Migrating chunk(s) in collection / merging chunks / splitting chunk</li>
<li>db or collection操作：movePrimary/enableSharding/dropCollection …</li>
<li>map-reduce操作：mr-post-process</li>
</ul>
<h4 id="collection-操作"><a href="#collection-操作" class="headerlink" title="collection 操作"></a>collection 操作</h4><table>
<thead>
<tr>
<th>whyMessage</th>
<th>_id</th>
<th>function</th>
<th>file</th>
</tr>
</thead>
<tbody><tr>
<td>“createCollection”</td>
<td>database</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_create_collection_command.cpp</td>
</tr>
<tr>
<td>“createCollection”</td>
<td>namespace</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_create_collection_command.cpp</td>
</tr>
<tr>
<td>“dropCollection”</td>
<td>database</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_drop_collection_command.cpp</td>
</tr>
<tr>
<td>“dropCollection”</td>
<td>namespace</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_drop_collection_command.cpp</td>
</tr>
<tr>
<td>“shardCollection”</td>
<td>database</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_shard_collection_command.cpp</td>
</tr>
<tr>
<td>“shardCollection”</td>
<td>namespace</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_shard_collection_command.cpp</td>
</tr>
</tbody></table>
<h4 id="database-操作"><a href="#database-操作" class="headerlink" title="database 操作"></a>database 操作</h4><table>
<thead>
<tr>
<th>whyMessage</th>
<th>_id</th>
<th>function</th>
<th>file</th>
</tr>
</thead>
<tbody><tr>
<td>“movePrimary”</td>
<td>database</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_move_primary_command.cpp</td>
</tr>
<tr>
<td>“enableSharding”</td>
<td>database</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_enable_sharding_command.cpp</td>
</tr>
<tr>
<td>“createDatabase”</td>
<td>database</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_create_database_command.cpp</td>
</tr>
<tr>
<td>“dropDatabase”</td>
<td>database</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_drop_database_command.cpp</td>
</tr>
<tr>
<td>“dropCollection”</td>
<td>namespace</td>
<td>lock</td>
<td>src/mongo/db/s/config/configsvr_drop_database_command.cpp</td>
</tr>
</tbody></table>
<h4 id="chunk-操作"><a href="#chunk-操作" class="headerlink" title="chunk 操作"></a>chunk 操作</h4><table>
<thead>
<tr>
<th>whyMessage</th>
<th>_id</th>
<th>function</th>
<th>file</th>
</tr>
</thead>
<tbody><tr>
<td>“splitting chunk “ &lt;&lt; chunkRange.toString() &lt;&lt; “ in “ &lt;&lt; nss.toString()</td>
<td>namespace</td>
<td>lock</td>
<td>src/mongo/db/s/split_chunk.cpp</td>
</tr>
<tr>
<td>“merging chunks in “ &lt;&lt; nss.ns() &lt;&lt; “ from “ &lt;&lt; minKey &lt;&lt; “ to “ &lt;&lt; maxKey</td>
<td>namespace</td>
<td>lock</td>
<td>src/mongo/db/s/merge_chunks_command.cpp</td>
</tr>
<tr>
<td>“Migrating chunk(s) in collection “ &lt;&lt; migrateType.getNss().ns())</td>
<td>namespace</td>
<td>tryLockWithLocalWriteConcern</td>
<td>src/mongo/db/s/balancer/migration_manager.cpp</td>
</tr>
<tr>
<td>“Migrating chunk(s) in collection “ &lt;&lt; nss.ns()</td>
<td>namespace</td>
<td>lockWithSessionID</td>
<td>src/mongo/db/s/balancer/migration_manager.cpp</td>
</tr>
</tbody></table>
<h4 id="map-reduce操作"><a href="#map-reduce操作" class="headerlink" title="map-reduce操作"></a>map-reduce操作</h4><table>
<thead>
<tr>
<th>whyMessage</th>
<th>_id</th>
<th>function</th>
<th>file</th>
</tr>
</thead>
<tbody><tr>
<td>“mr-post-process”</td>
<td>namespace</td>
<td>lock</td>
<td>src/mongo/s/commands/cluster_map_reduce_cmd.cpp</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/linux/linux-subsys-IO/linux-io-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux/linux-subsys-IO/linux-io-overview/" itemprop="url">Linux IO子系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-20T16:00:27+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/linux-subsys-IO/" itemprop="url" rel="index">
                    <span itemprop="name">linux_subsys_IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用于IO读写的函数"><a href="#用于IO读写的函数" class="headerlink" title="用于IO读写的函数"></a>用于IO读写的函数</h2><p>应用程序通过<code>read</code>/<code>write</code>/<code>sync</code>函数和底层交互进行读写。读写过程依次会经历<code>stdio buffer</code>/<code>kernel buffer</code>/<code>disk</code>。大致流程见下图【图1】：<br><img src="https://wangxin201492.github.io/techImages/linux-io-buffers.png" alt="linux-io-buffers.png"><br><code>read</code>用于数据读取，<code>write</code>用于数据写入，这两个行为默认情况下(<code>bufferedIO</code>)都是写入<code>kernel buffer</code>中，而<code>sync</code>则是将数据从<code>kernel buffer</code>刷入<code>disk</code></p>
<h4 id="read-write-sync相关的函数区分"><a href="#read-write-sync相关的函数区分" class="headerlink" title="read/write/sync相关的函数区分"></a><code>read</code>/<code>write</code>/<code>sync</code>相关的函数区分</h4><p><img src="https://wangxin201492.github.io/techImages/linux-io-function-read-write-sync.png" alt="linux-io-function-read-write-sync.png"><br>上图【图2】描述的比较清楚</p>
<ul>
<li><code>fread</code>/<code>fwrite</code>是stdio提供的方法，数据仅和<code>stdio buffer</code> 交互</li>
<li><code>read</code>/<code>write</code>是系统调用，以默认<code>bufferIO</code>形式调用时，数据仅和<code>kernel buffer</code>交互。而以<code>directIO</code>形式调用，则会跨过<code>kernel buffer</code>，直接和物理设备交互<ul>
<li><code>pread</code>/<code>pwrite</code>同样是系统调用，可以认为是<code>seek</code>+<code>read</code>/<code>write</code></li>
</ul>
</li>
<li><code>fflush</code>则是将<code>stdio buffer</code>数据刷入<code>kernel buffer</code></li>
</ul>
<p><code>sync</code>/<code>fsync</code>/<code>fdatasync</code>:</p>
<ul>
<li>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。</li>
<li>fsync将内核缓冲区中的内容真正写入磁盘</li>
<li>fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。</li>
</ul>
<p>相关阅读：<a href="https://luoming1224.github.io/2018/11/30/[Unix%E7%BC%96%E7%A8%8B]fread%20fwrite%20fflush%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://luoming1224.github.io/2018/11/30/[Unix%E7%BC%96%E7%A8%8B]fread%20fwrite%20fflush%E5%AE%9E%E7%8E%B0/</a></p>
<h3 id="一次完整的读取流程简述"><a href="#一次完整的读取流程简述" class="headerlink" title="一次完整的读取流程简述"></a>一次完整的读取流程简述</h3><p>IO简化的技术栈【图3】中也有相关描述，更加直观一些：<br><img src="https://wangxin201492.github.io/techImages/linux-io-stack-overview.png" alt="linux-io-stack-overview.png"></p>
<p>传统的Buffered IO使用read读取文件的过程什么样的？假设要去读一个冷文件（Cache中不存在），open(2)打开文件内核后建立了一系列的数据结构，接下来调用read(2)，到达文件系统这一层，发现Page Cache中不存在该位置的磁盘映射，然后创建相应的Page Cache并和相关的扇区关联。然后请求继续到达块设备层，在IO队列里排队，接受一系列的调度后到达设备驱动层，此时一般使用DMA方式读取相应的磁盘扇区到Cache中，然后read(2)拷贝数据到用户提供的用户态buffer中去（read(2)的参数指出的）。</p>
<h2 id="IO读写的一些重要特性"><a href="#IO读写的一些重要特性" class="headerlink" title="IO读写的一些重要特性"></a>IO读写的一些重要特性</h2><h3 id="IO类型"><a href="#IO类型" class="headerlink" title="IO类型"></a>IO类型</h3><h4 id="根据是否利用标准库缓存，可以把文件I-O分为缓冲I-O与非缓冲I-O"><a href="#根据是否利用标准库缓存，可以把文件I-O分为缓冲I-O与非缓冲I-O" class="headerlink" title="根据是否利用标准库缓存，可以把文件I/O分为缓冲I/O与非缓冲I/O"></a>根据是否利用标准库缓存，可以把文件I/O分为缓冲I/O与非缓冲I/O</h4><p>缓冲I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调用访问文件<br>非缓冲I/O，是指通过系统调用来访问文件，不再经过标准库缓存<br>注意，这里的 缓冲，是指标准库内部实现的缓存，比如很多程序到换行时才真正输出，而换行之前是被标准库暂时缓存起来了</p>
<h4 id="根据是否利用操作系统的页缓存，可以把文件I-O分为直接I-O和非直接I-O"><a href="#根据是否利用操作系统的页缓存，可以把文件I-O分为直接I-O和非直接I-O" class="headerlink" title="根据是否利用操作系统的页缓存，可以把文件I/O分为直接I/O和非直接I/O"></a>根据是否利用操作系统的页缓存，可以把文件I/O分为直接I/O和非直接I/O</h4><p>直接I/O，是指跳过操作系统页缓存，直接跟文件系统交互来访问文件<br>非直接I/O，在文件读写时，先经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘<br>要实现直接I/O，需要在系统调用中指定O_DIRECT标志，不设置默认是非直接I/O<br>注意，直接I/O和非直接I/O本质上还是和文件系统交互，如果在数据库等场景中，可以跳过文件系统读写磁盘的情况，就是裸I/</p>
<h4 id="根据应用程序是否阻塞自身运行，可以把文件I-O分为阻塞I-O和非阻塞I-O"><a href="#根据应用程序是否阻塞自身运行，可以把文件I-O分为阻塞I-O和非阻塞I-O" class="headerlink" title="根据应用程序是否阻塞自身运行，可以把文件I/O分为阻塞I/O和非阻塞I/O"></a>根据应用程序是否阻塞自身运行，可以把文件I/O分为阻塞I/O和非阻塞I/O</h4><h4 id="是指应用程序执行I-O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务"><a href="#是指应用程序执行I-O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务" class="headerlink" title="是指应用程序执行I/O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务"></a>是指应用程序执行I/O操作后，如果没有获得响应，就会阻塞当前线程，自然不能执行其他任务</h4><p>非阻塞I/O，是指应用程序执行I/O操作后，不会阻塞当前的线程，可以继续执行其他的人物，随后再通过轮询或者事件通知的形式，获取调用的结果<br>比如访问管道或者网络套接字时，设置O_NONBLOCK标志，就表示用非阻塞方式访问，默认是阻塞访问</p>
<h4 id="根据是否等待响应结果，可以把文件I-O分为同步和异步I-O"><a href="#根据是否等待响应结果，可以把文件I-O分为同步和异步I-O" class="headerlink" title="根据是否等待响应结果，可以把文件I/O分为同步和异步I/O"></a>根据是否等待响应结果，可以把文件I/O分为同步和异步I/O</h4><p>同步I/O，是指应用程序执行I/O操作后，要一直等到整个I/O完成后，才能获得I/O响应<br>异步I/O，是指应用程序执行I/O操作后，不用等待完成和完成后的响应，而是继续执行就可以，等到这次I/O完成后，响应会用事件通知的方式，告诉应用程序</p>
<h4 id="顺序访问-Sequential-Access-amp-随机访问-Random-Access"><a href="#顺序访问-Sequential-Access-amp-随机访问-Random-Access" class="headerlink" title="顺序访问(Sequential Access)&amp;随机访问(Random Access)"></a>顺序访问(Sequential Access)&amp;随机访问(Random Access)</h4><p>连续和随机，取决于本次IO的初始扇区地址，和上一次IO的结束扇区地址是否连续。如果是，则本次IO是一个连续IO；如果不连续，算一次随机IO。</p>
<ul>
<li>连续IO：因为本次初始扇区和上次结束扇区相隔很近，则磁头几乎不用换道或换道时间极短；</li>
<li>随机IO：磁头需要很长的换道时间，如果随机IO很多，导致磁头不停换道，效率会大大降底</li>
</ul>
<h3 id="磁盘预读-read-ahead"><a href="#磁盘预读-read-ahead" class="headerlink" title="磁盘预读(read ahead)"></a>磁盘预读(read ahead)</h3><h3 id="write-back、write-through、page-cache"><a href="#write-back、write-through、page-cache" class="headerlink" title="write back、write through、page cache"></a>write back、write through、page cache</h3><h3 id="读写过程中的数据拷贝（zero-copy）"><a href="#读写过程中的数据拷贝（zero-copy）" class="headerlink" title="读写过程中的数据拷贝（zero-copy）"></a>读写过程中的数据拷贝（zero-copy）</h3><p>整个过程有几次拷贝？从磁盘到Page Cache算第一次的话，从Page Cache到用户态buffer就是第二次了。</p>
<p>而mmap(2)做了什么？mmap(2)直接把Page Cache映射到了用户态的地址空间里了，所以mmap(2)的方式读文件是没有第二次拷贝过程的。</p>
<p>那Direct IO做了什么？这个机制更狠，直接让用户态和块IO层对接，直接放弃Page Cache，从磁盘直接和用户态拷贝数据。好处是什么？写操作直接映射进程的buffer到磁盘扇区，以DMA的方式传输数据，减少了原本需要到Page Cache层的一次拷贝，提升了写的效率。对于读而言，第一次肯定也是快于传统的方式的，但是之后的读就不如传统方式了（当然也可以在用户态自己做Cache，有些商用数据库就是这么做的）。</p>
<blockquote>
<p>除了传统的Buffered IO可以比较自由的用偏移+长度的方式读写文件之外，mmap(2)和Direct IO均有数据按页对齐的要求，Direct IO还限制读写必须是底层存储设备块大小的整数倍（甚至Linux 2.4还要求是文件系统逻辑块的整数倍）。所以接口越来越底层，换来表面上的效率提升的背后，需要在应用程序这一层做更多的事情。所以想用好这些高级特性，除了深刻理解其背后的机制之外，也要在系统设计上下一番功夫。</p>
</blockquote>
<h3 id="顺序IO模式-Queue-Mode-并发IO模式-Burst-Mode"><a href="#顺序IO模式-Queue-Mode-并发IO模式-Burst-Mode" class="headerlink" title="顺序IO模式(Queue Mode)/并发IO模式(Burst Mode)"></a>顺序IO模式(Queue Mode)/并发IO模式(Burst Mode)</h3><p>磁盘控制器可能会一次对磁盘组发出一连串的IO命令，如果磁盘组一次只能执行一个IO命令时称为顺序IO;当磁盘组能同时执行多个IO命令时，称为并发IO。</p>
<p>并发IO只能发生在由多个磁盘组成的磁盘组上，单块磁盘只能一次处理一个IO命令。</p>
<h3 id="缺页中断（Page-Fault）"><a href="#缺页中断（Page-Fault）" class="headerlink" title="缺页中断（Page Fault）"></a>缺页中断（Page Fault）</h3><h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><ol>
<li>提高IO效率原则： 顺序写，随机读</li>
<li>重点监控 rkB/s 和 和 wkB/s</li>
<li>%util接近100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈</li>
<li>await与svctm相差很大的时候，要注意磁盘的IO性能。差值越小，说明队列时间越短，反之则队列时间越长。说明系统出了问题。</li>
</ol>
<p>规避IO负载过高：</p>
<ul>
<li>如果服务器用来做日志分析，注意随机读和顺序写，避免定期的压缩、解压大日志。</li>
<li>如果是前端应用服务器，要避免程序频繁打本地日志、或者异常日志</li>
<li>如果是存储服务（mysql、nosql），尽量将服务部署在单独的节点上，做读写分离降低压力</li>
</ul>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ol>
<li><a href="https://www.cnblogs.com/muahao/p/6596545.html" target="_blank" rel="noopener">https://www.cnblogs.com/muahao/p/6596545.html</a></li>
<li><a href="https://testerhome.com/articles/21493" target="_blank" rel="noopener">https://testerhome.com/articles/21493</a></li>
<li><a href="http://blog.chinaunix.net/uid-667478-id-2384354.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-667478-id-2384354.html</a></li>
<li><a href="http://www.0xffffff.org/2017/05/01/41-linux-io/" target="_blank" rel="noopener">http://www.0xffffff.org/2017/05/01/41-linux-io/</a></li>
<li><a href="https://blog.csdn.net/hixiaoxiaoniao/article/details/86295712" target="_blank" rel="noopener">https://blog.csdn.net/hixiaoxiaoniao/article/details/86295712</a></li>
</ol>
<hr>
<h1 id="IO栈及各层功能"><a href="#IO栈及各层功能" class="headerlink" title="IO栈及各层功能"></a>IO栈及各层功能</h1><p>上文【图3】中可以看到，IO行为依次经历“应用层”、“内核层”、“块层”、“设备层”和磁盘交互。按照下图将这个层次再进一步的划分下：“文件系统层”（包含“VFS”、“Page Cache”）、“Block层”（包含“device mapper”）、“device层”</p>
<ul>
<li>文件系统层，以 write(2) 为例，内核拷贝了write(2)参数指定的用户态数据到文件系统Cache中，并适时向下层同步</li>
<li>块层，管理块设备的IO队列，对IO请求进行合并、排序（还记得操作系统课程学习过的IO调度算法吗？）</li>
<li>设备层，通过DMA与内存直接交互，完成数据和具体设备之间的交互</li>
</ul>
<p><img src="https://wangxin201492.github.io/techImages/linux-io-stack-overview-detail.png" alt="linux-io-stack-overview-detail.png"></p>
<h2 id="文件系统层"><a href="#文件系统层" class="headerlink" title="文件系统层"></a>文件系统层</h2><h3 id="缺页中断-–-page-fault"><a href="#缺页中断-–-page-fault" class="headerlink" title="缺页中断 – page fault"></a>缺页中断 – page fault</h3><p>当程序启动的时候，Linux 内核首先检查 CPU 的缓存和物理内存，如果数据已经在内存里就忽略，如果数据不在内存里就引起一个<strong>缺页中断（Page Fault）</strong>，然后从硬盘读取缺页，并把缺页缓存到物理内存里。<br>缺页中断可分为主缺页中断（Major Page Fault）和次缺页中断（Minor Page Fault）</p>
<ul>
<li>要从磁盘读取数据而产生的中断是主缺页中断</li>
<li>数据已经被读入内存并被缓存起来，从内存缓存区中而不是直接从硬盘中读取数据而产生的中断是次 缺页中断(page cache?)</li>
</ul>
<h3 id="磁盘预读-–-read-ahead"><a href="#磁盘预读-–-read-ahead" class="headerlink" title="磁盘预读 – read ahead"></a>磁盘预读 – read ahead</h3><h4 id="顺序性检测"><a href="#顺序性检测" class="headerlink" title="顺序性检测"></a>顺序性检测</h4><p>为了保证预读命中率，Linux只对顺序读(sequential read)进行预读。内核通过验证如下两个条件来判定一个read()是否顺序读：</p>
<ol>
<li>这是文件被打开后的第一次读，并且读的是文件首部；</li>
<li>当前的读请求与前一（记录的）读请求在文件内的位置是连续的。</li>
</ol>
<p>如果不满足上述顺序性条件，就判定为随机读</p>
<h4 id="预读的大小"><a href="#预读的大小" class="headerlink" title="预读的大小"></a>预读的大小</h4><p>Linux采用了一个快速的窗口扩张过程：</p>
<ul>
<li>首次预读： readahead_size = read_size * 2; // or *4</li>
<li>后续预读： readahead_size *= 2;<ul>
<li>后续的预读窗口将逐次倍增，直到达到系统设定的最大预读大小，其缺省值是128KB。</li>
<li>调整大小：blockdev –setra 2048 /dev/sda</li>
</ul>
</li>
</ul>
<h3 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h3><p>page cache有三种类型：</p>
<ol>
<li>Read pages只读页（或代码页）<ul>
<li>那些通过主缺页中断从硬盘读取的页面，包括不能修改的静态文件、可执行文件、库文件等。当内核需要它们的时候把它们读到 内存中，当内存不足的时候，内核就释放它们到空闲列表，当程序再次需要它们的时候需要通过缺页中断再次读到内存。</li>
</ul>
</li>
<li>Dirty pages，脏页<ul>
<li>指那些在内存中被修改过的数据页，比如文本文件等。这些文件由 pdflush 负责同步到硬盘，内存不足的时候由 kswapd 和 pdflush 把数据写回硬盘并释放内存。</li>
</ul>
</li>
<li>Anonymous pages，匿名页<ul>
<li>那些属于某个进程但是又和任何文件无关联，不能被同步到硬盘上，内存不足的时候由 kswapd 负责将它们写到交换分区并释放内存。</li>
</ul>
</li>
</ol>
<h3 id="Write-Through（写穿）和Write-back（写回）-–-page-cache同步"><a href="#Write-Through（写穿）和Write-back（写回）-–-page-cache同步" class="headerlink" title="Write Through（写穿）和Write back（写回） – page cache同步"></a>Write Through（写穿）和Write back（写回） – page cache同步</h3><p>广义上Cache的同步方式有两种，即Write Through（写穿）和Write back（写回）. 从名字上就能看出这两种方式都是从写操作的不同处理方式引出的概念（纯读的话就不存在Cache一致性了，不是么）。对应到Linux的Page Cache上</p>
<ul>
<li>Write Through就是指write(2)操作将数据拷贝到Page Cache后立即和下层进行同步的写操作，完成下层的更新后才返回。</li>
<li>而Write back正好相反，指的是写完Page Cache就可以返回了。Page Cache到下层的更新操作是异步进行的。</li>
</ul>
<p>Linux下Buffered IO默认使用的是Write back机制，即文件操作的写只写到Page Cache就返回，之后Page Cache到磁盘的更新操作是异步进行的。Page Cache中被修改的内存页称之为脏页（Dirty Page），脏页在特定的时候被一个叫做pdflush(Page Dirty Flush)的内核线程写入磁盘，写入的时机和条件如下：</p>
<p>当空闲内存低于一个特定的阈值时，内核必须将脏页写回磁盘，以便释放内存。<br>当脏页在内存中驻留时间超过一个特定的阈值时，内核必须将超时的脏页写回磁盘。<br>用户进程调用sync(2)、fsync(2)、fdatasync(2)系统调用时，内核会执行相应的写回操作。<br>刷新策略由以下几个参数决定（数值单位均为1/100秒）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># flush每隔5秒执行一次</span><br><span class="line">root@082caa3dfb1d &#x2F; $ sysctl vm.dirty_writeback_centisecs</span><br><span class="line">vm.dirty_writeback_centisecs &#x3D; 500</span><br><span class="line"># 内存中驻留30秒以上的脏数据将由flush在下一次执行时写入磁盘</span><br><span class="line">root@082caa3dfb1d &#x2F; $ sysctl vm.dirty_expire_centisecs</span><br><span class="line">vm.dirty_expire_centisecs &#x3D; 3000</span><br><span class="line"># 若脏页占总物理内存10％以上，则触发flush把脏数据写回磁盘</span><br><span class="line">root@082caa3dfb1d &#x2F; $ sysctl vm.dirty_background_ratio</span><br><span class="line">vm.dirty_background_ratio &#x3D; 10</span><br></pre></td></tr></table></figure>

<p>默认是写回方式，如果想指定某个文件是写穿方式呢？即写操作的可靠性压倒效率的时候，能否做到呢？当然能，除了之前提到的fsync(2)之类的系统调用外，在open(2)打开文件时，传入O_SYNC这个flag即可实现。这里给篇参考文章[5]，不再赘述（更好的选择是去读TLPI相关章节）。</p>
<p>文件读写遭遇断电时，数据还安全吗？相信你有自己的答案了。使用O_SYNC或者fsync(2)刷新文件就能保证安全吗？现代磁盘一般都内置了缓存，代码层面上也只能讲数据刷新到磁盘的缓存了。当数据已经进入到磁盘的高速缓存时断电了会怎么样？这个恐怕不能一概而论了。不过可以使用hdparm -W0命令关掉这个缓存，相应的，磁盘性能必然会降低。</p>
<h3 id="文件系统与inode"><a href="#文件系统与inode" class="headerlink" title="文件系统与inode"></a>文件系统与inode</h3><p><img src="https://wangxin201492.github.io/techImages/linux-filesystem-inode.png" alt="linux-filesystem-inode.png"></p>
<p>应用程序在访问文件时都会先打开文件，在内核中，对应每个进程，都会有一个文件描述符表表示这个进程打开的文件，但是用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引（一个整数），这些索引就被称为文件描述符。当调用open 打开一个文件或创建一个新文件时,内核分配一个文件描述符并返回给用户程序,该文件描述符表项中的指针指向新打开的文件。</p>
<p>文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块–file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程。</p>
<p>file对象中包含一个指针，指向dentry对象。dentry对象代表一个独立的文件路径，如果一个文件路径被打开多次，那么会建立多个file对象，但它们都指向同一个dentry对象。inode对象代表一个独立文件，inode 对象包含了最终对文件进行操作所需的所有信息，如文件系统类型、文件的操作方法、文件的权限、访问日期等。</p>
<h3 id="文件系统磁盘布局"><a href="#文件系统磁盘布局" class="headerlink" title="文件系统磁盘布局"></a>文件系统磁盘布局</h3><p><img src="https://wangxin201492.github.io/techImages/linux-filesystem-ext-blocks.png" alt="linux-filesystem-ext-blocks.png"></p>
<p>ext3文件系统将其所管理的磁盘或者分区(引导块除外)中的块划分到不同的块组中。每个块组大小相同，当然最后一个块组所管理的块可能会少一些，其大小在文件系统创建时决定，主要取决于文件系统的块大小。每个块组包含一个块位图块，一个inode位图块，一个或多个块用于描述 inode 表和用于存储文件数据的数据块，除此之外，还有可能包含超级块和所有块组描述符表。<br>块位图用于描述该块组所管理的块的分配状态，如果某个块对应的位未置位，那么代表该块未分配，可以进行分配使用。inode位图用于描述该块组所管理的inode的分配状态，每个inode对应文件系统中唯一的一个号，如果inode位图中相应位置位，那么代表该inode已经分配出去；否则可以使用。</p>
<h3 id="日志文件系统和非日志文件系统"><a href="#日志文件系统和非日志文件系统" class="headerlink" title="日志文件系统和非日志文件系统"></a>日志文件系统和非日志文件系统</h3><p>文件内容的修改涉及到两部分：实际文件内容的修改 和 文件元(metadata)信息的修改。所以在修改一个成功之后，修改另一个之前，此时系统崩溃，就会导致两者的不一致。所以提出了日志文件系统的概念。</p>
<p>所谓的日志文件系统(Journaling file system)，就是在实际修改文件内容和文件元信息之前，将他们的修改先写到一个日志中(journal log)。这样的话，如果发生系统崩溃，就可以使用日志进行恢复。当然，写日志会对文件系统的性能有一定的影响。除了ext2之外，其它文件系统几乎都是日志文件系统。</p>
<p>日志文件系统的处理过程是：1）先写日志；2）然后写实际的文件系统；3）删除日志；</p>
<p>日志文件系统又可以分成三种类型：</p>
<ol>
<li>日志模式(journal): 将所有的元数据和数据改变均写入日志，对性能影响最大；</li>
<li>预定模式(ordered): 只记录元数据的变化, 在数据写入磁盘后再修改元数据，对性能影响中等；</li>
<li>写回模式(writeback): 只记录元数据的修改变化，对数据修改顺序无要求，对性能影响最小；</li>
</ol>
<p>我们可以在/etc/fstab 文件中修改文件系统的日志模式。<br>/dev/sdb1 /testfs ext3 defaults,data=writeback 0 0</p>
<h3 id="相关阅读-1"><a href="#相关阅读-1" class="headerlink" title="相关阅读"></a>相关阅读</h3><ol>
<li><a href="http://www.sysnote.org/2015/08/06/fs-io-map/" target="_blank" rel="noopener">http://www.sysnote.org/2015/08/06/fs-io-map/</a></li>
<li><a href="http://oliveryang.net/2016/05/linux-file-system-basic-4/" target="_blank" rel="noopener">http://oliveryang.net/2016/05/linux-file-system-basic-4/</a></li>
<li><a href="https://www.cnblogs.com/digdeep/p/4857987.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4857987.html</a></li>
</ol>
<h2 id="Block层"><a href="#Block层" class="headerlink" title="Block层"></a>Block层</h2><h3 id="block-IO"><a href="#block-IO" class="headerlink" title="block IO"></a>block IO</h3><p>一个I/O请求进入block layer之后，可能会经历下面的过程：</p>
<ul>
<li>Remap: 可能被DM(Device Mapper)或MD(Multiple Device, Software RAID) remap到其它设备</li>
<li>Split: 可能会因为I/O请求与扇区边界未对齐、或者size太大而被分拆(split)成多个物理I/O</li>
<li>Merge: 可能会因为与其它I/O请求的物理位置相邻而合并(merge)成一个I/O</li>
<li>被IO Scheduler依照调度策略发送给driver</li>
<li>被driver提交给硬件，经过HBA、电缆（光纤、网线等）、交换机（SAN或网络）、最后到达存储设备，设备完成IO请求之后再把结果发回。</li>
</ul>
<h3 id="device-mapper层"><a href="#device-mapper层" class="headerlink" title="device mapper层"></a>device mapper层</h3><h2 id="device层"><a href="#device层" class="headerlink" title="device层"></a>device层</h2><h3 id="机械磁盘基本结构"><a href="#机械磁盘基本结构" class="headerlink" title="机械磁盘基本结构"></a>机械磁盘基本结构</h3><p><img src="https://wangxin201492.github.io/techImages/linux-disk-HDD-overview.png" alt="linux-disk-HDD-overview.png"><br>硬盘由三部分组成，物理结构，数据结构，存储容量</p>
<ul>
<li>数据结构:<ul>
<li>扇区：磁盘上每个磁道被分为若干个弧段，这些弧段便是硬盘的扇区。硬盘的第一个扇区，叫做引导扇区。</li>
<li>磁道：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹 叫做磁道</li>
</ul>
</li>
<li>物理结构<ul>
<li>盘片：硬盘有多个盘片，每个盘片有2面。</li>
<li>磁头：每面一个磁头</li>
</ul>
</li>
<li>存储容量 = 磁头数<em>磁道数</em>每道扇区数*每扇区字节数</li>
</ul>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>固态硬盘(Solid State Disk)，通常缩写为SSD，由固态电子元器件组成，固态磁盘不需要磁道寻址，所以不管是连续I/O，还是随机I/O的性能，都比机械磁盘要好得多</p>
<h4 id="机械硬盘-amp-固态硬盘"><a href="#机械硬盘-amp-固态硬盘" class="headerlink" title="机械硬盘&amp;固态硬盘"></a>机械硬盘&amp;固态硬盘</h4><p>无论机械盘还是固态磁盘，相同磁盘的随机I/O都要比连续I/O慢很多</p>
<ul>
<li>对机械磁盘来说，由于随机I/O需要更多的磁头晕倒和盘片旋转，它的性能自然比连续I/O慢</li>
<li>对于固态磁盘，虽然它的随机性能比机械硬盘好很多，但同样存在“先擦除再写入”的限制，随机读写会导致大量的垃圾回收，导致随机I/O的性能比连续I/O还是差了很多</li>
<li>连续I/O还可以通过预读取的方式，来减少I/O请求的次数，这也是其性能优异的一个原因，很多性能优化的方案，都会从这个角度出发，来优化I/O性能</li>
</ul>
<p>机械磁盘和固态硬盘还有一个最小的读写单位</p>
<ul>
<li>机械磁盘的最小读写单位是扇区，一般为512字节</li>
<li>固态硬盘的最小读写单位是页，通常大小是4KB，8KB等</li>
</ul>
<p>由于每次读写512字节这么小的单位效率很低，所以文件系统会把连续的扇区，组成逻辑块，然后以逻辑快作为最小单位来管理数据，常见的逻辑块大小是4KB，也就是连续8个扇区，或者一个独立的页，都可以组成一个逻辑块</p>
<h3 id="磁盘读取数据花费的时间"><a href="#磁盘读取数据花费的时间" class="headerlink" title="磁盘读取数据花费的时间"></a>磁盘读取数据花费的时间</h3><h4 id="寻道时间"><a href="#寻道时间" class="headerlink" title="寻道时间"></a>寻道时间</h4><p>磁盘的驱动臂(Actuator Arm)带读写磁头(Head)离开着陆区(Landing Zone，位于内圈没有数据的区域)，移动到要操作的初始数据块所在的磁道(Track)的正上方，这个过程被称为寻址(Seeking)，对应消耗的时间被称为寻址时间(Seek Time)</p>
<p>考虑到被读写的数据可能在磁盘的任意一个磁道，既有可能在磁盘的最内圈(寻址时间最短)，也可能在磁盘的最外圈(寻址时间最长)，所以在计算中我们只考虑平均寻址时间，也就是磁盘参数中标明的那个平均寻址时间，这里就采用当前最多的10krmp硬盘的5ms。</p>
<p>目前磁盘的平均寻道时间一般在3－15ms。</p>
<h4 id="旋转延迟"><a href="#旋转延迟" class="headerlink" title="旋转延迟"></a>旋转延迟</h4><p>但是找到对应磁道还不能马上读取数据，这时候磁头要等到磁盘盘片(Platter)旋转到初始数据块所在的扇区(Sector)落在读写磁头正上方的之后才能开始读取数据，在这个等待盘片旋转到可操作扇区的过程中消耗的时间称为旋转延时(Rotational Delay)</p>
<p>和寻址一样，当磁头定位到磁道之后有可能正好在要读写扇区之上，这时候是不需要额外额延时就可以立刻读写到数据，但是最坏的情况确实要磁盘旋转整整一圈之后磁头才能读取到数据，所以这里我们也考虑的是平均旋转延时，对于10krpm的磁盘就是(60s/15k)*(1/2) = 2ms。</p>
<h4 id="数据传输时间"><a href="#数据传输时间" class="headerlink" title="数据传输时间"></a>数据传输时间</h4><p>接下来就随着盘片的旋转，磁头不断的读/写相应的数据块，直到完成这次IO所需要操作的全部数据，这个过程称为数据传送(Data Transfer)，对应的时间称为传送时间(Transfer Time)</p>
<p>磁盘参数提供我们的最大的传输速度，当然要达到这种速度是很有难度的，但是这个速度却是磁盘纯读写磁盘的速度，因此只要给定了单次 IO的大小，我们就知道磁盘需要花费多少时间在数据传送上，这个时间就是IO Chunk Size / Max Transfer Rate。</p>
<p>目前IDE/ATA能达到133MB/s，SATA II可达到300MB/s的接口数据传输率</p>
<h3 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h3><h4 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h4><blockquote>
<p>在windows下叫做簇，在linux下如ext4系统中成为块(block)</p>
</blockquote>
<p>块是操作系统中最小的逻辑存储单位(虚拟出来的)，操作系统与磁盘打交道的最小单位是磁盘块，每个块可以包括2、4、8、16、32、64…2的n次方个扇区</p>
<p>优点：</p>
<ol>
<li>读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作</li>
<li>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位</li>
</ol>
<h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p>
<p>获取方式：<code>/usr/bin/time -v data</code></p>
<h4 id="扇区、块-簇、page的关系"><a href="#扇区、块-簇、page的关系" class="headerlink" title="扇区、块/簇、page的关系"></a>扇区、块/簇、page的关系</h4><ol>
<li>扇区： 硬盘的最小读写单元</li>
<li>块/簇： 是操作系统针对硬盘读写的最小单元</li>
<li>page： 是内存与操作系统之间操作的最小单元</li>
</ol>
<p>大小关系：扇区 &lt;= 块/簇 &lt;= page</p>
<p>目前接触到的扇区一般为512B，块为4KB，page为4KB</p>
<h3 id="磁盘类型一些名词区分"><a href="#磁盘类型一些名词区分" class="headerlink" title="磁盘类型一些名词区分"></a>磁盘类型一些名词区分</h3><h4 id="尺寸外形"><a href="#尺寸外形" class="headerlink" title="尺寸外形"></a>尺寸外形</h4><p>也就是设备的形状和大小，通常存储设备的尺寸外形包括如下：</p>
<ul>
<li>2.5寸或者3.5寸驱动器（在SFF标准中定义）</li>
<li>M.2 和 PCI Express（PCIe）（在PCI-SIG标准中定义）</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>也就是设备如何与计算机通信。常见的存储设备接口包括：</p>
<ul>
<li>SATA接口，通常用于2.5寸和3.5寸硬盘，有时候一些M.2设备也会使用</li>
<li>PCI Express(PCIe)接口， 用于M.2和PCIe设备</li>
<li>SAS（串行SCSI）和FC（Fibre Channel）接口</li>
</ul>
<p>仅用于服务器领域和数据中心 PCIe接口要比SATA接口快的多，SATA3最大带宽是6Gb/s，而基于4X PCIe的M.2接口最大可以达到32Gb/s。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>定义了如何在计算机与设备之间传输数据。常见的协议包括：</p>
<ul>
<li>用于SATA接口的AHCI或者ATA协议</li>
<li>用于PCIe接口的NVMe协议</li>
</ul>
<h4 id="为什么NVMe会这么快"><a href="#为什么NVMe会这么快" class="headerlink" title="为什么NVMe会这么快"></a>为什么NVMe会这么快</h4><blockquote>
<p>这里说的快是基于SSD设备的，如果是机械硬盘则不然</p>
</blockquote>
<p>由于SSD本身的物理特性，其数据的访问已经非常快了，性能的瓶颈就是出在计算机与设备连接的接口和协议上面。 </p>
<ul>
<li>对于SATA的SSD，类似于一个单臂的机器人，仓库生产的很快，但机器人每次只能拿一个，搬移的速度就比较慢。</li>
<li>然而对于基于NVMe的SSD，相当于这个机器人长了数百只手，这样速度显然就比前者快的多了。</li>
</ul>
<h3 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h3><p>IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。</p>
<h4 id="IOPS计算方法"><a href="#IOPS计算方法" class="headerlink" title="IOPS计算方法"></a>IOPS计算方法</h4><p>传统磁盘本质上一种机械装置，如FC, SAS, SATA磁盘，转速通常为5400/7200/10K/15K rpm不等。影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个I/O请求所花费的时间，它由<code>寻道时间</code>、<code>旋转延迟</code>和<code>数据传输时间</code>三部分构成。</p>
<p>理论上可以计算出磁盘的最大IOPS，即<code>IOPS = 1000 ms/ (Tseek + Troatation)</code>，忽略数据传输时间。假设磁盘平均物理寻道时间为3ms, 磁盘转速为7200,10K,15K rpm，则磁盘IOPS理论最大值分别为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;7200&#x2F;2)  &#x3D; 140</span><br><span class="line">IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;10000&#x2F;2) &#x3D; 167</span><br><span class="line">IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;15000&#x2F;2) &#x3D; 200</span><br></pre></td></tr></table></figure>

<p>固态硬盘SSD是一种电子装置， 避免了传统磁盘在寻道和旋转上的时间花费，存储单元寻址开销大大降低，因此IOPS可以非常高，能够达到数万甚至数十万。</p>
<h3 id="传输速度-Transfer-Rate-吞吐率-Throughput"><a href="#传输速度-Transfer-Rate-吞吐率-Throughput" class="headerlink" title="传输速度(Transfer Rate)/吞吐率(Throughput)"></a>传输速度(Transfer Rate)/吞吐率(Throughput)</h3><p>现在我们要说的传输速度(另一个常见的说法是吞吐率)不是磁盘上所表明的最大传输速度或者说理想传输速度，而是磁盘在实际使用的时候从磁盘系统总线上流过的数据量。有了IOPS数据之后我们是很容易就能计算出对应的传输速度来的</p>
<p><img src="https://wangxin201492.github.io/techImages/linux-io-size-effect-iops.png" alt="linux-io-size-effect-iops.png"></p>
<p>这里一定要明确一个概念，那就是尽管上面我们使用IOPS来计算传输速度，但是实际上传输速度和IOPS是没有直接关系，在没有缓存的情况下它们共同的决定因素都是对磁盘系统的访问方式以及单个IO的大小。</p>
<p>对磁盘进行随机访问时候我们可以利用IOPS来衡量一个磁盘系统的性能，此时的传输速度不会太大;但是当对磁盘进行连续访问时，此时的IOPS已经没有了参考的价值，这个时候限制实际传输速度却是磁盘的最大传输速度。</p>
<p>因此在实际的应用当中，<strong>只会用IOPS来衡量小IO的随机读写的性能，而当要衡量大IO连续读写的性能的时候就要采用传输速度而不能是IOPS了</strong></p>
<h2 id="相关阅读-2"><a href="#相关阅读-2" class="headerlink" title="相关阅读"></a>相关阅读</h2><ol>
<li><a href="https://blog.51cto.com/14449536/2431772" target="_blank" rel="noopener">https://blog.51cto.com/14449536/2431772</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/71932170" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71932170</a></li>
<li><a href="https://www.cnblogs.com/muahao/p/6596545.html" target="_blank" rel="noopener">https://www.cnblogs.com/muahao/p/6596545.html</a></li>
</ol>
<h3 id="内核代码分析"><a href="#内核代码分析" class="headerlink" title="内核代码分析"></a>内核代码分析</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/56823442" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56823442</a></li>
<li><a href="https://www.codeleading.com/article/22651695474/" target="_blank" rel="noopener">https://www.codeleading.com/article/22651695474/</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html</a></li>
<li><a href="http://oenhan.com/ext3-fs-directio" target="_blank" rel="noopener">http://oenhan.com/ext3-fs-directio</a></li>
<li><a href="http://oenhan.com/linux-kernel-read" target="_blank" rel="noopener">http://oenhan.com/linux-kernel-read</a></li>
</ol>
<hr>
<h2 id="IO监控工具"><a href="#IO监控工具" class="headerlink" title="IO监控工具"></a>IO监控工具</h2><p><img src="https://wangxin201492.github.io/techImages/linux-io-utils.png" alt="linux-io-utils.png"></p>
<h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>常用<code>iostat -dx 1 100</code>。iostat(1)和sar(1)都没有指标可以衡量硬盘设备的性能，这是因为它们所依赖的/proc/diskstats不提供这项数据</p>
<ul>
<li>IOPS：r/s &amp; w/s</li>
<li>带宽：rkB/s &amp; wkB/s</li>
<li>IO合并：rrqm/s &amp; wrqm/s。如果两个I/O操作发生在相邻的数据块时，它们可以被合并成一个，以提高效率，合并的操作通常是I/O scheduler（也叫elevator）负责的</li>
<li>avgrq-sz：每个I/O的平均扇区数</li>
<li>avgqu-sz：平均未完成的I/O请求数量（手册上说是队列里的平均I/O请求数量，更恰当的理解应该是平均未完成的I/O请求数量。）</li>
<li>svctm：已被废弃的指标，没什么意义，svctm=[util/tput]。iostat(1)和sar(1)的man page上都说了不要相信svctm，该指标将被废弃</li>
<li>%util：该硬盘设备的繁忙比率。表示该设备有I/O（即非空闲）的时间比率，不考虑I/O有多少，只考虑有没有。由于现代硬盘设备都有并行处理多个I/O请求的能力，所以%util即使达到100%也不意味着设备饱和了<ul>
<li>某硬盘处理单个I/O需要0.1秒，有能力同时处理10个I/O请求，那么当10个I/O请求依次顺序提交的时候，需要1秒才能全部完成，在1秒的采样周期里%util达到100%；而如果10个I/O请求一次性提交的话，0.1秒就全部完成，在1秒的采样周期里%util只有10%。可见，即使%util高达100%，硬盘也仍然有可能还有余力处理更多的I/O请求，即没有达到饱和状态</li>
</ul>
</li>
</ul>
<h3 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h3><p>这两个命令,都可以按进程统计IO状况,因此可以回答你以下二个问题</p>
<p>当前系统哪些进程在占用IO,百分比是多少?<br>占用IO的进程是在读?还是在写?读写量是多少?</p>
<h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u -r -d -t 1        </span><br><span class="line"># -d IO 信息,</span><br><span class="line"># -r 缺页及内存信息</span><br><span class="line"># -u CPU使用率</span><br><span class="line"># -t 以线程为统计单位</span><br><span class="line"># 1  1秒统计一次</span><br></pre></td></tr></table></figure>

<h3 id="block-dump-iodump"><a href="#block-dump-iodump" class="headerlink" title="block_dump, iodump"></a>block_dump, iodump</h3><p>iotop和 pidstat 用着很爽,但两者都依赖于/proc/pid/io文件导出的统计信息, 这个对于老一些的内核是没有的.因此只好用以上2个穷人版命令</p>
<h3 id="ioprofile"><a href="#ioprofile" class="headerlink" title="ioprofile"></a>ioprofile</h3><p>ioprofile 命令本质上是 lsof + strace, 具体下载可见 <a href="http://code.google.com/p/maatkit/" target="_blank" rel="noopener">http://code.google.com/p/maatkit/</a></p>
<p>ioprofile 可以回答你以下三个问题:</p>
<ul>
<li>当前进程某时间内,在业务层面读写了哪些文件(read, write)？</li>
<li>读写次数是多少?(read, write的调用次数)</li>
<li>读写数据量多少?(read, write的byte数)</li>
</ul>
<p>假设某个行为会触发程序一次IO动作,例如: “一个页面点击,导致后台读取A,B,C文件”<br>./io_event # 假设模拟一次IO行为,读取A文件一次, B文件500次, C文件500次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ioprofile  -p  &#96;pidof  io_event&#96; -c count   # 读写次数</span><br><span class="line">ioprofile  -p  &#96;pidof  io_event&#96; -c times   # 读写耗时</span><br><span class="line">ioprofile  -p  &#96;pidof  io_event&#96; -c sizes    # 读写大小</span><br></pre></td></tr></table></figure>

<h3 id="相关阅读-3"><a href="#相关阅读-3" class="headerlink" title="相关阅读"></a>相关阅读</h3><ol>
<li><a href="https://www.cnblogs.com/muahao/p/6564745.html" target="_blank" rel="noopener">https://www.cnblogs.com/muahao/p/6564745.html</a></li>
<li><a href="http://linuxperf.com/?p=156" target="_blank" rel="noopener">http://linuxperf.com/?p=156</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/shell/shell-and-subshell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shell/shell-and-subshell/" itemprop="url">【shell】shell与子shell那团乱麻</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-16T20:01:48+08:00">
                2015-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-fork-amp-source-amp-exec"><a href="#1-fork-amp-source-amp-exec" class="headerlink" title="1. fork &amp; source &amp; exec"></a>1. <code>fork</code> &amp; <code>source</code> &amp; <code>exec</code></h2><p>在运行shell脚本时候，有三种方式来调用外部的脚本，<code>exec(exec script.sh)</code>、<code>source(source script.sh)</code>、<code>fork(./script.sh)</code></p>
<h3 id="1-1-exec（exec-home-script-sh）："><a href="#1-1-exec（exec-home-script-sh）：" class="headerlink" title="1.1. exec（exec /home/script.sh）："></a>1.1. exec（exec /home/script.sh）：</h3><p>使用<code>exec</code>来调用脚本，被执行的脚本会继承当前shell的环境变量。<strong>但事实上<code>exec</code>产生了新的进程，他会把主shell的进程资源占用并替换脚本内容，继承了原主shell的PID号，即原主shell剩下的内容不会执行。</strong></p>
<h3 id="1-2-source（source-home-script-sh）"><a href="#1-2-source（source-home-script-sh）" class="headerlink" title="1.2. source（source /home/script.sh）"></a>1.2. source（source /home/script.sh）</h3><p>使用<code>source</code>或者“<code>.</code>”来调用外部脚本，<strong>不会产生新的进程</strong>，继承当前shell环境变量，而且被调用的脚本运行结束后，<strong>它拥有的环境变量和声明变量会被当前shell保留</strong>，类似将调用脚本的内容复制过来直接执行。<strong>执行完毕后原主shell继续运行。</strong></p>
<h3 id="1-3-fork（-home-script-sh）"><a href="#1-3-fork（-home-script-sh）" class="headerlink" title="1.3. fork（/home/script.sh）"></a>1.3. fork（/home/script.sh）</h3><p>直接运行脚本，会<strong>以当前shell为父进程，产生新的进程</strong>，并且<strong>继承主脚本的环境变量和声明变量</strong>。执行完毕后，<strong>主脚本不会保留其环境变量和声明变量</strong>。</p>
<p>总结：这样来看<code>fork</code>最灵活，<code>source</code>次之，<code>exec</code>最诡异。</p>
<h3 id="1-4-example"><a href="#1-4-example" class="headerlink" title="1.4. example"></a>1.4. example</h3><h5 id="主脚本"><a href="#主脚本" class="headerlink" title="主脚本"></a>主脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">a=main</span><br><span class="line"></span><br><span class="line">echo "a is $a"</span><br><span class="line">echo "PID for parent before 2.sh:$$"</span><br><span class="line">case $1 in</span><br><span class="line">  exec)</span><br><span class="line">    echo "using exec"</span><br><span class="line">    exec ./2.sh ;;</span><br><span class="line">  source)</span><br><span class="line">    echo "using sourcing"</span><br><span class="line">    source ./2.sh ;;</span><br><span class="line">  *)</span><br><span class="line">    echo "using fork"</span><br><span class="line">    ./2.sh ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">echo "PID FOR parent after 2.sh :$$"</span><br><span class="line"></span><br><span class="line">echo "now main.sh a is $a"</span><br><span class="line">echo "$b"</span><br></pre></td></tr></table></figure>

<h5 id="调用脚本：2-sh"><a href="#调用脚本：2-sh" class="headerlink" title="调用脚本：2.sh"></a>调用脚本：2.sh</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo "PID FOR 2.SH:$$"</span><br><span class="line"></span><br><span class="line">echo  "2.sh get a from main.sh is $a"</span><br><span class="line"></span><br><span class="line">a=2.sh</span><br><span class="line">export a</span><br><span class="line">b=3.sh</span><br><span class="line"></span><br><span class="line">echo "now 2.sh a is $a"</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./main.sh <span class="built_in">exec</span></span></span><br><span class="line">a is main</span><br><span class="line">PID for parent before 2.sh:19026</span><br><span class="line">using exec</span><br><span class="line">PID FOR 2.SH:19026</span><br><span class="line">2.sh get a from main.sh is main</span><br><span class="line">now a is 2.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./main.sh <span class="built_in">source</span></span></span><br><span class="line">a is main</span><br><span class="line">PID for parent before 2.sh:19027</span><br><span class="line">using sourcing</span><br><span class="line">PID FOR 2.SH:19027</span><br><span class="line">2.sh get a from main.sh is main</span><br><span class="line">now a is 2.sh</span><br><span class="line">PID FOR parent after 2.sh :19027</span><br><span class="line">now main.sh a is 2.sh</span><br><span class="line">3.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./main.sh fork</span></span><br><span class="line">a is main</span><br><span class="line">PID for parent before 2.sh:19028</span><br><span class="line">using fork</span><br><span class="line">PID FOR 2.SH:19029</span><br><span class="line">2.sh get a from main.sh is main</span><br><span class="line">now a is 2.sh</span><br><span class="line">PID FOR parent after 2.sh :19028</span><br><span class="line">now main.sh a is main</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://qujunorz.blog.51cto.com/6378776/1541676" target="_blank" rel="noopener">http://qujunorz.blog.51cto.com/6378776/1541676</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/protocol/TOTP/protocol-TOTP-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/protocol/TOTP/protocol-TOTP-overview/" itemprop="url">【一次性密码】TOTP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-08T20:45:00+08:00">
                2015-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/protocol/" itemprop="url" rel="index">
                    <span itemprop="name">protocol</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/protocol/TOTP/" itemprop="url" rel="index">
                    <span itemprop="name">TOTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-OTP"><a href="#1-OTP" class="headerlink" title="1. OTP"></a>1. OTP</h2><p><code>OTP(One-Time Password)</code>译为一次性密码，也称动态口令。是使用密码技术实现的在客户端和服务器之间通过共享秘密的一种认证技术，是一种强认证技术，是增强目前静态口令认证的一种非常方便技术手段，是一种重要的双因素认证技术。</p>
<h3 id="1-1-OTP的认证原理"><a href="#1-1-OTP的认证原理" class="headerlink" title="1.1 OTP的认证原理"></a>1.1 OTP的认证原理</h3><p>动态口令的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用的同一个种子密钥对某一个事件计数、或时间值、或者是异步挑战数进行密码算法计算，使用的算法有<code>对称算法</code>、<code>HASH</code>、<code>HMAC</code>，之后比较计算值是否一致进行认证。可以做到一次一个动态口令，使用后作废，口令长度通常为6-8个数字，使用方便，与通常的静态口令认证方式类似.</p>
<h3 id="1-3-OTP的实现方式"><a href="#1-3-OTP的实现方式" class="headerlink" title="1.3 OTP的实现方式"></a>1.3 OTP的实现方式</h3><ol>
<li>时间同步(<code>TOTP</code>)</li>
<li>事件同步(<code>HOTP</code>)</li>
<li>挑战/应答(<code>OCRA</code>)</li>
</ol>
<h2 id="2-HOTP"><a href="#2-HOTP" class="headerlink" title="2. HOTP"></a>2. HOTP</h2><p><code>HOTP(HMAC-base On-Time Password)</code>译为基于HMAC的一次性密码，也称事件同步的动态密码。</p>
<h3 id="2-1-HOTP的工作原理"><a href="#2-1-HOTP的工作原理" class="headerlink" title="2.1 HOTP的工作原理"></a>2.1 HOTP的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTOP(K,C) &#x3D; Truncate(HMAC-SHA-1(K,C))</span><br></pre></td></tr></table></figure>


<p>客户端和服务器事先协商好一个<code>密钥K</code>，用于一次性密码的生成过程。此外，客户端和服务器各有一个<code>计数器C</code>，并且事先将计数值同步。而<code>Truncate</code>是为了获得一个符合<code>HTOP</code>要求的值。</p>
<h2 id="3-TOTP"><a href="#3-TOTP" class="headerlink" title="3 TOTP"></a>3 TOTP</h2><p><code>TOTP(Time-base One-Time Password)</code>译为基于时间的一次性密码，也称时间同步的动态密码.</p>
<h3 id="3-1-TOTP的工作原理"><a href="#3-1-TOTP的工作原理" class="headerlink" title="3.1 TOTP的工作原理"></a>3.1 TOTP的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOTP &#x3D; Truncate(HMAC-SHA-1(K,T))</span><br></pre></td></tr></table></figure>

<p><code>TOTP</code>是<code>HOTP</code>的一个变种，将<code>HOTP</code>中的<code>计数器C</code>替换为依托时间的<code>参数T</code>，T是由当前时间(<code>CurrentUnixTime</code>、初始时间(T0)、步长(X)决定的。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T &#x3D; (Current Unix time - T0) &#x2F; X</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CurrentUnixTime</code>：当前的Unix时间。</li>
<li><code>T0</code>： 开始计步初始化时间，默认为0</li>
<li><code>X</code> : 步长，默认情况下为30s</li>
</ul>
<h3 id="3-2-TOTP的要求"><a href="#3-2-TOTP的要求" class="headerlink" title="3.2 TOTP的要求"></a>3.2 TOTP的要求</h3><ol>
<li>客户端和服务器必须能够彼此知道或者推算出对方的Unix Time</li>
<li>客户端和服务器端必须共享一个密钥</li>
<li>算法必须使用HOTP作为其关键实现环节</li>
<li>客户端和服务器端必须使用相同的步长X</li>
<li>每一个客户端必须拥有不同的密钥</li>
<li>密钥的生成必须足够随机</li>
<li>密钥必须储存在防篡改的设备上，而且不能在不安全的情况下被访问或使用。</li>
<li>对该算法中T的实现必须大于<code>int32</code>，因为它在2038年将超出上限。</li>
<li>T0和X的协商必须在之前的步骤中就已经做好了。</li>
</ol>
<h3 id="3-3-安全性考虑"><a href="#3-3-安全性考虑" class="headerlink" title="3.3 安全性考虑"></a>3.3 安全性考虑</h3><h4 id="3-3-1-安全性分析"><a href="#3-3-1-安全性分析" class="headerlink" title="3.3.1 安全性分析"></a>3.3.1 安全性分析</h4><p>该算法的安全性和健壮性完全依赖于其关键实现环节<code>HOTP</code>。</p>
<p>安全性分析的结果是：在所有的测试中，该算法的结果均匀的、独立的分布。这个分析显示，最好的攻击和破解<code>TOTP(HOTP)</code>的方法是暴力破解。而在算法要求环节，要求key必须有足够的随机性。</p>
<h4 id="3-3-2-时延兼容"><a href="#3-3-2-时延兼容" class="headerlink" title="3.3.2 时延兼容"></a>3.3.2 时延兼容</h4><p>在同一个步长内，动态密码生成的结果是一样的。当一个验证系统获得这个动态密码的时候，它并不知道动态密码的生产者是在哪个步长内产生的密码。由于网络的原因，客户端生成密码的时间和服务器接受密码的时间可能差距会很大，很有可能使得这2个时间不在同一个步长内。当一个动态密码产生在一个步长的结尾，服务器收到的密码很有可能在下一个步长的开始。</p>
<p>验证系统应该设置一个策略允许动态密码的传输时延，不应该只验证当前步长的动态密码，还应该验证之前几个步长的动态密码。但越大的传输时延窗口设置，就会带来越大的风险被攻击，我们推荐最多设置一个时延窗口来兼容传输延时。</p>
<h4 id="3-3-3-步长设置"><a href="#3-3-3-步长设置" class="headerlink" title="3.3.3 步长设置"></a>3.3.3 步长设置</h4><p>步长大小的设置，直接影响安全性和可用性:</p>
<ol>
<li>一个越大的步长，就会导致一个越大的窗口被攻击。当一个动态密码被生成而且在其有效期内暴露在第三方环境下，那么第三方系统就可以在该动态密码无效前使用这个密码。</li>
<li>我们推荐默认的步长时间是<code>30s</code>，这个默认值是在权衡了安全性和可用性的基础上提出的。</li>
<li>下一个动态密码肯定会在下一个步长生成，用户必须等待当前步长的结束。这个等待时间的理想值会随着步长的设置而增大。一个太长的窗口设置不使用网络用户登录这种场景，用户可能等不了一个步长的时间，就放弃登录。</li>
</ol>
<blockquote>
<p>参考资料：<br><a href="http://blog.csdn.net/janronehoo/article/details/7590976" target="_blank" rel="noopener">http://blog.csdn.net/janronehoo/article/details/7590976</a><br><a href="http://www.dannysite.com/blog/165/" target="_blank" rel="noopener">http://www.dannysite.com/blog/165/</a><br><a href="https://tools.ietf.org/html/rfc6238" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6238</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangxin201492.github.io/shell/shell-wait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxin201492">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangxin201492">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shell/shell-wait/" itemprop="url">【shell】我的wait为什么不能用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-18T20:01:48+08:00">
                2015-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>希望实现这样的一个功能：主脚本会运行几个后台进程，并希望这几个后台进程运行完之后，主进程才会退出。</p>
<p>RT,设想一个文件a，希望a的每一行都表示一个后台进程，有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat a</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>脚本<code>test_wait_1</code>这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> filename:test_wait_1</span></span><br><span class="line"></span><br><span class="line">cat a | while read line</span><br><span class="line">do</span><br><span class="line">    echo $line &amp;</span><br><span class="line">done</span><br><span class="line">wait</span><br><span class="line">echo "wait done"</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#result</span><br><span class="line">$ bash test_wait_1</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">wait done</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>显然，不尽如人意。</p>
<h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>脚本<code>test_wait_2</code>,做了一下修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> filename:test_wait_2</span></span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    echo $line &amp;</span><br><span class="line">done &lt; "a"</span><br><span class="line">wait</span><br><span class="line">echo "wait done"</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bash test_wait_2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">wait done</span><br></pre></td></tr></table></figure>

<p>结果符合预期！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>维基百科中有这样一段话：</p>
<blockquote>
<p>其中n是当前正在执行的后台进程的pid，或工作的工作ID。如果没有给定n，命令会等待shell调用的所有工作终止。</p>
</blockquote>
<blockquote>
<p>wait一般返回最后一个工作的退出状态。如果n所指的工作不存在，或没有工作要等待，它会返回127。</p>
</blockquote>
<blockquote>
<p>因为wait需要知道当前shell执行环境的工作表，它通常为shell内建命令。</p>
</blockquote>
<p>这样看来仿佛<code>test_wait_1</code>中的用法也没有什么问题，但实际上shell的管道<code>|</code>实际上是产生了一级子shell，也就是在<code>test_wait_1</code>中的后台进程<code>echo $line &amp;</code>是主进程子shell的后台进程。而<code>wait</code>只会等待当前进程的后台进程执行完毕，所以<code>test_wait_1</code>在遇到wait语句直接退出了。</p>
<p>而<code>test_wait_2</code>中，通过<code>&lt; &quot;a&quot;</code>将a文件的内容标准输入到<code>while</code>中，并未通过管道输入到<code>while</code>中，所以后台进程属于主进程。wait会等待所有的后台进程完成以后退出，</p>
<p>这也就是<code>test_wait_1</code>和<code>test_wait_2</code>这2个脚本运行的不同之处。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/Wait_(%E5%91%BD%E4%BB%A4)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Wait_(%E5%91%BD%E4%BB%A4)</a></p>
</li>
<li><p><a href="http://blog.csdn.net/shuanghujushi/article/details/38186303" target="_blank" rel="noopener">http://blog.csdn.net/shuanghujushi/article/details/38186303</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangxin201492</p>
              <p class="site-description motion-element" itemprop="description">my blogs</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wangxin201492" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wangxin201492@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangxin201492</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
